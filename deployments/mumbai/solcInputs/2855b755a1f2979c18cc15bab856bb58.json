{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlEnumerableUpgradeable.sol\";\nimport \"./AccessControlUpgradeable.sol\";\nimport \"../utils/structs/EnumerableSetUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerableUpgradeable is Initializable, IAccessControlEnumerableUpgradeable, AccessControlUpgradeable {\n    function __AccessControlEnumerable_init() internal onlyInitializing {\n    }\n\n    function __AccessControlEnumerable_init_unchained() internal onlyInitializing {\n    }\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    mapping(bytes32 => EnumerableSetUpgradeable.AddressSet) private _roleMembers;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlEnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\n        return _roleMembers[role].at(index);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\n        return _roleMembers[role].length();\n    }\n\n    /**\n     * @dev Overload {_grantRole} to track enumerable memberships\n     */\n    function _grantRole(bytes32 role, address account) internal virtual override {\n        super._grantRole(role, account);\n        _roleMembers[role].add(account);\n    }\n\n    /**\n     * @dev Overload {_revokeRole} to track enumerable memberships\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual override {\n        super._revokeRole(role, account);\n        _roleMembers[role].remove(account);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlEnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerableUpgradeable is IAccessControlUpgradeable {\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721Upgradeable.sol\";\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC1155/extensions/ERC1155Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC1155 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155PausableUpgradeable is Initializable, ERC1155Upgradeable, PausableUpgradeable {\n    function __ERC1155Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC1155Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        require(!paused(), \"ERC1155Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20PausableUpgradeable is Initializable, ERC20Upgradeable, PausableUpgradeable {\n    function __ERC20Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC20Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/presets/ERC20PresetMinterPauser.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../extensions/ERC20BurnableUpgradeable.sol\";\nimport \"../extensions/ERC20PausableUpgradeable.sol\";\nimport \"../../../access/AccessControlEnumerableUpgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC20} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to other accounts.\n *\n * _Deprecated in favor of https://wizard.openzeppelin.com/[Contracts Wizard]._\n */\ncontract ERC20PresetMinterPauserUpgradeable is Initializable, ContextUpgradeable, AccessControlEnumerableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable {\n    function initialize(string memory name, string memory symbol) public virtual initializer {\n        __ERC20PresetMinterPauser_init(name, symbol);\n    }\n    bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n    bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n    /**\n     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `PAUSER_ROLE` to the\n     * account that deploys the contract.\n     *\n     * See {ERC20-constructor}.\n     */\n    function __ERC20PresetMinterPauser_init(string memory name, string memory symbol) internal onlyInitializing {\n        __ERC20_init_unchained(name, symbol);\n        __Pausable_init_unchained();\n        __ERC20PresetMinterPauser_init_unchained(name, symbol);\n    }\n\n    function __ERC20PresetMinterPauser_init_unchained(string memory, string memory) internal onlyInitializing {\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\n        _setupRole(MINTER_ROLE, _msgSender());\n        _setupRole(PAUSER_ROLE, _msgSender());\n    }\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mint(address to, uint256 amount) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have minter role to mint\");\n        _mint(to, amount);\n    }\n\n    /**\n     * @dev Pauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_pause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function pause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to pause\");\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses all token transfers.\n     *\n     * See {ERC20Pausable} and {Pausable-_unpause}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `PAUSER_ROLE`.\n     */\n    function unpause() public virtual {\n        require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: must have pauser role to unpause\");\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override(ERC20Upgradeable, ERC20PausableUpgradeable) {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC721/extensions/ERC721Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../security/PausableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC721PausableUpgradeable is Initializable, ERC721Upgradeable, PausableUpgradeable {\n    function __ERC721Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __ERC721Pausable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        require(!paused(), \"ERC721Pausable: token transfer while paused\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../security/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract unpausable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_beforeTokenTransfer}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        require(!paused(), \"ERC20Pausable: token transfer while paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/external/ERC1155PresetPauserUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @dev {ERC1155} token, including a pauser role that allows to stop all token transfers\n * (including minting and burning).\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * Adapted from OZ's ERC1155PresetMinterPauserUpgradeable.sol: removed inheritance of\n * ERC1155BurnableUpgradeable; removed MINTER_ROLE; replaced DEFAULT_ADMIN_ROLE with OWNER_ROLE;\n * grants roles to owner param rather than `_msgSender()`; added `setURI()`, to give owner ability\n * to set the URI after initialization; added `isAdmin()` helper and `onlyAdmin` modifier.\n */\ncontract ERC1155PresetPauserUpgradeable is\n  Initializable,\n  ContextUpgradeable,\n  AccessControlEnumerableUpgradeable,\n  ERC1155PausableUpgradeable\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /**\n   * @dev Grants `OWNER_ROLE` and `PAUSER_ROLE` to the account that\n   * deploys the contract.\n   */\n  function __ERC1155PresetPauser_init(address owner, string memory uri) internal initializer {\n    __Context_init_unchained();\n    __ERC165_init_unchained();\n    __AccessControl_init_unchained();\n    __AccessControlEnumerable_init_unchained();\n    __ERC1155_init_unchained(uri);\n    __Pausable_init_unchained();\n    __ERC1155Pausable_init_unchained();\n    __ERC1155PresetPauser_init_unchained(owner);\n  }\n\n  function __ERC1155PresetPauser_init_unchained(address owner) internal initializer {\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function setURI(string memory newuri) external onlyAdmin {\n    /// @dev Because the `newuri` is not id-specific, we do not emit a URI event here. See the comment\n    /// on `_setURI()`.\n    _setURI(newuri);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC1155Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetPauser: must have pauser role to pause\");\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC1155Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public virtual {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC1155PresetPauser: must have pauser role to unpause\");\n    _unpause();\n  }\n\n  /**\n   * @dev See {IERC165-supportsInterface}.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(AccessControlEnumerableUpgradeable, ERC1155Upgradeable)\n    returns (bool)\n  {\n    return super.supportsInterface(interfaceId);\n  }\n\n  function _beforeTokenTransfer(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) internal virtual override(ERC1155PausableUpgradeable) {\n    super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n  }\n\n  uint256[50] private __gap;\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/external/ERC721PresetMinterPauserAutoId.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\n/*\n  This is copied from OZ preset: https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v3.0.0/contracts/presets/ERC721PresetMinterPauserAutoId.sol\n  Alterations:\n   * Make the counter public, so that we can use it in our custom mint function\n   * Removed ERC721Burnable parent contract, but added our own custom burn function.\n   * Removed original \"mint\" function, because we have a custom one.\n   * Removed default initialization functions, because they set msg.sender as the owner, which\n     we do not want, because we use a deployer account, which is separate from the protocol owner.\n*/\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721PausableUpgradeable.sol';\n\n/**\n * @dev {ERC721} token, including:\n *\n *  - ability for holders to burn (destroy) their tokens\n *  - a minter role that allows for token minting (creation)\n *  - a pauser role that allows to stop all token transfers\n *  - token ID and URI autogeneration\n *\n * This contract uses {AccessControl} to lock permissioned functions using the\n * different roles - head to its documentation for details.\n *\n * The account that deploys the contract will be granted the minter and pauser\n * roles, as well as the default admin role, which will let it grant both minter\n * and pauser roles to aother accounts\n */\ncontract ERC721PresetMinterPauserAutoIdUpgradeSafe is\n  Initializable,\n  ContextUpgradeable,\n  AccessControlUpgradeable,\n  ERC721PausableUpgradeable\n{\n  using Counters for Counters.Counter;\n\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  Counters.Counter public _tokenIdTracker;\n\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override(ERC721Upgradeable, AccessControlUpgradeable) returns (bool) {\n    return\n      interfaceId == type(IERC721Upgradeable).interfaceId ||\n      interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n      super.supportsInterface(interfaceId);\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC721Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() public {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to pause\");\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC721Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() public {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"ERC721PresetMinterPauserAutoId: must have pauser role to unpause\");\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId,\n    uint256 batchSize\n  ) internal virtual override(ERC721PausableUpgradeable) {\n    super._beforeTokenTransfer(from, to, tokenId, batchSize);\n  }\n\n  uint256[49] private __gap;\n}\n"
    },
    "contracts/external/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// solhint-disable\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n  using SafeMath for uint256;\n  using SignedSafeMath for int256;\n\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For unsigned values:\n  //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n  // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n  struct Unsigned {\n    uint256 rawValue;\n  }\n\n  /**\n   * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a uint to convert into a FixedPoint.\n   * @return the converted FixedPoint.\n   */\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return add(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return sub(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return sub(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as a uint256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n    if (mod != 0) {\n      return Unsigned(mulFloor.add(1));\n    } else {\n      return Unsigned(mulFloor);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as a uint256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a uint256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return div(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n    uint256 divFloor = aScaled.div(b.rawValue);\n    uint256 mod = aScaled.mod(b.rawValue);\n    if (mod != 0) {\n      return Unsigned(divFloor.add(1));\n    } else {\n      return Unsigned(divFloor);\n    }\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n    // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n    // This creates the possibility of overflow if b is very large.\n    return divCeil(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n    output = fromUnscaledUint(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n\n  // ------------------------------------------------- SIGNED -------------------------------------------------------------\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For signed values:\n  //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n  struct Signed {\n    int256 rawValue;\n  }\n\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n    require(a.rawValue >= 0, \"Negative value provided\");\n    return Unsigned(uint256(a.rawValue));\n  }\n\n  function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n    require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n    return Signed(int256(a.rawValue));\n  }\n\n  /**\n   * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a int to convert into a FixedPoint.Signed.\n   * @return the converted FixedPoint.Signed.\n   */\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n    return Signed(a.mul(SFP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a int256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return add(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return sub(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return sub(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as an int256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(mulTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(mulTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as an int256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a an int256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return div(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n    int256 divTowardsZero = aScaled.div(b.rawValue);\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = aScaled % b.rawValue;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(divTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(divTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n    // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n    // This creates the possibility of overflow if b is very large.\n    return divAwayFromZero(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint.Signed.\n   * @param b a uint256 (negative exponents are not allowed).\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n    output = fromUnscaledInt(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IBackerRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IBackerRewards {\n  function allocateRewards(uint256 _interestPaymentAmount) external;\n\n  function setPoolTokenAccRewardsPerPrincipalDollarAtMint(address poolAddress, uint256 tokenId) external;\n}\n"
    },
    "contracts/interfaces/IBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IBorrower {\n  function initialize(address owner, address _config) external;\n}\n"
    },
    "contracts/interfaces/ICommunityRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\";\n\nimport \"../interfaces/IERC20withDec.sol\";\n\ninterface ICommunityRewards is IERC721Upgradeable {\n  function rewardsToken() external view returns (IERC20withDec);\n\n  function claimableRewards(uint256 tokenId) external view returns (uint256 rewards);\n\n  function totalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 granted,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    uint256 revokedAt,\n    uint256 time\n  ) external pure returns (uint256 rewards);\n\n  function grant(\n    address recipient,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  ) external returns (uint256 tokenId);\n\n  function loadRewards(uint256 rewards) external;\n\n  function revokeGrant(uint256 tokenId) external;\n\n  function getReward(uint256 tokenId) external;\n\n  event RewardAdded(uint256 reward);\n  event Granted(\n    address indexed user,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  );\n  event GrantRevoked(uint256 indexed tokenId, uint256 totalUnvested);\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\n}\n"
    },
    "contracts/interfaces/ICreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract ICreditDesk {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit) external virtual;\n\n  function drawdown(address creditLineAddress, uint256 amount) external virtual;\n\n  function pay(address creditLineAddress, uint256 amount) external virtual;\n\n  function assessCreditLine(address creditLineAddress) external virtual;\n\n  function applyPayment(address creditLineAddress, uint256 amount) external virtual;\n\n  function getNextPaymentAmount(address creditLineAddress, uint256 asOfBLock) external view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface ICreditLine {\n  function borrower() external view returns (address);\n\n  function limit() external view returns (uint256);\n\n  function maxLimit() external view returns (uint256);\n\n  function interestApr() external view returns (uint256);\n\n  function paymentPeriodInDays() external view returns (uint256);\n\n  function principalGracePeriodInDays() external view returns (uint256);\n\n  function termInDays() external view returns (uint256);\n\n  function lateFeeApr() external view returns (uint256);\n\n  function isLate() external view returns (bool);\n\n  function withinPrincipalGracePeriod() external view returns (bool);\n\n  // Accounting variables\n  function balance() external view returns (uint256);\n\n  function interestOwed() external view returns (uint256);\n\n  function principalOwed() external view returns (uint256);\n\n  function termEndTime() external view returns (uint256);\n\n  function nextDueTime() external view returns (uint256);\n\n  function interestAccruedAsOf() external view returns (uint256);\n\n  function lastFullPaymentTime() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICUSDCContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\npragma solidity 0.8.4;\n\nimport \"./IERC20withDec.sol\";\n\ninterface ICUSDCContract is IERC20withDec {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDobermanConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IDobermanConfig {\n  function getNumber(uint256 index) external returns (uint256);\n\n  function getAddress(uint256 index) external returns (address);\n\n  function setAddress(uint256 index, address newAddress) external returns (address);\n\n  function setNumber(uint256 index, uint256 newNumber) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDobermanFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IDobermanFactory {\n  function createCreditLine() external returns (address);\n\n  function createBorrower(address owner) external returns (address);\n\n  function createPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function createMigratedPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function updateDobermanConfig() external;\n}\n"
    },
    "contracts/interfaces/IERC20withDec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20withDec is IERC20 {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IFidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./IERC20withDec.sol\";\n\ninterface IFidu is IERC20withDec {\n  function mintTo(address to, uint256 amount) external;\n\n  function burnFrom(address to, uint256 amount) external;\n\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0;\n  uint256 public constant ID_TYPE_1 = 1;\n  uint256 public constant ID_TYPE_2 = 2;\n  uint256 public constant ID_TYPE_3 = 3;\n  uint256 public constant ID_TYPE_4 = 4;\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (address);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(address account, uint256[] calldata onlyIdTypes) public view virtual returns (bool);\n\n  function goSeniorPool(address account) public view virtual returns (bool);\n\n  function updateDobermanConfig() external virtual;\n}\n"
    },
    "contracts/interfaces/IMerkleDirectDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\npragma solidity 0.8.4;\n\n/// @notice Enables the transfer of GFI rewards (referred to as a \"grant\"), if the grant details exist in this\n/// contract's Merkle root.\ninterface IMerkleDirectDistributor {\n  /// @notice Returns the address of the GFI contract that is the token distributed as rewards by\n  ///   this contract.\n  function gfi() external view returns (address);\n\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\n  function merkleRoot() external view returns (bytes32);\n\n  /// @notice Returns true if the index has been marked accepted.\n  function isGrantAccepted(uint256 index) external view returns (bool);\n\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\n  /// the inputs (which includes who the sender is) are invalid.\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    bytes32[] calldata merkleProof\n  ) external;\n\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\n  event GrantAccepted(uint256 indexed index, address indexed account, uint256 amount);\n}\n"
    },
    "contracts/interfaces/IMerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/interfaces/IMerkleDistributor.sol.\npragma solidity 0.8.4;\n\n/// @notice Enables the granting of a CommunityRewards grant, if the grant details exist in this\n/// contract's Merkle root.\ninterface IMerkleDistributor {\n  /// @notice Returns the address of the CommunityRewards contract whose grants are distributed by this contract.\n  function communityRewards() external view returns (address);\n\n  /// @notice Returns the merkle root of the merkle tree containing grant details available to accept.\n  function merkleRoot() external view returns (bytes32);\n\n  /// @notice Returns true if the index has been marked accepted.\n  function isGrantAccepted(uint256 index) external view returns (bool);\n\n  /// @notice Causes the sender to accept the grant consisting of the given details. Reverts if\n  /// the inputs (which includes who the sender is) are invalid.\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    bytes32[] calldata merkleProof\n  ) external;\n\n  /// @notice This event is triggered whenever a call to #acceptGrant succeeds.\n  event GrantAccepted(\n    uint256 indexed tokenId,\n    uint256 indexed index,\n    address indexed account,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  );\n}\n"
    },
    "contracts/interfaces/IMigrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IMigrate {\n  function pause() public virtual;\n\n  function unpause() public virtual;\n\n  function updateDobermanConfig() external virtual;\n\n  function grantRole(bytes32 role, address assignee) external virtual;\n\n  function renounceRole(bytes32 role, address self) external virtual;\n\n  // Proxy methods\n  function transferOwnership(address newOwner) external virtual;\n\n  function changeImplementation(address newImplementation, bytes calldata data) external virtual;\n\n  function owner() external view virtual returns (address);\n\n  // CreditDesk\n  function migrateV1CreditLine(\n    address _clToMigrate,\n    address borrower,\n    uint256 termEndTime,\n    uint256 nextDueTime,\n    uint256 interestAccruedAsOf,\n    uint256 lastFullPaymentTime,\n    uint256 totalInterestPaid\n  ) public virtual returns (address, address);\n\n  // Pool\n  function migrateToSeniorPool() external virtual;\n}\n"
    },
    "contracts/interfaces/IMigratedTranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./IV2CreditLine.sol\";\nimport \"./IV1CreditLine.sol\";\nimport \"./ITranchedPool.sol\";\n\nabstract contract IMigratedTranchedPool is ITranchedPool {\n  function migrateCreditLineToV2(\n    IV1CreditLine clToMigrate,\n    uint256 termEndTime,\n    uint256 nextDueTime,\n    uint256 interestAccruedAsOf,\n    uint256 lastFullPaymentTime,\n    uint256 totalInterestPaid\n  ) external virtual returns (IV2CreditLine);\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IPool {\n  uint256 public sharePrice;\n\n  function deposit(uint256 amount) external virtual;\n\n  function withdraw(uint256 usdcAmount) external virtual;\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual;\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public virtual;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool);\n\n  function drawdown(address to, uint256 amount) public virtual returns (bool);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n  function assets() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPoolBackup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// abstract contract IPool {\n//   uint256 public sharePrice;\n\n//   function deposit(uint256 amount) external virtual;\n\n//   function withdraw(uint256 usdcAmount) external virtual;\n\n//   function withdrawInFidu(uint256 fiduAmount) external virtual;\n\n//   function collectInterestAndPrincipal(\n//     address from,\n//     uint256 interest,\n//     uint256 principal\n//   ) public virtual;\n\n//   function transferFrom(\n//     address from,\n//     address to,\n//     uint256 amount\n//   ) public virtual returns (bool);\n\n//   function drawdown(address to, uint256 amount) public virtual returns (bool);\n\n//   function sweepToCompound() public virtual;\n\n//   function sweepFromCompound() public virtual;\n\n//   function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n//   function assets() public view virtual returns (uint256);\n// }\n"
    },
    "contracts/interfaces/IPoolTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IPoolTokens is IERC721Upgradeable {\n  event TokenMinted(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 tranche\n  );\n\n  event TokenRedeemed(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed,\n    uint256 tranche\n  );\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  struct TokenInfo {\n    address pool;\n    uint256 tranche;\n    uint256 principalAmount;\n    uint256 principalRedeemed;\n    uint256 interestRedeemed;\n  }\n\n  struct MintParams {\n    uint256 principalAmount;\n    uint256 tranche;\n  }\n\n  function mint(MintParams calldata params, address to) external returns (uint256);\n\n  function redeem(\n    uint256 tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed\n  ) external;\n\n  function burn(uint256 tokenId) external;\n\n  function onPoolCreated(address newPool) external;\n\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\n\n  function validPool(address sender) external view returns (bool);\n\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity 0.8.4;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal virtual view returns (bytes memory);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ISeniorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ITranchedPool.sol\";\n\nabstract contract ISeniorPool {\n  uint256 public sharePrice;\n  uint256 public totalLoansOutstanding;\n  uint256 public totalWritedowns;\n\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\n\n  function depositWithPermit(\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 depositShares);\n\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function invest(ITranchedPool pool) public virtual;\n\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\n\n  function redeem(uint256 tokenId) public virtual;\n\n  function writedown(uint256 tokenId) public virtual;\n\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\n\n  function assets() public view virtual returns (uint256);\n\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISeniorPoolBackup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// import \"./ITranchedPool.sol\";\n\n// abstract contract ISeniorPool {\n//   uint256 public sharePrice;\n//   uint256 public totalLoansOutstanding;\n//   uint256 public totalWritedowns;\n\n//   function deposit(uint256 amount) external virtual returns (uint256 depositShares);\n\n//   function depositWithPermit(\n//     uint256 amount,\n//     uint256 deadline,\n//     uint8 v,\n//     bytes32 r,\n//     bytes32 s\n//   ) external virtual returns (uint256 depositShares);\n\n//   function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\n\n//   function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\n\n//   function sweepToCompound() public virtual;\n\n//   function sweepFromCompound() public virtual;\n\n//   function invest(ITranchedPool pool) public virtual;\n\n//   function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\n\n//   function redeem(uint256 tokenId) public virtual;\n\n//   function writedown(uint256 tokenId) public virtual;\n\n//   function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\n\n//   function assets() public view virtual returns (uint256);\n\n//   function getNumShares(uint256 amount) public view virtual returns (uint256);\n// }\n"
    },
    "contracts/interfaces/ISeniorPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ISeniorPool.sol\";\nimport \"./ITranchedPool.sol\";\n\nabstract contract ISeniorPoolStrategy {\n  function getLeverageRatio(ITranchedPool pool) public view virtual returns (uint256);\n\n  function invest(ISeniorPool seniorPool, ITranchedPool pool) public view virtual returns (uint256 amount);\n\n  function estimateInvestment(ISeniorPool seniorPool, ITranchedPool pool) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./IV2CreditLine.sol\";\n\nabstract contract ITranchedPool {\n  IV2CreditLine public creditLine;\n  uint256 public createdAt;\n\n  enum Tranches {\n    Reserved,\n    Senior,\n    Junior\n  }\n\n  struct TrancheInfo {\n    uint256 id;\n    uint256 principalDeposited;\n    uint256 principalSharePrice;\n    uint256 interestSharePrice;\n    uint256 lockedUntil;\n  }\n\n  struct PoolSlice {\n    TrancheInfo seniorTranche;\n    TrancheInfo juniorTranche;\n    uint256 totalInterestAccrued;\n    uint256 principalDeployed;\n  }\n\n  struct SliceInfo {\n    uint256 reserveFeePercent;\n    uint256 interestAccrued;\n    uint256 principalAccrued;\n  }\n\n  struct ApplyResult {\n    uint256 interestRemaining;\n    uint256 principalRemaining;\n    uint256 reserveDeduction;\n    uint256 oldInterestSharePrice;\n    uint256 oldPrincipalSharePrice;\n  }\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public virtual;\n\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\n\n  function pay(uint256 amount) external virtual;\n\n  function lockJuniorCapital() external virtual;\n\n  function lockPool() external virtual;\n\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\n\n  function totalJuniorDeposits() external view virtual returns (uint256);\n\n  function drawdown(uint256 amount) external virtual;\n\n  function setFundableAt(uint256 timestamp) external virtual;\n\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\n\n  function assess() external virtual;\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 tokenId);\n\n  function availableToWithdraw(uint256 tokenId)\n    external\n    view\n    virtual\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\n\n  function withdraw(uint256 tokenId, uint256 amount)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMax(uint256 tokenId)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\n}\n"
    },
    "contracts/interfaces/IUniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\ninterface IUniqueIdentity is IERC1155Upgradeable {\n  function mint(\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) external payable;\n\n  function burn(\n    address account,\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) external;\n}\n"
    },
    "contracts/interfaces/IUniqueIdentity0612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/// @dev This interface provides a subset of the functionality of the IUniqueIdentity\n/// interface -- namely, the subset of functionality needed by Doberman protocol contracts\n/// compiled with Solidity version 0.6.12.\ninterface IUniqueIdentity0612 {\n  function balanceOf(address account, uint256 id) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IV1CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IV1CreditLine {\n  address public borrower;\n  address public underwriter;\n  uint256 public limit;\n  uint256 public interestApr;\n  uint256 public paymentPeriodInDays;\n  uint256 public termInDays;\n  uint256 public lateFeeApr;\n\n  uint256 public balance;\n  uint256 public interestOwed;\n  uint256 public principalOwed;\n  uint256 public termEndBlock;\n  uint256 public nextDueBlock;\n  uint256 public interestAccruedAsOfBlock;\n  uint256 public writedownAmount;\n  uint256 public lastFullPaymentBlock;\n\n  function setLimit(uint256 newAmount) external virtual;\n\n  function setBalance(uint256 newBalance) external virtual;\n}\n"
    },
    "contracts/interfaces/IV2CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ICreditLine.sol\";\n\nabstract contract IV2CreditLine is ICreditLine {\n  function principal() external view virtual returns (uint256);\n\n  function totalInterestAccrued() external view virtual returns (uint256);\n\n  function termStartTime() external view virtual returns (uint256);\n\n  function setLimit(uint256 newAmount) external virtual;\n\n  function setMaxLimit(uint256 newAmount) external virtual;\n\n  function setBalance(uint256 newBalance) external virtual;\n\n  function setPrincipal(uint256 _principal) external virtual;\n\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\n\n  function drawdown(uint256 amount) external virtual;\n\n  function assess()\n    external\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function initialize(\n    address _config,\n    address owner,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public virtual;\n\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\n\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\n\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\n\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\n\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\n\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\n\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\n\n  function updateDobermanConfig() external virtual;\n}\n"
    },
    "contracts/library/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity ^0.8.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/library/CommunityRewardsVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nlibrary CommunityRewardsVesting {\n  using SafeMath for uint256;\n  using CommunityRewardsVesting for Rewards;\n\n  /// @dev All time values in the Rewards struct (i.e. `startTime`, `endTime`,\n  /// `cliffLength`, `vestingInterval`, `revokedAt`) use the same units: seconds. All timestamp\n  /// values (i.e. `startTime`, `endTime`, `revokedAt`) are seconds since the unix epoch.\n  /// @dev `cliffLength` is the duration from the start of the grant, before which has elapsed\n  /// the vested amount remains 0.\n  /// @dev `vestingInterval` is the interval at which vesting occurs. For rewards to have\n  /// vested fully only at `endTime`, `vestingInterval` must be a factor of\n  /// `endTime.sub(startTime)`. If `vestingInterval` is not thusly a factor, the calculation\n  /// of `totalVestedAt()` would calculate rewards to have fully vested as of the time of the\n  /// last whole `vestingInterval`'s elapsing before `endTime`.\n  struct Rewards {\n    uint256 totalGranted;\n    uint256 totalClaimed;\n    uint256 startTime;\n    uint256 endTime;\n    uint256 cliffLength;\n    uint256 vestingInterval;\n    uint256 revokedAt;\n  }\n\n  function claim(Rewards storage rewards, uint256 reward) internal {\n    rewards.totalClaimed = rewards.totalClaimed.add(reward);\n  }\n\n  function claimable(Rewards storage rewards) internal view returns (uint256) {\n    return claimable(rewards, block.timestamp);\n  }\n\n  function claimable(Rewards storage rewards, uint256 time) internal view returns (uint256) {\n    return rewards.totalVestedAt(time).sub(rewards.totalClaimed);\n  }\n\n  function totalUnvestedAt(Rewards storage rewards, uint256 time) internal view returns (uint256) {\n    return rewards.totalGranted.sub(rewards.totalVestedAt(time));\n  }\n\n  function totalVestedAt(Rewards storage rewards, uint256 time) internal view returns (uint256) {\n    return\n      getTotalVestedAt(\n        rewards.startTime,\n        rewards.endTime,\n        rewards.totalGranted,\n        rewards.cliffLength,\n        rewards.vestingInterval,\n        rewards.revokedAt,\n        time\n      );\n  }\n\n  function getTotalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 granted,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    uint256 revokedAt,\n    uint256 time\n  ) internal pure returns (uint256) {\n    if (time < start.add(cliffLength)) {\n      return 0;\n    }\n\n    if (end <= start) {\n      return granted;\n    }\n\n    uint256 elapsedVestingTimestamp = revokedAt > 0 ? Math.min(revokedAt, time) : time;\n    uint256 elapsedVestingUnits = (elapsedVestingTimestamp.sub(start)).div(vestingInterval);\n    uint256 totalVestingUnits = (end.sub(start)).div(vestingInterval);\n    return Math.min(granted.mul(elapsedVestingUnits).div(totalVestingUnits), granted);\n  }\n}\n"
    },
    "contracts/library/SafeERC20Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Safe ERC20 Transfer\n * @notice Reverts when transfer is not successful\n * @author Doberman\n */\nabstract contract SafeERC20Transfer {\n  function safeERC20Transfer(\n    IERC20 erc20,\n    address to,\n    uint256 amount,\n    string memory message\n  ) internal {\n    require(to != address(0), \"Can't send to zero address\");\n    bool success = erc20.transfer(to, amount);\n    require(success, message);\n  }\n\n  function safeERC20Transfer(\n    IERC20 erc20,\n    address to,\n    uint256 amount\n  ) internal {\n    safeERC20Transfer(erc20, to, amount, \"Failed to transfer ERC20\");\n  }\n\n  function safeERC20TransferFrom(\n    IERC20 erc20,\n    address from,\n    address to,\n    uint256 amount,\n    string memory message\n  ) internal {\n    require(to != address(0), \"Can't send to zero address\");\n    bool success = erc20.transferFrom(from, to, amount);\n    require(success, message);\n  }\n\n  function safeERC20TransferFrom(\n    IERC20 erc20,\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    string memory message = \"Failed to transfer ERC20\";\n    safeERC20TransferFrom(erc20, from, to, amount, message);\n  }\n\n  function safeERC20Approve(\n    IERC20 erc20,\n    address spender,\n    uint256 allowance,\n    string memory message\n  ) internal {\n    bool success = erc20.approve(spender, allowance);\n    require(success, message);\n  }\n\n  function safeERC20Approve(\n    IERC20 erc20,\n    address spender,\n    uint256 allowance\n  ) internal {\n    string memory message = \"Failed to approve ERC20\";\n    safeERC20Approve(erc20, spender, allowance, message);\n  }\n}\n"
    },
    "contracts/library/StakingRewardsVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nlibrary StakingRewardsVesting {\n  using SafeMath for uint256;\n  using StakingRewardsVesting for Rewards;\n\n  uint256 internal constant PERCENTAGE_DECIMALS = 1e18;\n\n  struct Rewards {\n    uint256 totalUnvested;\n    uint256 totalVested;\n    uint256 totalPreviouslyVested;\n    uint256 totalClaimed;\n    uint256 startTime;\n    uint256 endTime;\n  }\n\n  function claim(Rewards storage rewards, uint256 reward) internal {\n    rewards.totalClaimed = rewards.totalClaimed.add(reward);\n  }\n\n  function claimable(Rewards storage rewards) internal view returns (uint256) {\n    return rewards.totalVested.add(rewards.totalPreviouslyVested).sub(rewards.totalClaimed);\n  }\n\n  function currentGrant(Rewards storage rewards) internal view returns (uint256) {\n    return rewards.totalUnvested.add(rewards.totalVested);\n  }\n\n  /// @notice Slash the vesting rewards by `percentage`. `percentage` of the unvested portion\n  ///   of the grant is forfeited. The remaining unvested portion continues to vest over the rest\n  ///   of the vesting schedule. The already vested portion continues to be claimable.\n  ///\n  ///   A motivating example:\n  ///\n  ///   Let's say we're 50% through vesting, with 100 tokens granted. Thus, 50 tokens are vested and 50 are unvested.\n  ///   Now let's say the grant is slashed by 90% (e.g. for StakingRewards, because the user unstaked 90% of their\n  ///   position). 45 of the unvested tokens will be forfeited. 5 of the unvested tokens and 5 of the vested tokens\n  ///   will be considered as the \"new grant\", which is 50% through vesting. The remaining 45 vested tokens will be\n  ///   still be claimable at any time.\n  function slash(Rewards storage rewards, uint256 percentage) internal {\n    require(percentage <= PERCENTAGE_DECIMALS, \"slashing percentage cannot be greater than 100%\");\n\n    uint256 unvestedToSlash = rewards.totalUnvested.mul(percentage).div(PERCENTAGE_DECIMALS);\n    uint256 vestedToMove = rewards.totalVested.mul(percentage).div(PERCENTAGE_DECIMALS);\n\n    rewards.totalUnvested = rewards.totalUnvested.sub(unvestedToSlash);\n    rewards.totalVested = rewards.totalVested.sub(vestedToMove);\n    rewards.totalPreviouslyVested = rewards.totalPreviouslyVested.add(vestedToMove);\n  }\n\n  function checkpoint(Rewards storage rewards) internal {\n    uint256 newTotalVested = totalVestedAt(rewards.startTime, rewards.endTime, block.timestamp, rewards.currentGrant());\n\n    if (newTotalVested > rewards.totalVested) {\n      uint256 difference = newTotalVested.sub(rewards.totalVested);\n      rewards.totalUnvested = rewards.totalUnvested.sub(difference);\n      rewards.totalVested = newTotalVested;\n    }\n  }\n\n  function totalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 time,\n    uint256 grantedAmount\n  ) internal pure returns (uint256) {\n    if (end <= start) {\n      return grantedAmount;\n    }\n\n    return Math.min(grantedAmount.mul(time.sub(start)).div(end.sub(start)), grantedAmount);\n  }\n}\n"
    },
    "contracts/protocol/core/Accountant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./CreditLine.sol\";\nimport \"../../interfaces/ICreditLine.sol\";\nimport \"../../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n/**\n * @title The Accountant\n * @notice Library for handling key financial calculations, such as interest and principal accrual.\n * @author Doberman\n */\n\nlibrary Accountant {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Signed;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for int256;\n  using FixedPoint for uint256;\n\n  // Scaling factor used by FixedPoint.sol. We need this to convert the fixed point raw values back to unscaled\n  uint256 public constant FP_SCALING_FACTOR = 10**18;\n  uint256 public constant INTEREST_DECIMALS = 1e18;\n  uint256 public constant SECONDS_PER_DAY = 60;\n  uint256 public constant SECONDS_PER_YEAR = (SECONDS_PER_DAY * 365);\n\n  struct PaymentAllocation {\n    uint256 interestPayment;\n    uint256 principalPayment;\n    uint256 additionalBalancePayment;\n  }\n\n  function calculateInterestAndPrincipalAccrued(\n    CreditLine cl,\n    uint256 timestamp,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    uint256 balance = cl.balance(); // gas optimization\n    uint256 interestAccrued = calculateInterestAccrued(cl, balance, timestamp, lateFeeGracePeriod);\n    uint256 principalAccrued = calculatePrincipalAccrued(cl, balance, timestamp);\n    return (interestAccrued, principalAccrued);\n  }\n\n  function calculateInterestAndPrincipalAccruedOverPeriod(\n    CreditLine cl,\n    uint256 balance,\n    uint256 startTime,\n    uint256 endTime,\n    uint256 lateFeeGracePeriod\n  ) public view returns (uint256, uint256) {\n    uint256 interestAccrued = calculateInterestAccruedOverPeriod(cl, balance, startTime, endTime, lateFeeGracePeriod);\n    uint256 principalAccrued = calculatePrincipalAccrued(cl, balance, endTime);\n    return (interestAccrued, principalAccrued);\n  }\n\n  function calculatePrincipalAccrued(\n    ICreditLine cl,\n    uint256 balance,\n    uint256 timestamp\n  ) public view returns (uint256) {\n    // If we've already accrued principal as of the term end time, then don't accrue more principal\n    uint256 termEndTime = cl.termEndTime();\n    if (cl.interestAccruedAsOf() >= termEndTime) {\n      return 0;\n    }\n    if (timestamp >= termEndTime) {\n      return balance;\n    } else {\n      return 0;\n    }\n  }\n\n  function calculateWritedownFor(\n    ICreditLine cl,\n    uint256 timestamp,\n    uint256 gracePeriodInDays,\n    uint256 maxDaysLate\n  ) public view returns (uint256, uint256) {\n    return calculateWritedownForPrincipal(cl, cl.balance(), timestamp, gracePeriodInDays, maxDaysLate);\n  }\n\n  function calculateWritedownForPrincipal(\n    ICreditLine cl,\n    uint256 principal,\n    uint256 timestamp,\n    uint256 gracePeriodInDays,\n    uint256 maxDaysLate\n  ) public view returns (uint256, uint256) {\n    FixedPoint.Unsigned memory amountOwedPerDay = calculateAmountOwedForOneDay(cl);\n    if (amountOwedPerDay.isEqual(0)) {\n      return (0, 0);\n    }\n    FixedPoint.Unsigned memory fpGracePeriod = FixedPoint.fromUnscaledUint(gracePeriodInDays);\n    FixedPoint.Unsigned memory daysLate;\n\n    // Excel math: =min(1,max(0,periods_late_in_days-graceperiod_in_days)/MAX_ALLOWED_DAYS_LATE) grace_period = 30,\n    // Before the term end date, we use the interestOwed to calculate the periods late. However, after the loan term\n    // has ended, since the interest is a much smaller fraction of the principal, we cannot reliably use interest to\n    // calculate the periods later.\n    uint256 totalOwed = cl.interestOwed().add(cl.principalOwed());\n    daysLate = FixedPoint.fromUnscaledUint(totalOwed).div(amountOwedPerDay);\n    if (timestamp > cl.termEndTime()) {\n      uint256 secondsLate = timestamp.sub(cl.termEndTime());\n      daysLate = daysLate.add(FixedPoint.fromUnscaledUint(secondsLate).div(SECONDS_PER_DAY));\n    }\n\n    FixedPoint.Unsigned memory maxLate = FixedPoint.fromUnscaledUint(maxDaysLate);\n    FixedPoint.Unsigned memory writedownPercent;\n    if (daysLate.isLessThanOrEqual(fpGracePeriod)) {\n      // Within the grace period, we don't have to write down, so assume 0%\n      writedownPercent = FixedPoint.fromUnscaledUint(0);\n    } else {\n      writedownPercent = FixedPoint.min(FixedPoint.fromUnscaledUint(1), (daysLate.sub(fpGracePeriod)).div(maxLate));\n    }\n\n    FixedPoint.Unsigned memory writedownAmount = writedownPercent.mul(principal).div(FP_SCALING_FACTOR);\n    // This will return a number between 0-100 representing the write down percent with no decimals\n    uint256 unscaledWritedownPercent = writedownPercent.mul(100).div(FP_SCALING_FACTOR).rawValue;\n    return (unscaledWritedownPercent, writedownAmount.rawValue);\n  }\n\n  function calculateAmountOwedForOneDay(ICreditLine cl) public view returns (FixedPoint.Unsigned memory interestOwed) {\n    // Determine theoretical interestOwed for one full day\n    uint256 totalInterestPerYear = cl.balance().mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    interestOwed = FixedPoint.fromUnscaledUint(totalInterestPerYear).div(365);\n    return interestOwed;\n  }\n\n  function calculateInterestAccrued(\n    CreditLine cl,\n    uint256 balance,\n    uint256 timestamp,\n    uint256 lateFeeGracePeriodInDays\n  ) public view returns (uint256) {\n    // We use Math.min here to prevent integer overflow (ie. go negative) when calculating\n    // numSecondsElapsed. Typically this shouldn't be possible, because\n    // the interestAccruedAsOf couldn't be *after* the current timestamp. However, when assessing\n    // we allow this function to be called with a past timestamp, which raises the possibility\n    // of overflow.\n    // This use of min should not generate incorrect interest calculations, since\n    // this function's purpose is just to normalize balances, and handing in a past timestamp\n    // will necessarily return zero interest accrued (because zero elapsed time), which is correct.\n    uint256 startTime = Math.min(timestamp, cl.interestAccruedAsOf());\n    return calculateInterestAccruedOverPeriod(cl, balance, startTime, timestamp, lateFeeGracePeriodInDays);\n  }\n\n  function calculateInterestAccruedOverPeriod(\n    CreditLine cl,\n    uint256 balance,\n    uint256 startTime,\n    uint256 endTime,\n    uint256 lateFeeGracePeriodInDays\n  ) public view returns (uint256 interestOwed) {\n    uint256 secondsElapsed = endTime.sub(startTime);\n    uint256 totalInterestPerYear = balance.mul(cl.interestApr()).div(INTEREST_DECIMALS);\n    interestOwed = totalInterestPerYear.mul(secondsElapsed).div(SECONDS_PER_YEAR);\n    if (lateFeeApplicable(cl, endTime, lateFeeGracePeriodInDays)) {\n      uint256 lateFeeInterestPerYear = balance.mul(cl.lateFeeApr()).div(INTEREST_DECIMALS);\n      uint256 additionalLateFeeInterest = lateFeeInterestPerYear.mul(secondsElapsed).div(SECONDS_PER_YEAR);\n      interestOwed = interestOwed.add(additionalLateFeeInterest);\n    }\n\n    return interestOwed;\n  }\n\n  function lateFeeApplicable(\n    CreditLine cl,\n    uint256 timestamp,\n    uint256 gracePeriodInDays\n  ) public view returns (bool) {\n    uint256 secondsLate = timestamp.sub(cl.lastFullPaymentTime());\n    return cl.lateFeeApr() > 0 && secondsLate > gracePeriodInDays.mul(SECONDS_PER_DAY);\n  }\n\n  function allocatePayment(\n    uint256 paymentAmount,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) public pure returns (PaymentAllocation memory) {\n    uint256 paymentRemaining = paymentAmount;\n    uint256 interestPayment = Math.min(interestOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(interestPayment);\n\n    uint256 principalPayment = Math.min(principalOwed, paymentRemaining);\n    paymentRemaining = paymentRemaining.sub(principalPayment);\n\n    uint256 balanceRemaining = balance.sub(principalPayment);\n    uint256 additionalBalancePayment = Math.min(paymentRemaining, balanceRemaining);\n\n    return\n      PaymentAllocation({\n        interestPayment: interestPayment,\n        principalPayment: principalPayment,\n        additionalBalancePayment: additionalBalancePayment\n      });\n  }\n}\n"
    },
    "contracts/protocol/core/BaseUpgradeablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./PauserPausable.sol\";\n\n/**\n * @title BaseUpgradeablePausable contract\n * @notice This is our Base contract that most other contracts inherit from. It includes many standard\n *  useful abilities like ugpradeability, pausability, access control, and re-entrancy guards.\n * @author Doberman\n */\n\ncontract BaseUpgradeablePausable is\n  Initializable,\n  AccessControlUpgradeable,\n  PauserPausable,\n  ReentrancyGuardUpgradeable\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  using SafeMath for uint256;\n  // Pre-reserving a few slots in the base contract in case we need to add things in the future.\n  // This does not actually take up gas cost or storage cost, but it does reserve the storage slots.\n  // See OpenZeppelin's use of this pattern here:\n  // https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/GSN/Context.sol#L37\n  uint256[50] private __gap1;\n  uint256[50] private __gap2;\n  uint256[50] private __gap3;\n  uint256[50] private __gap4;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __BaseUpgradeablePausable__init(address owner) public onlyInitializing {\n    require(owner != address(0), \"Owner cannot be the zero address\");\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./DobermanConfig.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IFidu.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/ISeniorPoolStrategy.sol\";\nimport \"../../interfaces/ICreditDesk.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/ICUSDCContract.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../interfaces/IBackerRewards.sol\";\nimport \"../../interfaces/IDobermanFactory.sol\";\nimport \"../../interfaces/IGo.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the DobermanConfig contract\n * @author Doberman\n */\n\nlibrary ConfigHelper {\n  function getPool(DobermanConfig config) internal view returns (IPool) {\n    return IPool(poolAddress(config));\n  }\n\n  function getSeniorPool(DobermanConfig config) internal view returns (ISeniorPool) {\n    return ISeniorPool(seniorPoolAddress(config));\n  }\n\n  function getSeniorPoolStrategy(DobermanConfig config) internal view returns (ISeniorPoolStrategy) {\n    return ISeniorPoolStrategy(seniorPoolStrategyAddress(config));\n  }\n\n  function getUSDC(DobermanConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(usdcAddress(config));\n  }\n\n  function getCreditDesk(DobermanConfig config) internal view returns (ICreditDesk) {\n    return ICreditDesk(creditDeskAddress(config));\n  }\n\n  function getFidu(DobermanConfig config) internal view returns (IFidu) {\n    return IFidu(fiduAddress(config));\n  }\n\n  function getCUSDCContract(DobermanConfig config) internal view returns (ICUSDCContract) {\n    return ICUSDCContract(cusdcContractAddress(config));\n  }\n\n  function getPoolTokens(DobermanConfig config) internal view returns (IPoolTokens) {\n    return IPoolTokens(poolTokensAddress(config));\n  }\n\n  function getBackerRewards(DobermanConfig config) internal view returns (IBackerRewards) {\n    return IBackerRewards(backerRewardsAddress(config));\n  }\n\n  function getDobermanFactory(DobermanConfig config) internal view returns (IDobermanFactory) {\n    return IDobermanFactory(DobermanFactoryAddress(config));\n  }\n\n  function getGFI(DobermanConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(gfiAddress(config));\n  }\n\n  function getGo(DobermanConfig config) internal view returns (IGo) {\n    return IGo(goAddress(config));\n  }\n\n  function oneInchAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.OneInch));\n  }\n\n  function creditLineImplementationAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditLineImplementation));\n  }\n\n  function trustedForwarderAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TrustedForwarder));\n  }\n\n  function configAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.DobermanConfig));\n  }\n\n  function poolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n  }\n\n  function poolTokensAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.PoolTokens));\n  }\n\n  function backerRewardsAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.BackerRewards));\n  }\n\n  function seniorPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.SeniorPool));\n  }\n\n  function seniorPoolStrategyAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.SeniorPoolStrategy));\n  }\n\n  function creditDeskAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditDesk));\n  }\n\n  function DobermanFactoryAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.DobermanFactory));\n  }\n\n  function gfiAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.GFI));\n  }\n\n  function fiduAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Fidu));\n  }\n\n  function cusdcContractAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CUSDCContract));\n  }\n\n  function usdcAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n  }\n\n  function tranchedPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TranchedPoolImplementation));\n  }\n\n  function migratedTranchedPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.MigratedTranchedPoolImplementation));\n  }\n\n  function reserveAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TreasuryReserve));\n  }\n\n  function protocolAdminAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.ProtocolAdmin));\n  }\n\n  function borrowerImplementationAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.BorrowerImplementation));\n  }\n\n  function goAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Go));\n  }\n\n  function stakingRewardsAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.StakingRewards));\n  }\n\n  function getReserveDenominator(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.ReserveDenominator));\n  }\n\n  function getWithdrawFeeDenominator(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator));\n  }\n\n  function getLatenessGracePeriodInDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays));\n  }\n\n  function getLatenessMaxDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays));\n  }\n\n  function getDrawdownPeriodInSeconds(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.DrawdownPeriodInSeconds));\n  }\n\n  function getTransferRestrictionPeriodInDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.TransferRestrictionPeriodInDays));\n  }\n\n  function getLeverageRatio(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LeverageRatio));\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title ConfigOptions\n * @notice A central place for enumerating the configurable options of our DobermanConfig contract\n * @author Doberman\n */\n\nlibrary ConfigOptions {\n  // NEVER EVER CHANGE THE ORDER OF THESE!\n  // You can rename or append. But NEVER change the order.\n  enum Numbers {\n    TransactionLimit,\n    TotalFundsLimit,\n    MaxUnderwriterLimit,\n    ReserveDenominator,\n    WithdrawFeeDenominator,\n    LatenessGracePeriodInDays,\n    LatenessMaxDays,\n    DrawdownPeriodInSeconds,\n    TransferRestrictionPeriodInDays,\n    LeverageRatio\n  }\n  enum Addresses {\n    Pool,\n    CreditLineImplementation,\n    DobermanFactory,\n    CreditDesk,\n    Fidu,\n    USDC,\n    TreasuryReserve,\n    ProtocolAdmin,\n    OneInch,\n    TrustedForwarder,\n    CUSDCContract,\n    DobermanConfig,\n    PoolTokens,\n    TranchedPoolImplementation,\n    SeniorPool,\n    SeniorPoolStrategy,\n    MigratedTranchedPoolImplementation,\n    BorrowerImplementation,\n    GFI,\n    Go,\n    BackerRewards,\n    StakingRewards\n  }\n}\n"
    },
    "contracts/protocol/core/CreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./Accountant.sol\";\nimport \"./CreditLine.sol\";\nimport \"./DobermanFactory.sol\";\nimport \"../../interfaces/IV1CreditLine.sol\";\nimport \"../../interfaces/IMigratedTranchedPool.sol\";\n\n/**\n * @title Doberman's CreditDesk contract\n * @notice Main entry point for borrowers and underwriters.\n *  Handles key logic for creating CreditLine's, borrowing money, repayment, etc.\n * @author Doberman\n */\n\ncontract CreditDesk is BaseUpgradeablePausable, ICreditDesk {\n  using SafeMath for uint256;\n  \n  uint256 public constant SECONDS_PER_DAY = 60;\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  struct Underwriter {\n    uint256 governanceLimit;\n    address[] creditLines;\n  }\n\n  struct Borrower {\n    address[] creditLines;\n  }\n\n  event PaymentApplied(\n    address indexed payer,\n    address indexed creditLine,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount\n  );\n  event PaymentCollected(address indexed payer, address indexed creditLine, uint256 paymentAmount);\n  event DrawdownMade(address indexed borrower, address indexed creditLine, uint256 drawdownAmount);\n  event CreditLineCreated(address indexed borrower, address indexed creditLine);\n  event GovernanceUpdatedUnderwriterLimit(address indexed underwriter, uint256 newLimit);\n\n  mapping(address => Underwriter) public underwriters;\n  mapping(address => Borrower) private borrowers;\n  mapping(address => address) private creditLines;\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the DobermanConfig contract\n   */\n  function initialize(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  /**\n   * @notice Sets a particular underwriter's limit of how much credit the DAO will allow them to \"create\"\n   * @param underwriterAddress The address of the underwriter for whom the limit shall change\n   * @param limit What the new limit will be set to\n   * Requirements:\n   *\n   * - the caller must have the `OWNER_ROLE`.\n   */\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit)\n    external\n    override\n    onlyAdmin\n    whenNotPaused\n  {\n    require(withinMaxUnderwriterLimit(limit), \"This limit is greater than the max allowed by the protocol\");\n    underwriters[underwriterAddress].governanceLimit = limit;\n    emit GovernanceUpdatedUnderwriterLimit(underwriterAddress, limit);\n  }\n\n  /**\n   * @notice Allows a borrower to drawdown on their creditline.\n   *  `amount` USDC is sent to the borrower, and the credit line accounting is updated.\n   * @param creditLineAddress The creditline from which they would like to drawdown\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown\n   *\n   * Requirements:\n   *\n   * - the caller must be the borrower on the creditLine\n   */\n  function drawdown(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    Borrower storage borrower = borrowers[msg.sender];\n    require(borrower.creditLines.length > 0, \"No credit lines exist for this borrower\");\n    require(amount > 0, \"Must drawdown more than zero\");\n    require(cl.borrower() == msg.sender, \"You are not the borrower of this credit line\");\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n    uint256 unappliedBalance = getUSDCBalance(creditLineAddress);\n    require(\n      withinCreditLimit(amount, unappliedBalance, cl),\n      \"The borrower does not have enough credit limit for this drawdown\"\n    );\n\n    uint256 balance = cl.balance();\n\n    if (balance == 0) {\n      cl.setInterestAccruedAsOf(currentTime());\n      cl.setLastFullPaymentTime(currentTime());\n    }\n\n    IPool pool = config.getPool();\n\n    // If there is any balance on the creditline that has not been applied yet, then use that first before\n    // drawing down from the pool. This is to support cases where the borrower partially pays back the\n    // principal before the due date, but then decides to drawdown again\n    uint256 amountToTransferFromCL;\n    if (unappliedBalance > 0) {\n      if (amount > unappliedBalance) {\n        amountToTransferFromCL = unappliedBalance;\n        amount = amount.sub(unappliedBalance);\n      } else {\n        amountToTransferFromCL = amount;\n        amount = 0;\n      }\n      bool success = pool.transferFrom(creditLineAddress, msg.sender, amountToTransferFromCL);\n      require(success, \"Failed to drawdown\");\n    }\n\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, currentTime());\n    balance = balance.add(amount);\n\n    updateCreditLineAccounting(cl, balance, interestOwed, principalOwed);\n\n    // Must put this after we update the credit line accounting, so we're using the latest\n    // interestOwed\n    require(!isLate(cl, currentTime()), \"Cannot drawdown when payments are past due\");\n    emit DrawdownMade(msg.sender, address(cl), amount.add(amountToTransferFromCL));\n\n    if (amount > 0) {\n      bool success = pool.drawdown(msg.sender, amount);\n      require(success, \"Failed to drawdown\");\n    }\n  }\n\n  /**\n   * @notice Allows a borrower to repay their loan. Payment is *collected* immediately (by sending it to\n   *  the individual CreditLine), but it is not *applied* unless it is after the nextDueTime, or until we assess\n   *  the credit line (ie. payment period end).\n   *  Any amounts over the minimum payment will be applied to outstanding principal (reducing the effective\n   *  interest rate). If there is still any left over, it will remain in the USDC Balance\n   *  of the CreditLine, which is held distinct from the Pool amounts, and can not be withdrawn by LP's.\n   * @param creditLineAddress The credit line to be paid back\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to pay\n   */\n  function pay(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    require(amount > 0, \"Must pay more than zero\");\n    CreditLine cl = CreditLine(creditLineAddress);\n\n    collectPayment(cl, amount);\n    assessCreditLine(creditLineAddress);\n  }\n\n  /**\n   * @notice Assesses a particular creditLine. This will apply payments, which will update accounting and\n   *  distribute gains or losses back to the pool accordingly. This function is idempotent, and anyone\n   *  is allowed to call it.\n   * @param creditLineAddress The creditline that should be assessed.\n   */\n  function assessCreditLine(address creditLineAddress)\n    public\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    // Do not assess until a full period has elapsed or past due\n    require(cl.balance() > 0, \"Must have balance to assess credit line\");\n\n    // Don't assess credit lines early!\n    if (currentTime() < cl.nextDueTime() && !isLate(cl, currentTime())) {\n      return;\n    }\n\n    uint256 timeToAssess = calculateNextDueTime(cl);\n    cl.setNextDueTime(timeToAssess);\n\n    // We always want to assess for the most recently *past* nextDueTime.\n    // So if the recalculation above sets the nextDueTime into the future,\n    // then ensure we pass in the one just before this.\n    if (timeToAssess > currentTime()) {\n      uint256 secondsPerPeriod = cl.paymentPeriodInDays().mul(SECONDS_PER_DAY);\n      timeToAssess = timeToAssess.sub(secondsPerPeriod);\n    }\n    _applyPayment(cl, getUSDCBalance(address(cl)), timeToAssess);\n  }\n\n  function applyPayment(address creditLineAddress, uint256 amount)\n    external\n    override\n    whenNotPaused\n    onlyValidCreditLine(creditLineAddress)\n  {\n    CreditLine cl = CreditLine(creditLineAddress);\n    require(cl.borrower() == msg.sender, \"You do not belong to this credit line\");\n    _applyPayment(cl, amount, currentTime());\n  }\n\n  function migrateV1CreditLine(\n    address _clToMigrate,\n    address borrower,\n    uint256 termEndTime,\n    uint256 nextDueTime,\n    uint256 interestAccruedAsOf,\n    uint256 lastFullPaymentTime,\n    uint256 totalInterestPaid\n  ) public onlyAdmin returns (address, address) {\n    IV1CreditLine clToMigrate = IV1CreditLine(_clToMigrate);\n    uint256 originalBalance = clToMigrate.balance();\n    require(clToMigrate.limit() > 0, \"Can't migrate empty credit line\");\n    require(originalBalance > 0, \"Can't migrate credit line that's currently paid off\");\n    // Ensure it is a v1 creditline by calling a function that only exists on v1\n    require(clToMigrate.nextDueBlock() > 0, \"Invalid creditline\");\n    if (borrower == address(0)) {\n      borrower = clToMigrate.borrower();\n    }\n    // We're migrating from 1e8 decimal precision of interest rates to 1e18\n    // So multiply the legacy rates by 1e10 to normalize them.\n    uint256 interestMigrationFactor = 1e10;\n    uint256[] memory allowedUIDTypes;\n    address pool = getDobermanFactory().createMigratedPool(\n      borrower,\n      20, // junior fee percent\n      clToMigrate.limit(),\n      clToMigrate.interestApr().mul(interestMigrationFactor),\n      clToMigrate.paymentPeriodInDays(),\n      clToMigrate.termInDays(),\n      clToMigrate.lateFeeApr(),\n      0,\n      0,\n      allowedUIDTypes\n    );\n\n    IV2CreditLine newCl = IMigratedTranchedPool(pool).migrateCreditLineToV2(\n      clToMigrate,\n      termEndTime,\n      nextDueTime,\n      interestAccruedAsOf,\n      lastFullPaymentTime,\n      totalInterestPaid\n    );\n\n    // Close out the original credit line\n    clToMigrate.setLimit(0);\n    clToMigrate.setBalance(0);\n\n    // Some sanity checks on the migration\n    require(newCl.balance() == originalBalance, \"Balance did not migrate properly\");\n    require(newCl.interestAccruedAsOf() == interestAccruedAsOf, \"Interest accrued as of did not migrate properly\");\n    return (address(newCl), pool);\n  }\n\n  /**\n   * @notice Simple getter for the creditlines of a given underwriter\n   * @param underwriterAddress The underwriter address you would like to see the credit lines of.\n   */\n  function getUnderwriterCreditLines(address underwriterAddress) public view returns (address[] memory) {\n    return underwriters[underwriterAddress].creditLines;\n  }\n\n  /**\n   * @notice Simple getter for the creditlines of a given borrower\n   * @param borrowerAddress The borrower address you would like to see the credit lines of.\n   */\n  function getBorrowerCreditLines(address borrowerAddress) public view returns (address[] memory) {\n    return borrowers[borrowerAddress].creditLines;\n  }\n\n  /**\n   * @notice This function is only meant to be used by frontends. It returns the total\n   * payment due for a given creditLine as of the provided timestamp. Returns 0 if no\n   * payment is due (e.g. asOf is before the nextDueTime)\n   * @param creditLineAddress The creditLine to calculate the payment for\n   * @param asOf The timestamp to use for the payment calculation, if it is set to 0, uses the current time\n   */\n  function getNextPaymentAmount(address creditLineAddress, uint256 asOf)\n    external\n    view\n    override\n    onlyValidCreditLine(creditLineAddress)\n    returns (uint256)\n  {\n    if (asOf == 0) {\n      asOf = currentTime();\n    }\n    CreditLine cl = CreditLine(creditLineAddress);\n\n    if (asOf < cl.nextDueTime() && !isLate(cl, currentTime())) {\n      return 0;\n    }\n\n    (uint256 interestAccrued, uint256 principalAccrued) = Accountant.calculateInterestAndPrincipalAccrued(\n      cl,\n      asOf,\n      config.getLatenessGracePeriodInDays()\n    );\n    return cl.interestOwed().add(interestAccrued).add(cl.principalOwed().add(principalAccrued));\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n  }\n\n  /*\n   * Internal Functions\n   */\n\n  /**\n   * @notice Collects `amount` of payment for a given credit line. This sends money from the payer to the credit line.\n   *  Note that payment is not *applied* when calling this function. Only collected (ie. held) for later application.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be collected\n   */\n  function collectPayment(CreditLine cl, uint256 amount) internal {\n    require(withinTransactionLimit(amount), \"Amount is over the per-transaction limit\");\n\n    emit PaymentCollected(msg.sender, address(cl), amount);\n\n    bool success = config.getPool().transferFrom(msg.sender, address(cl), amount);\n    require(success, \"Failed to collect payment\");\n  }\n\n  /**\n   * @notice Applies `amount` of payment for a given credit line. This moves already collected money into the Pool.\n   *  It also updates all the accounting variables. Note that interest is always paid back first, then principal.\n   *  Any extra after paying the minimum will go towards existing principal (reducing the\n   *  effective interest rate). Any extra after the full loan has been paid off will remain in the\n   *  USDC Balance of the creditLine, where it will be automatically used for the next drawdown.\n   * @param cl The CreditLine the payment will be collected for.\n   * @param amount The amount, in USDC atomic units, to be applied\n   * @param timestamp The timestamp on which accrual calculations should be based. This allows us\n   *  to be precise when we assess a Credit Line\n   */\n  function _applyPayment(\n    CreditLine cl,\n    uint256 amount,\n    uint256 timestamp\n  ) internal {\n    (uint256 paymentRemaining, uint256 interestPayment, uint256 principalPayment) = handlePayment(\n      cl,\n      amount,\n      timestamp\n    );\n\n    IPool pool = config.getPool();\n\n    if (interestPayment > 0 || principalPayment > 0) {\n      emit PaymentApplied(cl.borrower(), address(cl), interestPayment, principalPayment, paymentRemaining);\n      pool.collectInterestAndPrincipal(address(cl), interestPayment, principalPayment);\n    }\n  }\n\n  function handlePayment(\n    CreditLine cl,\n    uint256 paymentAmount,\n    uint256 timestamp\n  )\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 interestOwed, uint256 principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(cl, timestamp);\n    Accountant.PaymentAllocation memory pa = Accountant.allocatePayment(\n      paymentAmount,\n      cl.balance(),\n      interestOwed,\n      principalOwed\n    );\n\n    uint256 newBalance = cl.balance().sub(pa.principalPayment);\n    // Apply any additional payment towards the balance\n    newBalance = newBalance.sub(pa.additionalBalancePayment);\n    uint256 totalPrincipalPayment = cl.balance().sub(newBalance);\n    uint256 paymentRemaining = paymentAmount.sub(pa.interestPayment).sub(totalPrincipalPayment);\n\n    updateCreditLineAccounting(\n      cl,\n      newBalance,\n      interestOwed.sub(pa.interestPayment),\n      principalOwed.sub(pa.principalPayment)\n    );\n\n    assert(paymentRemaining.add(pa.interestPayment).add(totalPrincipalPayment) == paymentAmount);\n\n    return (paymentRemaining, pa.interestPayment, totalPrincipalPayment);\n  }\n\n  function isLate(CreditLine cl, uint256 timestamp) internal view returns (bool) {\n    uint256 secondsElapsedSinceFullPayment = timestamp.sub(cl.lastFullPaymentTime());\n    return secondsElapsedSinceFullPayment > cl.paymentPeriodInDays().mul(SECONDS_PER_DAY);\n  }\n\n  function getDobermanFactory() internal view returns (DobermanFactory) {\n    return DobermanFactory(config.getAddress(uint256(ConfigOptions.Addresses.DobermanFactory)));\n  }\n\n  function updateAndGetInterestAndPrincipalOwedAsOf(CreditLine cl, uint256 timestamp)\n    internal\n    returns (uint256, uint256)\n  {\n    (uint256 interestAccrued, uint256 principalAccrued) = Accountant.calculateInterestAndPrincipalAccrued(\n      cl,\n      timestamp,\n      config.getLatenessGracePeriodInDays()\n    );\n    if (interestAccrued > 0) {\n      // If we've accrued any interest, update interestAccruedAsOf to the time that we've\n      // calculated interest for. If we've not accrued any interest, then we keep the old value so the next\n      // time the entire period is taken into account.\n      cl.setInterestAccruedAsOf(timestamp);\n    }\n    return (cl.interestOwed().add(interestAccrued), cl.principalOwed().add(principalAccrued));\n  }\n\n  function withinCreditLimit(\n    uint256 amount,\n    uint256 unappliedBalance,\n    CreditLine cl\n  ) internal view returns (bool) {\n    return cl.balance().add(amount).sub(unappliedBalance) <= cl.limit();\n  }\n\n  function withinTransactionLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function calculateNewTermEndTime(CreditLine cl, uint256 balance) internal view returns (uint256) {\n    // If there's no balance, there's no loan, so there's no term end time\n    if (balance == 0) {\n      return 0;\n    }\n    // Don't allow any weird bugs where we add to your current end time. This\n    // function should only be used on new credit lines, when we are setting them up\n    if (cl.termEndTime() != 0) {\n      return cl.termEndTime();\n    }\n    return currentTime().add(SECONDS_PER_DAY.mul(cl.termInDays()));\n  }\n\n  function calculateNextDueTime(CreditLine cl) internal view returns (uint256) {\n    uint256 secondsPerPeriod = cl.paymentPeriodInDays().mul(SECONDS_PER_DAY);\n    uint256 balance = cl.balance();\n    uint256 nextDueTime = cl.nextDueTime();\n    uint256 curTimestamp = currentTime();\n    // You must have just done your first drawdown\n    if (nextDueTime == 0 && balance > 0) {\n      return curTimestamp.add(secondsPerPeriod);\n    }\n\n    // Active loan that has entered a new period, so return the *next* nextDueTime.\n    // But never return something after the termEndTime\n    if (balance > 0 && curTimestamp >= nextDueTime) {\n      uint256 secondsToAdvance = (curTimestamp.sub(nextDueTime).div(secondsPerPeriod)).add(1).mul(secondsPerPeriod);\n      nextDueTime = nextDueTime.add(secondsToAdvance);\n      return Math.min(nextDueTime, cl.termEndTime());\n    }\n\n    // Your paid off, or have not taken out a loan yet, so no next due time.\n    if (balance == 0 && nextDueTime != 0) {\n      return 0;\n    }\n    // Active loan in current period, where we've already set the nextDueTime correctly, so should not change.\n    if (balance > 0 && curTimestamp < nextDueTime) {\n      return nextDueTime;\n    }\n    revert(\"Error: could not calculate next due time.\");\n  }\n\n  function currentTime() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  function underwriterCanCreateThisCreditLine(uint256 newAmount, Underwriter storage underwriter)\n    internal\n    view\n    returns (bool)\n  {\n    uint256 underwriterLimit = underwriter.governanceLimit;\n    require(underwriterLimit != 0, \"underwriter does not have governance limit\");\n    uint256 creditCurrentlyExtended = getCreditCurrentlyExtended(underwriter);\n    uint256 totalToBeExtended = creditCurrentlyExtended.add(newAmount);\n    return totalToBeExtended <= underwriterLimit;\n  }\n\n  function withinMaxUnderwriterLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.MaxUnderwriterLimit));\n  }\n\n  function getCreditCurrentlyExtended(Underwriter storage underwriter) internal view returns (uint256) {\n    uint256 creditExtended;\n    uint256 length = underwriter.creditLines.length;\n    for (uint256 i = 0; i < length; i++) {\n      CreditLine cl = CreditLine(underwriter.creditLines[i]);\n      creditExtended = creditExtended.add(cl.limit());\n    }\n    return creditExtended;\n  }\n\n  function updateCreditLineAccounting(\n    CreditLine cl,\n    uint256 balance,\n    uint256 interestOwed,\n    uint256 principalOwed\n  ) internal nonReentrant {\n    // subtract cl from total loans outstanding\n    totalLoansOutstanding = totalLoansOutstanding.sub(cl.balance());\n\n    cl.setBalance(balance);\n    cl.setInterestOwed(interestOwed);\n    cl.setPrincipalOwed(principalOwed);\n\n    // This resets lastFullPaymentTime. These conditions assure that they have\n    // indeed paid off all their interest and they have a real nextDueTime. (ie. creditline isn't pre-drawdown)\n    uint256 nextDueTime = cl.nextDueTime();\n    if (interestOwed == 0 && nextDueTime != 0) {\n      // If interest was fully paid off, then set the last full payment as the previous due time\n      uint256 mostRecentLastDueTime;\n      if (currentTime() < nextDueTime) {\n        uint256 secondsPerPeriod = cl.paymentPeriodInDays().mul(SECONDS_PER_DAY);\n        mostRecentLastDueTime = nextDueTime.sub(secondsPerPeriod);\n      } else {\n        mostRecentLastDueTime = nextDueTime;\n      }\n      cl.setLastFullPaymentTime(mostRecentLastDueTime);\n    }\n\n    // Add new amount back to total loans outstanding\n    totalLoansOutstanding = totalLoansOutstanding.add(balance);\n\n    cl.setTermEndTime(calculateNewTermEndTime(cl, balance)); // pass in balance as a gas optimization\n    cl.setNextDueTime(calculateNextDueTime(cl));\n  }\n\n  function getUSDCBalance(address _address) internal view returns (uint256) {\n    return config.getUSDC().balanceOf(_address);\n  }\n\n  modifier onlyValidCreditLine(address clAddress) {\n    require(creditLines[clAddress] != address(0), \"Unknown credit line\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./DobermanConfig.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./Accountant.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/ICreditLine.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n/**\n * @title CreditLine\n * @notice A contract that represents the agreement between Backers and\n *  a Borrower. Includes the terms of the loan, as well as the current accounting state, such as interest owed.\n *  A CreditLine belongs to a TranchedPool, and is fully controlled by that TranchedPool. It does not\n *  operate in any standalone capacity. It should generally be considered internal to the TranchedPool.\n * @author Doberman\n */\n\n// solhint-disable-next-line max-states-count\ncontract CreditLine is BaseUpgradeablePausable, ICreditLine {\n  using SafeMath for uint256;\n\n  uint256 public constant SECONDS_PER_DAY = 60;\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  // Credit line terms\n  address public override borrower;\n  uint256 public currentLimit;\n  uint256 public override maxLimit;\n  uint256 public override interestApr;\n  uint256 public override paymentPeriodInDays;\n  uint256 public override termInDays;\n  uint256 public override principalGracePeriodInDays;\n  uint256 public override lateFeeApr;\n\n  // Accounting variables\n  uint256 public override balance;\n  uint256 public override interestOwed;\n  uint256 public override principalOwed;\n  uint256 public override termEndTime;\n  uint256 public override nextDueTime;\n  uint256 public override interestAccruedAsOf;\n  uint256 public override lastFullPaymentTime;\n  uint256 public totalInterestAccrued;\n\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  function initialize(\n    address _config,\n    address owner,\n    address _borrower,\n    uint256 _maxLimit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public initializer {\n    require(_config != address(0) && owner != address(0) && _borrower != address(0), \"Zero address passed in\");\n    __BaseUpgradeablePausable__init(owner);\n    config = DobermanConfig(_config);\n    borrower = _borrower;\n    maxLimit = _maxLimit;\n    interestApr = _interestApr;\n    paymentPeriodInDays = _paymentPeriodInDays;\n    termInDays = _termInDays;\n    lateFeeApr = _lateFeeApr;\n    principalGracePeriodInDays = _principalGracePeriodInDays;\n    interestAccruedAsOf = block.timestamp;\n\n    // Unlock owner, which is a TranchedPool, for infinite amount\n    bool success = config.getUSDC().approve(owner, type(uint256).max);\n    require(success, \"Failed to approve USDC\");\n  }\n\n  function limit() external view override returns (uint256) {\n    return currentLimit;\n  }\n\n  /**\n   * @notice Updates the internal accounting to track a drawdown as of current block timestamp.\n   * Does not move any money\n   * @param amount The amount in USDC that has been drawndown\n   */\n  function drawdown(uint256 amount) external onlyAdmin {\n    require(amount.add(balance) <= currentLimit, \"Cannot drawdown more than the limit\");\n    require(amount > 0, \"Invalid drawdown amount\");\n    uint256 timestamp = currentTime();\n\n    if (balance == 0) {\n      setInterestAccruedAsOf(timestamp);\n      setLastFullPaymentTime(timestamp);\n      setTotalInterestAccrued(0);\n      setTermEndTime(timestamp.add(SECONDS_PER_DAY.mul(termInDays)));\n    }\n\n    (uint256 _interestOwed, uint256 _principalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(timestamp);\n    balance = balance.add(amount);\n\n    updateCreditLineAccounting(balance, _interestOwed, _principalOwed);\n    require(!_isLate(timestamp), \"Cannot drawdown when payments are past due\");\n  }\n\n  /**\n   * @notice Migrates to a new Doberman config address\n   */\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  function setLateFeeApr(uint256 newLateFeeApr) external onlyAdmin {\n    lateFeeApr = newLateFeeApr;\n  }\n\n  function setLimit(uint256 newAmount) external onlyAdmin {\n    require(newAmount <= maxLimit, \"Cannot be more than the max limit\");\n    currentLimit = newAmount;\n  }\n\n  function setMaxLimit(uint256 newAmount) external onlyAdmin {\n    maxLimit = newAmount;\n  }\n\n  function termStartTime() external view returns (uint256) {\n    return _termStartTime();\n  }\n\n  function isLate() external view override returns (bool) {\n    return _isLate(block.timestamp);\n  }\n\n  function withinPrincipalGracePeriod() external view override returns (bool) {\n    if (termEndTime == 0) {\n      // Loan hasn't started yet\n      return true;\n    }\n    return block.timestamp < _termStartTime().add(principalGracePeriodInDays.mul(SECONDS_PER_DAY));\n  }\n\n  function setTermEndTime(uint256 newTermEndTime) public onlyAdmin {\n    termEndTime = newTermEndTime;\n  }\n\n  function setNextDueTime(uint256 newNextDueTime) public onlyAdmin {\n    nextDueTime = newNextDueTime;\n  }\n\n  function setBalance(uint256 newBalance) public onlyAdmin {\n    balance = newBalance;\n  }\n\n  function setTotalInterestAccrued(uint256 _totalInterestAccrued) public onlyAdmin {\n    totalInterestAccrued = _totalInterestAccrued;\n  }\n\n  function setInterestOwed(uint256 newInterestOwed) public onlyAdmin {\n    interestOwed = newInterestOwed;\n  }\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) public onlyAdmin {\n    principalOwed = newPrincipalOwed;\n  }\n\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) public onlyAdmin {\n    interestAccruedAsOf = newInterestAccruedAsOf;\n  }\n\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) public onlyAdmin {\n    lastFullPaymentTime = newLastFullPaymentTime;\n  }\n\n  /**\n   * @notice Triggers an assessment of the creditline. Any USDC balance available in the creditline is applied\n   * towards the interest and principal.\n   * @return Any amount remaining after applying payments towards the interest and principal\n   * @return Amount applied towards interest\n   * @return Amount applied towards principal\n   */\n  function assess()\n    public\n    onlyAdmin\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    // Do not assess until a full period has elapsed or past due\n    require(balance > 0, \"Must have balance to assess credit line\");\n\n    // Don't assess credit lines early!\n    if (currentTime() < nextDueTime && !_isLate(currentTime())) {\n      return (0, 0, 0);\n    }\n    uint256 timeToAssess = calculateNextDueTime();\n    setNextDueTime(timeToAssess);\n\n    // We always want to assess for the most recently *past* nextDueTime.\n    // So if the recalculation above sets the nextDueTime into the future,\n    // then ensure we pass in the one just before this.\n    if (timeToAssess > currentTime()) {\n      uint256 secondsPerPeriod = paymentPeriodInDays.mul(SECONDS_PER_DAY);\n      timeToAssess = timeToAssess.sub(secondsPerPeriod);\n    }\n    return handlePayment(getUSDCBalance(address(this)), timeToAssess);\n  }\n\n  function calculateNextDueTime() internal view returns (uint256) {\n    uint256 newNextDueTime = nextDueTime;\n    uint256 secondsPerPeriod = paymentPeriodInDays.mul(SECONDS_PER_DAY);\n    uint256 curTimestamp = currentTime();\n    // You must have just done your first drawdown\n    if (newNextDueTime == 0 && balance > 0) {\n      return curTimestamp.add(secondsPerPeriod);\n    }\n\n    // Active loan that has entered a new period, so return the *next* newNextDueTime.\n    // But never return something after the termEndTime\n    if (balance > 0 && curTimestamp >= newNextDueTime) {\n      uint256 secondsToAdvance = (curTimestamp.sub(newNextDueTime).div(secondsPerPeriod)).add(1).mul(secondsPerPeriod);\n      newNextDueTime = newNextDueTime.add(secondsToAdvance);\n      return Math.min(newNextDueTime, termEndTime);\n    }\n\n    // You're paid off, or have not taken out a loan yet, so no next due time.\n    if (balance == 0 && newNextDueTime != 0) {\n      return 0;\n    }\n    // Active loan in current period, where we've already set the newNextDueTime correctly, so should not change.\n    if (balance > 0 && curTimestamp < newNextDueTime) {\n      return newNextDueTime;\n    }\n    revert(\"Error: could not calculate next due time.\");\n  }\n\n  function currentTime() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  function _isLate(uint256 timestamp) internal view returns (bool) {\n    uint256 secondsElapsedSinceFullPayment = timestamp.sub(lastFullPaymentTime);\n    return balance > 0 && secondsElapsedSinceFullPayment > paymentPeriodInDays.mul(SECONDS_PER_DAY);\n  }\n\n  function _termStartTime() internal view returns (uint256) {\n    return termEndTime.sub(SECONDS_PER_DAY.mul(termInDays));\n  }\n\n  /**\n   * @notice Applies `amount` of payment for a given credit line. This moves already collected money into the Pool.\n   *  It also updates all the accounting variables. Note that interest is always paid back first, then principal.\n   *  Any extra after paying the minimum will go towards existing principal (reducing the\n   *  effective interest rate). Any extra after the full loan has been paid off will remain in the\n   *  USDC Balance of the creditLine, where it will be automatically used for the next drawdown.\n   * @param paymentAmount The amount, in USDC atomic units, to be applied\n   * @param timestamp The timestamp on which accrual calculations should be based. This allows us\n   *  to be precise when we assess a Credit Line\n   */\n  function handlePayment(uint256 paymentAmount, uint256 timestamp)\n    internal\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    (uint256 newInterestOwed, uint256 newPrincipalOwed) = updateAndGetInterestAndPrincipalOwedAsOf(timestamp);\n    Accountant.PaymentAllocation memory pa = Accountant.allocatePayment(\n      paymentAmount,\n      balance,\n      newInterestOwed,\n      newPrincipalOwed\n    );\n\n    uint256 newBalance = balance.sub(pa.principalPayment);\n    // Apply any additional payment towards the balance\n    newBalance = newBalance.sub(pa.additionalBalancePayment);\n    uint256 totalPrincipalPayment = balance.sub(newBalance);\n    uint256 paymentRemaining = paymentAmount.sub(pa.interestPayment).sub(totalPrincipalPayment);\n\n    updateCreditLineAccounting(\n      newBalance,\n      newInterestOwed.sub(pa.interestPayment),\n      newPrincipalOwed.sub(pa.principalPayment)\n    );\n\n    assert(paymentRemaining.add(pa.interestPayment).add(totalPrincipalPayment) == paymentAmount);\n\n    return (paymentRemaining, pa.interestPayment, totalPrincipalPayment);\n  }\n\n  function updateAndGetInterestAndPrincipalOwedAsOf(uint256 timestamp) internal returns (uint256, uint256) {\n    (uint256 interestAccrued, uint256 principalAccrued) = Accountant.calculateInterestAndPrincipalAccrued(\n      this,\n      timestamp,\n      config.getLatenessGracePeriodInDays()\n    );\n    if (interestAccrued > 0) {\n      // If we've accrued any interest, update interestAccruedAsOf to the time that we've\n      // calculated interest for. If we've not accrued any interest, then we keep the old value so the next\n      // time the entire period is taken into account.\n      setInterestAccruedAsOf(timestamp);\n      totalInterestAccrued = totalInterestAccrued.add(interestAccrued);\n    }\n    return (interestOwed.add(interestAccrued), principalOwed.add(principalAccrued));\n  }\n\n  function updateCreditLineAccounting(\n    uint256 newBalance,\n    uint256 newInterestOwed,\n    uint256 newPrincipalOwed\n  ) internal nonReentrant {\n    setBalance(newBalance);\n    setInterestOwed(newInterestOwed);\n    setPrincipalOwed(newPrincipalOwed);\n\n    // This resets lastFullPaymentTime. These conditions assure that they have\n    // indeed paid off all their interest and they have a real nextDueTime. (ie. creditline isn't pre-drawdown)\n    uint256 _nextDueTime = nextDueTime;\n    if (newInterestOwed == 0 && _nextDueTime != 0) {\n      // If interest was fully paid off, then set the last full payment as the previous due time\n      uint256 mostRecentLastDueTime;\n      if (currentTime() < _nextDueTime) {\n        uint256 secondsPerPeriod = paymentPeriodInDays.mul(SECONDS_PER_DAY);\n        mostRecentLastDueTime = _nextDueTime.sub(secondsPerPeriod);\n      } else {\n        mostRecentLastDueTime = _nextDueTime;\n      }\n      setLastFullPaymentTime(mostRecentLastDueTime);\n    }\n\n    setNextDueTime(calculateNextDueTime());\n  }\n\n  function getUSDCBalance(address _address) internal view returns (uint256) {\n    return config.getUSDC().balanceOf(_address);\n  }\n}\n"
    },
    "contracts/protocol/core/DobermanConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../../interfaces/IDobermanConfig.sol\";\nimport \"./ConfigOptions.sol\";\n\n/**\n * @title DobermanConfig\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. For example, the TransactionLimit, or the PoolAddress. These config vars\n *  are enumerated in the `ConfigOptions` library, and can only be changed by admins of the protocol.\n *  Note: While this inherits from BaseUpgradeablePausable, it is not deployed as an upgradeable contract (this\n *    is mostly to save gas costs of having each call go through a proxy)\n * @author Doberman\n */\n\ncontract DobermanConfig is BaseUpgradeablePausable {\n  bytes32 public constant GO_LISTER_ROLE = keccak256(\"GO_LISTER_ROLE\");\n\n  mapping(uint256 => address) public addresses;\n  mapping(uint256 => uint256) public numbers;\n  mapping(address => bool) public goList;\n\n  event AddressUpdated(address owner, uint256 index, address oldValue, address newValue);\n  event NumberUpdated(address owner, uint256 index, uint256 oldValue, uint256 newValue);\n\n  event GoListed(address indexed member);\n  event NoListed(address indexed member);\n\n  bool public valuesInitialized;\n\n  function initialize(address owner) public initializer {\n    require(owner != address(0), \"Owner address cannot be empty\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    _setupRole(GO_LISTER_ROLE, owner);\n\n    _setRoleAdmin(GO_LISTER_ROLE, OWNER_ROLE);\n  }\n\n  function setAddress(uint256 addressIndex, address newAddress) public onlyAdmin {\n    // require(addresses[addressIndex] == address(0), \"Address has already been initialized\");\n\n    emit AddressUpdated(msg.sender, addressIndex, addresses[addressIndex], newAddress);\n    addresses[addressIndex] = newAddress;\n  }\n\n  function setNumber(uint256 index, uint256 newNumber) public onlyAdmin {\n    emit NumberUpdated(msg.sender, index, numbers[index], newNumber);\n    numbers[index] = newNumber;\n  }\n\n  function setTreasuryReserve(address newTreasuryReserve) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TreasuryReserve);\n    emit AddressUpdated(msg.sender, key, addresses[key], newTreasuryReserve);\n    addresses[key] = newTreasuryReserve;\n  }\n\n  function setSeniorPoolStrategy(address newStrategy) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.SeniorPoolStrategy);\n    emit AddressUpdated(msg.sender, key, addresses[key], newStrategy);\n    addresses[key] = newStrategy;\n  }\n\n  function setCreditLineImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.CreditLineImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setTranchedPoolImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TranchedPoolImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setBorrowerImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.BorrowerImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setDobermanConfig(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.DobermanConfig);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function initializeFromOtherConfig(\n    address _initialConfig,\n    uint256 numbersLength,\n    uint256 addressesLength\n  ) public onlyAdmin {\n    require(!valuesInitialized, \"Already initialized values\");\n    IDobermanConfig initialConfig = IDobermanConfig(_initialConfig);\n    for (uint256 i = 0; i < numbersLength; i++) {\n      setNumber(i, initialConfig.getNumber(i));\n    }\n\n    for (uint256 i = 0; i < addressesLength; i++) {\n      if (getAddress(i) == address(0)) {\n        setAddress(i, initialConfig.getAddress(i));\n      }\n    }\n    valuesInitialized = true;\n  }\n\n  /**\n   * @dev Adds a user to go-list\n   * @param _member address to add to go-list\n   */\n  function addToGoList(address _member) public onlyGoListerRole {\n    goList[_member] = true;\n    emit GoListed(_member);\n  }\n\n  /**\n   * @dev removes a user from go-list\n   * @param _member address to remove from go-list\n   */\n  function removeFromGoList(address _member) public onlyGoListerRole {\n    goList[_member] = false;\n    emit NoListed(_member);\n  }\n\n  /**\n   * @dev adds many users to go-list at once\n   * @param _members addresses to ad to go-list\n   */\n  function bulkAddToGoList(address[] calldata _members) external onlyGoListerRole {\n    for (uint256 i = 0; i < _members.length; i++) {\n      addToGoList(_members[i]);\n    }\n  }\n\n  /**\n   * @dev removes many users from go-list at once\n   * @param _members addresses to remove from go-list\n   */\n  function bulkRemoveFromGoList(address[] calldata _members) external onlyGoListerRole {\n    for (uint256 i = 0; i < _members.length; i++) {\n      removeFromGoList(_members[i]);\n    }\n  }\n\n  /*\n    Using custom getters in case we want to change underlying implementation later,\n    or add checks or validations later on.\n  */\n  function getAddress(uint256 index) public view returns (address) {\n    return addresses[index];\n  }\n\n  function getNumber(uint256 index) public view returns (uint256) {\n    return numbers[index];\n  }\n\n  modifier onlyGoListerRole() {\n    require(hasRole(GO_LISTER_ROLE, _msgSender()), \"Must have go-lister role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/DobermanFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./DobermanConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../../interfaces/IBorrower.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title DobermanFactory\n * @notice Contract that allows us to create other contracts, such as CreditLines and BorrowerContracts\n *  Note DobermanFactory is a legacy name. More properly this can be considered simply the DobermanFactory\n * @author Doberman\n */\n\ncontract DobermanFactory is BaseUpgradeablePausable {\n  DobermanConfig public config;\n\n  /// Role to allow for pool creation\n  bytes32 public constant BORROWER_ROLE = keccak256(\"BORROWER_ROLE\");\n\n  using ConfigHelper for DobermanConfig;\n\n  event BorrowerCreated(address indexed borrower, address indexed owner);\n  event PoolCreated(address indexed pool, address indexed borrower);\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n  event CreditLineCreated(address indexed creditLine);\n\n  function initialize(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n    _performUpgrade();\n  }\n\n  function performUpgrade() external onlyAdmin {\n    _performUpgrade();\n  }\n\n  function _performUpgrade() internal {\n    if (getRoleAdmin(BORROWER_ROLE) != OWNER_ROLE) {\n      _setRoleAdmin(BORROWER_ROLE, OWNER_ROLE);\n    }\n  }\n\n  /**\n   * @notice Allows anyone to create a CreditLine contract instance\n   * @dev There is no value to calling this function directly. It is only meant to be called\n   *  by a TranchedPool during it's creation process.\n   */\n  function createCreditLine() external returns (address) {\n    address creditLine = deployMinimal(config.creditLineImplementationAddress());\n    emit CreditLineCreated(creditLine);\n    return creditLine;\n  }\n\n  /**\n   * @notice Allows anyone to create a Borrower contract instance\n   * @param owner The address that will own the new Borrower instance\n   */\n  function createBorrower(address owner) external returns (address) {\n    address _borrower = deployMinimal(config.borrowerImplementationAddress());\n    IBorrower borrower = IBorrower(_borrower);\n    borrower.initialize(owner, address(config));\n    emit BorrowerCreated(address(borrower), owner);\n    return address(borrower);\n  }\n\n  /**\n   * @notice Allows anyone to create a new TranchedPool for a single borrower\n   * @param _borrower The borrower for whom the CreditLine will be created\n   * @param _juniorFeePercent The percent of senior interest allocated to junior investors, expressed as\n   *  integer percents. eg. 20% is simply 20\n   * @param _limit The maximum amount a borrower can drawdown from this CreditLine\n   * @param _interestApr The interest amount, on an annualized basis (APR, so non-compounding), expressed as an integer.\n   *  We assume 18 digits of precision. For example, to submit 15.34%, you would pass up 153400000000000000,\n   *  and 5.34% would be 53400000000000000\n   * @param _paymentPeriodInDays How many days in each payment period.\n   *  ie. the frequency with which they need to make payments.\n   * @param _termInDays Number of days in the credit term. It is used to set the `termEndTime` upon first drawdown.\n   *  ie. The credit line should be fully paid off {_termIndays} days after the first drawdown.\n   * @param _lateFeeApr The additional interest you will pay if you are late. For example, if this is 3%, and your\n   *  normal rate is 15%, then you will pay 18% while you are late. Also expressed as an 18 decimal precision integer\n   *\n   * Requirements:\n   *  You are the admin\n   */\n  function createPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external onlyAdminOrBorrower returns (address pool) {\n    address tranchedPoolImplAddress = config.tranchedPoolAddress();\n    pool = deployMinimal(tranchedPoolImplAddress);\n    ITranchedPool(pool).initialize(\n      address(config),\n      _borrower,\n      _juniorFeePercent,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays,\n      _fundableAt,\n      _allowedUIDTypes\n    );\n    emit PoolCreated(pool, _borrower);\n    config.getPoolTokens().onPoolCreated(pool);\n    return pool;\n  }\n\n  function createMigratedPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) external onlyCreditDesk returns (address pool) {\n    address tranchedPoolImplAddress = config.migratedTranchedPoolAddress();\n    pool = deployMinimal(tranchedPoolImplAddress);\n    ITranchedPool(pool).initialize(\n      address(config),\n      _borrower,\n      _juniorFeePercent,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays,\n      _fundableAt,\n      _allowedUIDTypes\n    );\n    emit PoolCreated(pool, _borrower);\n    config.getPoolTokens().onPoolCreated(pool);\n    return pool;\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  // Stolen from:\n  // https://github.com/OpenZeppelin/openzeppelin-sdk/blob/master/packages/lib/contracts/upgradeability/ProxyFactory.sol\n  function deployMinimal(address _logic) internal returns (address proxy) {\n    bytes20 targetBytes = bytes20(_logic);\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      proxy := create(0, clone, 0x37)\n    }\n    return proxy;\n  }\n\n  function isBorrower() public view returns (bool) {\n    return hasRole(BORROWER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdminOrBorrower() {\n    require(isAdmin() || isBorrower(), \"Must have admin or borrower role to perform this action\");\n    _;\n  }\n\n  modifier onlyCreditDesk() {\n    require(msg.sender == config.creditDeskAddress(), \"Only the CreditDesk can call this\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/DynamicLeverageRatioStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./LeverageRatioStrategy.sol\";\nimport \"../../interfaces/ISeniorPoolStrategy.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract DynamicLeverageRatioStrategy is LeverageRatioStrategy {\n  bytes32 public constant LEVERAGE_RATIO_SETTER_ROLE = keccak256(\"LEVERAGE_RATIO_SETTER_ROLE\");\n\n  struct LeverageRatioInfo {\n    uint256 leverageRatio;\n    uint256 juniorTrancheLockedUntil;\n  }\n\n  // tranchedPoolAddress => leverageRatioInfo\n  mapping(address => LeverageRatioInfo) public ratios;\n\n  event LeverageRatioUpdated(\n    address indexed pool,\n    uint256 leverageRatio,\n    uint256 juniorTrancheLockedUntil,\n    bytes32 version\n  );\n\n  function initialize(address owner) public initializer {\n    require(owner != address(0), \"Owner address cannot be empty\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    _setupRole(LEVERAGE_RATIO_SETTER_ROLE, owner);\n\n    _setRoleAdmin(LEVERAGE_RATIO_SETTER_ROLE, OWNER_ROLE);\n  }\n\n  function getLeverageRatio(ITranchedPool pool) public view override returns (uint256) {\n    LeverageRatioInfo memory ratioInfo = ratios[address(pool)];\n    ITranchedPool.TrancheInfo memory juniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Junior));\n    ITranchedPool.TrancheInfo memory seniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Senior));\n\n    require(ratioInfo.juniorTrancheLockedUntil > 0, \"Leverage ratio has not been set yet.\");\n    if (seniorTranche.lockedUntil > 0) {\n      // The senior tranche is locked. Coherence check: we expect locking the senior tranche to have\n      // updated `juniorTranche.lockedUntil` (compared to its value when `setLeverageRatio()` was last\n      // called successfully).\n      require(\n        ratioInfo.juniorTrancheLockedUntil < juniorTranche.lockedUntil,\n        \"Expected junior tranche `lockedUntil` to have been updated.\"\n      );\n    } else {\n      require(\n        ratioInfo.juniorTrancheLockedUntil == juniorTranche.lockedUntil,\n        \"Leverage ratio is obsolete. Wait for its recalculation.\"\n      );\n    }\n\n    return ratioInfo.leverageRatio;\n  }\n\n  /**\n   * @notice Updates the leverage ratio for the specified tranched pool. The combination of the\n   * `juniorTranchedLockedUntil` param and the `version` param in the event emitted by this\n   * function are intended to enable an outside observer to verify the computation of the leverage\n   * ratio set by calls of this function.\n   * @param pool The tranched pool whose leverage ratio to update.\n   * @param leverageRatio The leverage ratio value to set for the tranched pool.\n   * @param juniorTrancheLockedUntil The `lockedUntil` timestamp, of the tranched pool's\n   * junior tranche, to which this calculation of `leverageRatio` corresponds, i.e. the\n   * value of the `lockedUntil` timestamp of the JuniorCapitalLocked event which the caller\n   * is calling this function in response to having observed. By providing this timestamp\n   * (plus an assumption that we can trust the caller to report this value accurately),\n   * the caller enables this function to enforce that a leverage ratio that is obsolete in\n   * the sense of having been calculated for an obsolete `lockedUntil` timestamp cannot be set.\n   * @param version An arbitrary identifier included in the LeverageRatioUpdated event emitted\n   * by this function, enabling the caller to describe how it calculated `leverageRatio`. Using\n   * the bytes32 type accommodates using git commit hashes (both the current SHA1 hashes, which\n   * require 20 bytes; and the future SHA256 hashes, which require 32 bytes) for this value.\n   */\n  function setLeverageRatio(\n    ITranchedPool pool,\n    uint256 leverageRatio,\n    uint256 juniorTrancheLockedUntil,\n    bytes32 version\n  ) public onlySetterRole {\n    ITranchedPool.TrancheInfo memory juniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Junior));\n    ITranchedPool.TrancheInfo memory seniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Senior));\n\n    // NOTE: We allow a `leverageRatio` of 0.\n    require(\n      leverageRatio <= 10 * LEVERAGE_RATIO_DECIMALS,\n      \"Leverage ratio must not exceed 10 (adjusted for decimals).\"\n    );\n\n    require(juniorTranche.lockedUntil > 0, \"Cannot set leverage ratio if junior tranche is not locked.\");\n    require(seniorTranche.lockedUntil == 0, \"Cannot set leverage ratio if senior tranche is locked.\");\n    require(juniorTrancheLockedUntil == juniorTranche.lockedUntil, \"Invalid `juniorTrancheLockedUntil` timestamp.\");\n\n    ratios[address(pool)] = LeverageRatioInfo({\n      leverageRatio: leverageRatio,\n      juniorTrancheLockedUntil: juniorTrancheLockedUntil\n    });\n\n    emit LeverageRatioUpdated(address(pool), leverageRatio, juniorTrancheLockedUntil, version);\n  }\n\n  modifier onlySetterRole() {\n    require(\n      hasRole(LEVERAGE_RATIO_SETTER_ROLE, _msgSender()),\n      \"Must have leverage-ratio setter role to perform this action\"\n    );\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/Fidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/presets/ERC20PresetMinterPauserUpgradeable.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Fidu\n * @notice Fidu (symbol: FIDU) is Doberman's liquidity token, representing shares\n *  in the Pool. When you deposit, we mint a corresponding amount of Fidu, and when you withdraw, we\n *  burn Fidu. The share price of the Pool implicitly represents the \"exchange rate\" between Fidu\n *  and USDC (or whatever currencies the Pool may allow withdraws in during the future)\n * @author Doberman\n */\n\ncontract Fidu is ERC20PresetMinterPauserUpgradeable {\n  using SafeMath for uint256;\n  \n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  // $1 threshold to handle potential rounding errors, from differing decimals on Fidu and USDC;\n  uint256 public constant ASSET_LIABILITY_MATCH_THRESHOLD = 1e6;\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  /*\n    We are using our own initializer function so we can set the owner by passing it in.\n    I would override the regular \"initializer\" function, but I can't because it's not marked\n    as \"virtual\" in the parent contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(\n    address owner,\n    string calldata name,\n    string calldata symbol,\n    DobermanConfig _config\n  ) external initializer {\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n\n    __ERC20Burnable_init_unchained();\n    __Pausable_init_unchained();\n    __ERC20Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(MINTER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(MINTER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @dev Creates `amount` new tokens for `to`.\n   *\n   * See {ERC20-_mint}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `MINTER_ROLE`.\n   */\n  function mintTo(address to, uint256 amount) public {\n    require(canMint(amount), \"Cannot mint: it would create an asset/liability mismatch\");\n    // This super call restricts to only the minter in its implementation, so we don't need to do it here.\n    super.mint(to, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the MINTER_ROLE\n   */\n  function burnFrom(address from, uint256 amount) public override {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: Must have minter role to burn\");\n    require(canBurn(amount), \"Cannot burn: it would create an asset/liability mismatch\");\n    _burn(from, amount);\n  }\n\n  // Internal functions\n\n  // canMint assumes that the USDC that backs the new shares has already been sent to the Pool\n  function canMint(uint256 newAmount) internal view returns (bool) {\n    ISeniorPool seniorPool = config.getSeniorPool();\n    uint256 liabilities = totalSupply().add(newAmount).mul(seniorPool.sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = seniorPool.assets();\n    if (_assets >= liabilitiesInDollars) {\n      return true;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  // canBurn assumes that the USDC that backed these shares has already been moved out the Pool\n  function canBurn(uint256 amountToBurn) internal view returns (bool) {\n    ISeniorPool seniorPool = config.getSeniorPool();\n    uint256 liabilities = totalSupply().sub(amountToBurn).mul(seniorPool.sharePrice()).div(fiduMantissa());\n    uint256 liabilitiesInDollars = fiduToUSDC(liabilities);\n    uint256 _assets = seniorPool.assets();\n    if (_assets >= liabilitiesInDollars) {\n      return true;\n    } else {\n      return liabilitiesInDollars.sub(_assets) <= ASSET_LIABILITY_MATCH_THRESHOLD;\n    }\n  }\n\n  function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function fiduMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function updateDobermanConfig() external {\n    require(hasRole(OWNER_ROLE, _msgSender()), \"ERC20PresetMinterPauser: Must have minter role to change config\");\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n}\n"
    },
    "contracts/protocol/core/FixedLeverageRatioStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"./LeverageRatioStrategy.sol\";\nimport \"../../interfaces/ISeniorPoolStrategy.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract FixedLeverageRatioStrategy is LeverageRatioStrategy {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  function initialize(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  function getLeverageRatio(ITranchedPool pool) public view override returns (uint256) {\n    return config.getLeverageRatio();\n  }\n}\n"
    },
    "contracts/protocol/core/GFI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title GFI\n * @notice GFI is Doberman's governance token.\n * @author Doberman\n */\ncontract GFI is Context, AccessControl, ERC20Burnable, ERC20Pausable {\n  using SafeMath for uint256;\n\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  /// The maximum number of tokens that can be minted\n  uint256 public cap;\n\n  event CapUpdated(address indexed who, uint256 cap);\n\n  constructor(\n    address owner,\n    string memory name,\n    string memory symbol,\n    uint256 initialCap\n  ) ERC20(name, symbol) {\n    cap = initialCap;\n\n    _setupRole(MINTER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(MINTER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @notice create and send tokens to a specified address\n   * @dev this function will fail if the caller attempts to mint over the current cap\n   */\n  function mint(address account, uint256 amount) public onlyMinter whenNotPaused {\n    require(mintingAmountIsWithinCap(amount), \"Cannot mint more than cap\");\n    _mint(account, amount);\n  }\n\n  /**\n   * @notice sets the maximum number of tokens that can be minted\n   * @dev the cap must be greater than the current total supply\n   */\n  function setCap(uint256 _cap) external onlyOwner {\n    require(_cap >= totalSupply(), \"Cannot decrease the cap below existing supply\");\n    cap = _cap;\n    emit CapUpdated(_msgSender(), cap);\n  }\n\n  function mintingAmountIsWithinCap(uint256 amount) internal view returns (bool) {\n    return totalSupply().add(amount) <= cap;\n  }\n\n  /**\n   * @dev Pauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function pause() external onlyPauser {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses all token transfers.\n   *\n   * See {ERC20Pausable} and {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the `PAUSER_ROLE`.\n   */\n  function unpause() external onlyPauser {\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override(ERC20, ERC20Pausable) {\n    super._beforeTokenTransfer(from, to, amount);\n  }\n\n  modifier onlyOwner() {\n    require(hasRole(OWNER_ROLE, _msgSender()), \"Must be owner\");\n    _;\n  }\n\n  modifier onlyMinter() {\n    require(hasRole(MINTER_ROLE, _msgSender()), \"Must be minter\");\n    _;\n  }\n\n  modifier onlyPauser() {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Must be pauser\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/Go.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"../../interfaces/IGo.sol\";\nimport \"../../interfaces/IUniqueIdentity0612.sol\";\n\ncontract Go is IGo, BaseUpgradeablePausable {\n  address public override uniqueIdentity;\n\n  using SafeMath for uint256;\n\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  DobermanConfig public legacyGoList;\n  uint256[11] public allIdTypes;\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  function initialize(\n    address owner,\n    DobermanConfig _config,\n    address _uniqueIdentity\n  ) public initializer {\n    require(\n      owner != address(0) && address(_config) != address(0) && _uniqueIdentity != address(0),\n      \"Owner and config and UniqueIdentity addresses cannot be empty\"\n    );\n    __BaseUpgradeablePausable__init(owner);\n    _performUpgrade();\n    config = _config;\n    uniqueIdentity = _uniqueIdentity;\n  }\n\n  function updateDobermanConfig() external override onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  function performUpgrade() external onlyAdmin {\n    return _performUpgrade();\n  }\n\n  function _performUpgrade() internal {\n    allIdTypes[0] = ID_TYPE_0;\n    allIdTypes[1] = ID_TYPE_1;\n    allIdTypes[2] = ID_TYPE_2;\n    allIdTypes[3] = ID_TYPE_3;\n    allIdTypes[4] = ID_TYPE_4;\n    allIdTypes[5] = ID_TYPE_5;\n    allIdTypes[6] = ID_TYPE_6;\n    allIdTypes[7] = ID_TYPE_7;\n    allIdTypes[8] = ID_TYPE_8;\n    allIdTypes[9] = ID_TYPE_9;\n    allIdTypes[10] = ID_TYPE_10;\n  }\n\n  /**\n   * @notice sets the config that will be used as the source of truth for the go\n   * list instead of the config currently associated. To use the associated config for to list, set the override\n   * to the null address.\n   */\n  function setLegacyGoList(DobermanConfig _legacyGoList) external onlyAdmin {\n    legacyGoList = _legacyGoList;\n  }\n\n  /**\n   * @notice Returns whether the provided account is go-listed for use of the Doberman protocol\n   * for any of the UID token types.\n   * This status is defined as: whether `balanceOf(account, id)` on the UniqueIdentity\n   * contract is non-zero (where `id` is a supported token id on UniqueIdentity), falling back to the\n   * account's status on the legacy go-list maintained on DobermanConfig.\n   * @param account The account whose go status to obtain\n   * @return The account's go status\n   */\n  function go(address account) public view override returns (bool) {\n    require(account != address(0), \"Zero address is not go-listed\");\n\n    if (_getLegacyGoList().goList(account) || IUniqueIdentity0612(uniqueIdentity).balanceOf(account, ID_TYPE_0) > 0) {\n      return true;\n    }\n\n    // start loop at index 1 because we checked index 0 above\n    for (uint256 i = 1; i < allIdTypes.length; ++i) {\n      uint256 idTypeBalance = IUniqueIdentity0612(uniqueIdentity).balanceOf(account, allIdTypes[i]);\n      if (idTypeBalance > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Returns whether the provided account is go-listed for use of the Doberman protocol\n   * for defined UID token types\n   * @param account The account whose go status to obtain\n   * @param onlyIdTypes Array of id types to check balances\n   * @return The account's go status\n   */\n  function goOnlyIdTypes(address account, uint256[] memory onlyIdTypes) public view override returns (bool) {\n    require(account != address(0), \"Zero address is not go-listed\");\n    if(account == address(config.getSeniorPool())){\n      return true;\n    }\n    DobermanConfig goListSource = _getLegacyGoList();\n    for (uint256 i = 0; i < onlyIdTypes.length; ++i) {\n      if (onlyIdTypes[i] == ID_TYPE_0 && goListSource.goList(account)) {\n        return true;\n      }\n      uint256 idTypeBalance = IUniqueIdentity0612(uniqueIdentity).balanceOf(account, onlyIdTypes[i]);\n      if (idTypeBalance > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @notice Returns whether the provided account is go-listed for use of the SeniorPool on the Doberman protocol.\n   * @param account The account whose go status to obtain\n   * @return The account's go status\n   */\n  function goSeniorPool(address account) public view override returns (bool) {\n    require(account != address(0), \"Zero address is not go-listed\");\n    if (account == config.stakingRewardsAddress() || _getLegacyGoList().goList(account)) {\n      return true;\n    }\n    uint256[2] memory seniorPoolIdTypes = [ID_TYPE_0, ID_TYPE_1];\n    for (uint256 i = 0; i < seniorPoolIdTypes.length; ++i) {\n      uint256 idTypeBalance = IUniqueIdentity0612(uniqueIdentity).balanceOf(account, seniorPoolIdTypes[i]);\n      if (idTypeBalance > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _getLegacyGoList() internal view returns (DobermanConfig) {\n    return address(legacyGoList) == address(0) ? config : legacyGoList;\n  }\n}\n"
    },
    "contracts/protocol/core/LeverageRatioStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"../../interfaces/ISeniorPoolStrategy.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\n\nabstract contract LeverageRatioStrategy is BaseUpgradeablePausable, ISeniorPoolStrategy {\n  using SafeMath for uint256;\n\n  uint256 internal constant LEVERAGE_RATIO_DECIMALS = 1e18;\n\n  /**\n   * @notice Determines how much money to invest in the senior tranche based on what is committed to the junior\n   * tranche, what is committed to the senior tranche, and a leverage ratio to the junior tranche. Because\n   * it takes into account what is already committed to the senior tranche, the value returned by this\n   * function can be used \"idempotently\" to achieve the investment target amount without exceeding that target.\n   * @param seniorPool The senior pool to invest from\n   * @param pool The tranched pool to invest into (as the senior)\n   * @return The amount of money to invest into the tranched pool's senior tranche, from the senior pool\n   */\n  function invest(ISeniorPool seniorPool, ITranchedPool pool) public view override returns (uint256) {\n    ITranchedPool.TrancheInfo memory juniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Junior));\n    ITranchedPool.TrancheInfo memory seniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Senior));\n\n    // If junior capital is not yet invested, or pool already locked, then don't invest anything.\n    if (juniorTranche.lockedUntil == 0 || seniorTranche.lockedUntil > 0) {\n      return 0;\n    }\n\n    return _invest(pool, juniorTranche, seniorTranche);\n  }\n\n  /**\n   * @notice A companion of `invest()`: determines how much would be returned by `invest()`, as the\n   * value to invest into the senior tranche, if the junior tranche were locked and the senior tranche\n   * were not locked.\n   * @param seniorPool The senior pool to invest from\n   * @param pool The tranched pool to invest into (as the senior)\n   * @return The amount of money to invest into the tranched pool's senior tranche, from the senior pool\n   */\n  function estimateInvestment(ISeniorPool seniorPool, ITranchedPool pool) public view override returns (uint256) {\n    ITranchedPool.TrancheInfo memory juniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Junior));\n    ITranchedPool.TrancheInfo memory seniorTranche = pool.getTranche(uint256(ITranchedPool.Tranches.Senior));\n\n    return _invest(pool, juniorTranche, seniorTranche);\n  }\n\n  function _invest(\n    ITranchedPool pool,\n    ITranchedPool.TrancheInfo memory juniorTranche,\n    ITranchedPool.TrancheInfo memory seniorTranche\n  ) internal view returns (uint256) {\n    uint256 juniorCapital = juniorTranche.principalDeposited;\n    uint256 existingSeniorCapital = seniorTranche.principalDeposited;\n    uint256 seniorTarget = juniorCapital.mul(getLeverageRatio(pool)).div(LEVERAGE_RATIO_DECIMALS);\n\n    IV2CreditLine creditLine = pool.creditLine();\n    uint256 maxLimit = creditLine.maxLimit();\n    seniorTarget = (juniorCapital + seniorTarget > maxLimit) ? maxLimit - juniorCapital : seniorTarget;\n    \n    if (existingSeniorCapital >= seniorTarget) {\n      return 0;\n    }\n\n    return seniorTarget.sub(existingSeniorCapital);\n  }\n}\n"
    },
    "contracts/protocol/core/MigratedTranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// import \"./TranchedPool.sol\";\n// import \"../../interfaces/IV1CreditLine.sol\";\n// import \"../../interfaces/IMigratedTranchedPool.sol\";\n\n// contract MigratedTranchedPool is TranchedPool, IMigratedTranchedPool {\n//   bool public migrated;\n\n//   function migrateCreditLineToV2(\n//     IV1CreditLine clToMigrate,\n//     uint256 termEndTime,\n//     uint256 nextDueTime,\n//     uint256 interestAccruedAsOf,\n//     uint256 lastFullPaymentTime,\n//     uint256 totalInterestPaid\n//   ) external override returns (IV2CreditLine) {\n//     require(msg.sender == config.creditDeskAddress(), \"Only credit desk can call this\");\n//     require(!migrated, \"Already migrated\");\n\n//     // Set accounting state vars.\n//     IV2CreditLine newCl = creditLine;\n//     newCl.setBalance(clToMigrate.balance());\n//     newCl.setInterestOwed(clToMigrate.interestOwed());\n//     newCl.setPrincipalOwed(clToMigrate.principalOwed());\n//     newCl.setTermEndTime(termEndTime);\n//     newCl.setNextDueTime(nextDueTime);\n//     newCl.setInterestAccruedAsOf(interestAccruedAsOf);\n//     newCl.setLastFullPaymentTime(lastFullPaymentTime);\n//     newCl.setTotalInterestAccrued(totalInterestPaid.add(clToMigrate.interestOwed()));\n\n//     migrateDeposits(clToMigrate, totalInterestPaid);\n\n//     migrated = true;\n\n//     return newCl;\n//   }\n\n//   function migrateDeposits(IV1CreditLine clToMigrate, uint256 totalInterestPaid) internal {\n//     // Mint junior tokens to the SeniorPool, equal to current cl balance;\n//     require(!locked(), \"Pool has been locked\");\n//     // Hardcode to always get the JuniorTranche, since the migration case is when\n//     // the senior pool took the entire investment. Which we're expressing as the junior tranche\n//     uint256 tranche = uint256(ITranchedPool.Tranches.Junior);\n//     TrancheInfo storage trancheInfo = getTrancheInfo(tranche);\n//     require(trancheInfo.lockedUntil == 0, \"Tranche has been locked\");\n//     trancheInfo.principalDeposited = clToMigrate.limit();\n//     IPoolTokens.MintParams memory params = IPoolTokens.MintParams({\n//       tranche: tranche,\n//       principalAmount: trancheInfo.principalDeposited\n//     });\n//     IPoolTokens poolTokens = config.getPoolTokens();\n\n//     uint256 tokenId = poolTokens.mint(params, config.seniorPoolAddress());\n//     uint256 balancePaid = creditLine.limit().sub(creditLine.balance());\n\n//     // Account for the implicit redemptions already made by the Legacy Pool\n//     _lockJuniorCapital(poolSlices.length - 1);\n//     _lockPool();\n//     PoolSlice storage currentSlice = poolSlices[poolSlices.length - 1];\n//     currentSlice.juniorTranche.lockedUntil = block.timestamp - 1;\n//     poolTokens.redeem(tokenId, balancePaid, totalInterestPaid);\n\n//     // Simulate the drawdown\n//     currentSlice.juniorTranche.principalSharePrice = 0;\n//     currentSlice.seniorTranche.principalSharePrice = 0;\n\n//     // Set junior's sharePrice correctly\n//     currentSlice.juniorTranche.applyByAmount(totalInterestPaid, balancePaid, totalInterestPaid, balancePaid);\n//   }\n// }\n"
    },
    "contracts/protocol/core/PauserPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title PauserPausable\n * @notice Inheriting from OpenZeppelin's Pausable contract, this does small\n *  augmentations to make it work with a PAUSER_ROLE, leveraging the AccessControl contract.\n *  It is meant to be inherited.\n * @author Doberman\n */\n\ncontract PauserPausable is AccessControlUpgradeable, PausableUpgradeable {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __PauserPausable__init() public initializer {\n    __Pausable_init_unchained();\n  }\n\n  /**\n   * @dev Pauses all functions guarded by Pause\n   *\n   * See {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the PAUSER_ROLE.\n   */\n\n  function pause() public onlyPauserRole {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses the contract\n   *\n   * See {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the Pauser role\n   */\n  function unpause() public onlyPauserRole {\n    _unpause();\n  }\n\n  modifier onlyPauserRole() {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Doberman's Pool contract\n * @notice Main entry point for LP's (a.k.a. capital providers)\n *  Handles key logic for depositing and withdrawing funds from the Pool\n * @author Doberman\n */\n\ncontract Pool is BaseUpgradeablePausable, IPool {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using SafeMath for uint256;\n\n  uint256 public compoundBalance;\n\n  event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n  event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n  event TransferMade(address indexed from, address indexed to, uint256 amount);\n  event InterestCollected(address indexed payer, uint256 poolAmount, uint256 reserveAmount);\n  event PrincipalCollected(address indexed payer, uint256 amount);\n  event ReserveFundsCollected(address indexed user, uint256 amount);\n  event PrincipalWrittendown(address indexed creditline, int256 amount);\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  /**\n   * @notice Run only once, on initialization\n   * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n   * @param _config The address of the DobermanConfig contract\n   */\n  function initialize(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    config = _config;\n    sharePrice = fiduMantissa();\n    IERC20withDec usdc = config.getUSDC();\n    // Sanity check the address\n    usdc.totalSupply();\n\n    // Unlock self for infinite amount\n    bool success = usdc.approve(address(this), type(uint256).max);\n    require(success, \"Failed to approve USDC\");\n  }\n\n  /**\n   * @notice Deposits `amount` USDC from msg.sender into the Pool, and returns you the equivalent value of FIDU tokens\n   * @param amount The amount of USDC to deposit\n   */\n  function deposit(uint256 amount) external override whenNotPaused withinTransactionLimit(amount) nonReentrant {\n    require(amount > 0, \"Must deposit more than zero\");\n    // Check if the amount of new shares to be added is within limits\n    uint256 depositShares = getNumShares(amount);\n    uint256 potentialNewTotalShares = totalShares().add(depositShares);\n    require(poolWithinLimit(potentialNewTotalShares), \"Deposit would put the Pool over the total limit.\");\n    emit DepositMade(msg.sender, amount, depositShares);\n    bool success = doUSDCTransfer(msg.sender, address(this), amount);\n    require(success, \"Failed to transfer for deposit\");\n\n    config.getFidu().mintTo(msg.sender, depositShares);\n  }\n\n  /**\n   * @notice Withdraws USDC from the Pool to msg.sender, and burns the equivalent value of FIDU tokens\n   * @param usdcAmount The amount of USDC to withdraw\n   */\n  function withdraw(uint256 usdcAmount) external override whenNotPaused nonReentrant {\n    require(usdcAmount > 0, \"Must withdraw more than zero\");\n    // This MUST happen before calculating withdrawShares, otherwise the share price\n    // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    uint256 withdrawShares = getNumShares(usdcAmount);\n    _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Withdraws USDC (denominated in FIDU terms) from the Pool to msg.sender\n   * @param fiduAmount The amount of USDC to withdraw in terms of fidu shares\n   */\n  function withdrawInFidu(uint256 fiduAmount) external override whenNotPaused nonReentrant {\n    require(fiduAmount > 0, \"Must withdraw more than zero\");\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    uint256 usdcAmount = getUSDCAmountFromShares(fiduAmount);\n    uint256 withdrawShares = fiduAmount;\n    _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Collects `interest` USDC in interest and `principal` in principal from `from` and sends it to the Pool.\n   *  This also increases the share price accordingly. A portion is sent to the Doberman Reserve address\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param interest the interest amount of USDC to move to the Pool\n   * @param principal the principal amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public override onlyCreditDesk whenNotPaused {\n    _collectInterestAndPrincipal(from, interest, principal);\n  }\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta)\n    external\n    override\n    onlyCreditDesk\n    whenNotPaused\n  {\n    if (writedownDelta > 0) {\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n      sharePrice = sharePrice.add(delta);\n    } else {\n      // If delta is negative, convert to positive uint, and sub from sharePrice\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n      sharePrice = sharePrice.sub(delta);\n    }\n    emit PrincipalWrittendown(creditlineAddress, writedownDelta);\n  }\n\n  /**\n   * @notice Moves `amount` USDC from `from`, to `to`.\n   * @param from The address to take the USDC from. Implicitly, the Pool\n   *  must be authorized to move USDC on behalf of `from`.\n   * @param to The address that the USDC should be moved to\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override onlyCreditDesk whenNotPaused returns (bool) {\n    bool result = doUSDCTransfer(from, to, amount);\n    require(result, \"USDC Transfer failed\");\n    emit TransferMade(from, to, amount);\n    return result;\n  }\n\n  /**\n   * @notice Moves `amount` USDC from the pool, to `to`. This is similar to transferFrom except we sweep any\n   * balance we have from compound first and recognize interest. Meant to be called only by the credit desk on drawdown\n   * @param to The address that the USDC should be moved to\n   * @param amount the amount of USDC to move to the Pool\n   *\n   * Requirements:\n   *  - The caller must be the Credit Desk. Not even the owner can call this function.\n   */\n  function drawdown(address to, uint256 amount) public override onlyCreditDesk whenNotPaused returns (bool) {\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    return transferFrom(address(this), to, amount);\n  }\n\n  function assets() public view override returns (uint256) {\n    ICreditDesk creditDesk = config.getCreditDesk();\n    return\n      compoundBalance.add(config.getUSDC().balanceOf(address(this))).add(creditDesk.totalLoansOutstanding()).sub(\n        creditDesk.totalWritedowns()\n      );\n  }\n\n  function migrateToSeniorPool() external onlyAdmin {\n    // Bring back all USDC\n    if (compoundBalance > 0) {\n      sweepFromCompound();\n    }\n\n    // Pause deposits/withdrawals\n    if (!paused()) {\n      pause();\n    }\n\n    // Remove special priveldges from Fidu\n    bytes32 minterRole = keccak256(\"MINTER_ROLE\");\n    bytes32 pauserRole = keccak256(\"PAUSER_ROLE\");\n    config.getFidu().renounceRole(minterRole, address(this));\n    config.getFidu().renounceRole(pauserRole, address(this));\n\n    // Move all USDC to the SeniorPool\n    address seniorPoolAddress = config.seniorPoolAddress();\n    uint256 balance = config.getUSDC().balanceOf(address(this));\n    bool success = doUSDCTransfer(address(this), seniorPoolAddress, balance);\n    require(success, \"Failed to transfer USDC balance to the senior pool\");\n\n    // Claim our COMP!\n    address compoundController = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n    bytes memory data = abi.encodeWithSignature(\"claimComp(address)\", address(this));\n    bytes memory _res;\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, _res) = compoundController.call(data);\n    require(success, \"Failed to claim COMP\");\n\n    // Send our balance of COMP!\n    address compToken = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n    data = abi.encodeWithSignature(\"balanceOf(address)\", address(this));\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, _res) = compToken.call(data);\n    uint256 compBalance = toUint256(_res);\n    data = abi.encodeWithSignature(\"transfer(address,uint256)\", seniorPoolAddress, compBalance);\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, _res) = compToken.call(data);\n    require(success, \"Failed to transfer COMP\");\n  }\n\n  function toUint256(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 0x20))\n    }\n  }\n\n  /**\n   * @notice Moves any USDC still in the Pool to Compound, and tracks the amount internally.\n   * This is done to earn interest on latent funds until we have other borrowers who can use it.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepToCompound() public override onlyAdmin whenNotPaused {\n    IERC20 usdc = config.getUSDC();\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    // Approve compound to the exact amount\n    bool success = usdc.approve(address(cUSDC), usdcBalance);\n    require(success, \"Failed to approve USDC for compound\");\n\n    sweepToCompound(cUSDC, usdcBalance);\n\n    // Remove compound approval to be extra safe\n    success = config.getUSDC().approve(address(cUSDC), 0);\n    require(success, \"Failed to approve USDC for compound\");\n  }\n\n  /**\n   * @notice Moves any USDC from Compound back to the Pool, and recognizes interest earned.\n   * This is done automatically on drawdown or withdraw, but can be called manually if necessary.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepFromCompound() public override onlyAdmin whenNotPaused {\n    _sweepFromCompound();\n  }\n\n  /* Internal Functions */\n\n  function _withdraw(uint256 usdcAmount, uint256 withdrawShares) internal withinTransactionLimit(usdcAmount) {\n    IFidu fidu = config.getFidu();\n    // Determine current shares the address has and the shares requested to withdraw\n    uint256 currentShares = fidu.balanceOf(msg.sender);\n    // Ensure the address has enough value in the pool\n    require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n    uint256 reserveAmount = usdcAmount.div(config.getWithdrawFeeDenominator());\n    uint256 userAmount = usdcAmount.sub(reserveAmount);\n\n    emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n    // Send the amounts\n    bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n    require(success, \"Failed to transfer for withdraw\");\n    sendToReserve(address(this), reserveAmount, msg.sender);\n\n    // Burn the shares\n    fidu.burnFrom(msg.sender, withdrawShares);\n  }\n\n  function sweepToCompound(ICUSDCContract cUSDC, uint256 usdcAmount) internal {\n    // Our current design requires we re-normalize by withdrawing everything and recognizing interest gains\n    // before we can add additional capital to Compound\n    require(compoundBalance == 0, \"Cannot sweep when we already have a compound balance\");\n    require(usdcAmount != 0, \"Amount to sweep cannot be zero\");\n    uint256 error = cUSDC.mint(usdcAmount);\n    require(error == 0, \"Sweep to compound failed\");\n    compoundBalance = usdcAmount;\n  }\n\n  function sweepFromCompound(ICUSDCContract cUSDC, uint256 cUSDCAmount) internal {\n    uint256 cBalance = compoundBalance;\n    require(cBalance != 0, \"No funds on compound\");\n    require(cUSDCAmount != 0, \"Amount to sweep cannot be zero\");\n\n    IERC20 usdc = config.getUSDC();\n    uint256 preRedeemUSDCBalance = usdc.balanceOf(address(this));\n    uint256 cUSDCExchangeRate = cUSDC.exchangeRateCurrent();\n    uint256 redeemedUSDC = cUSDCToUSDC(cUSDCExchangeRate, cUSDCAmount);\n\n    uint256 error = cUSDC.redeem(cUSDCAmount);\n    uint256 postRedeemUSDCBalance = usdc.balanceOf(address(this));\n    require(error == 0, \"Sweep from compound failed\");\n    require(postRedeemUSDCBalance.sub(preRedeemUSDCBalance) == redeemedUSDC, \"Unexpected redeem amount\");\n\n    uint256 interestAccrued = redeemedUSDC.sub(cBalance);\n    _collectInterestAndPrincipal(address(this), interestAccrued, 0);\n    compoundBalance = 0;\n  }\n\n  function _collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) internal {\n    uint256 reserveAmount = interest.div(config.getReserveDenominator());\n    uint256 poolAmount = interest.sub(reserveAmount);\n    uint256 increment = usdcToSharePrice(poolAmount);\n    sharePrice = sharePrice.add(increment);\n\n    if (poolAmount > 0) {\n      emit InterestCollected(from, poolAmount, reserveAmount);\n    }\n    if (principal > 0) {\n      emit PrincipalCollected(from, principal);\n    }\n    if (reserveAmount > 0) {\n      sendToReserve(from, reserveAmount, from);\n    }\n    // Gas savings: No need to transfer to yourself, which happens in sweepFromCompound\n    if (from != address(this)) {\n      bool success = doUSDCTransfer(from, address(this), principal.add(poolAmount));\n      require(success, \"Failed to collect principal repayment\");\n    }\n  }\n\n  function _sweepFromCompound() internal {\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    sweepFromCompound(cUSDC, cUSDC.balanceOf(address(this)));\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  function fiduMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function usdcToFidu(uint256 amount) internal pure returns (uint256) {\n    return amount.mul(fiduMantissa()).div(usdcMantissa());\n  }\n\n  function cUSDCToUSDC(uint256 exchangeRate, uint256 amount) internal pure returns (uint256) {\n    // See https://compound.finance/docs#protocol-math\n    // But note, the docs and reality do not agree. Docs imply that that exchange rate is\n    // scaled by 1e18, but tests and mainnet forking make it appear to be scaled by 1e16\n    // 1e16 is also what Sheraz at Certik said.\n    uint256 usdcDecimals = 6;\n    uint256 cUSDCDecimals = 8;\n\n    // We multiply in the following order, for the following reasons...\n    // Amount in cToken (1e8)\n    // Amount in USDC (but scaled by 1e16, cause that's what exchange rate decimals are)\n    // Downscale to cToken decimals (1e8)\n    // Downscale from cToken to USDC decimals (8 to 6)\n    return amount.mul(exchangeRate).div(10**(18 + usdcDecimals - cUSDCDecimals)).div(10**2);\n  }\n\n  function totalShares() internal view returns (uint256) {\n    return config.getFidu().totalSupply();\n  }\n\n  function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n    return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n  }\n\n  function poolWithinLimit(uint256 _totalShares) internal view returns (bool) {\n    return\n      _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n      usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n  }\n\n  function transactionWithinLimit(uint256 amount) internal view returns (bool) {\n    return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n  }\n\n  function getNumShares(uint256 amount) internal view returns (uint256) {\n    return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n  }\n\n  function getUSDCAmountFromShares(uint256 fiduAmount) internal view returns (uint256) {\n    return fiduToUSDC(fiduAmount.mul(sharePrice).div(fiduMantissa()));\n  }\n\n  function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function sendToReserve(\n    address from,\n    uint256 amount,\n    address userForEvent\n  ) internal {\n    emit ReserveFundsCollected(userForEvent, amount);\n    bool success = doUSDCTransfer(from, config.reserveAddress(), amount);\n    require(success, \"Reserve transfer was not successful\");\n  }\n\n  function doUSDCTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    require(to != address(0), \"Can't send to zero address\");\n    IERC20withDec usdc = config.getUSDC();\n    return usdc.transferFrom(from, to, amount);\n  }\n\n  modifier withinTransactionLimit(uint256 amount) {\n    require(transactionWithinLimit(amount), \"Amount is over the per-transaction limit\");\n    _;\n  }\n\n  modifier onlyCreditDesk() {\n    require(msg.sender == config.creditDeskAddress(), \"Only the credit desk is allowed to call this function\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/PoolBackup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// import \"./BaseUpgradeablePausable.sol\";\n// import \"./ConfigHelper.sol\";\n\n// /**\n//  * @title Doberman's Pool contract\n//  * @notice Main entry point for LP's (a.k.a. capital providers)\n//  *  Handles key logic for depositing and withdrawing funds from the Pool\n//  * @author Doberman\n//  */\n\n// contract Pool is BaseUpgradeablePausable, IPool {\n//   DobermanConfig public config;\n//   using ConfigHelper for DobermanConfig;\n//   using SafeMath for uint256;\n\n//   uint256 public compoundBalance;\n\n//   event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n//   event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n//   event TransferMade(address indexed from, address indexed to, uint256 amount);\n//   event InterestCollected(address indexed payer, uint256 poolAmount, uint256 reserveAmount);\n//   event PrincipalCollected(address indexed payer, uint256 amount);\n//   event ReserveFundsCollected(address indexed user, uint256 amount);\n//   event PrincipalWrittendown(address indexed creditline, int256 amount);\n//   event DobermanConfigUpdated(address indexed who, address configAddress);\n\n//   /**\n//    * @notice Run only once, on initialization\n//    * @param owner The address of who should have the \"OWNER_ROLE\" of this contract\n//    * @param _config The address of the DobermanConfig contract\n//    */\n//   function initialize(address owner, DobermanConfig _config) public initializer {\n//     require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n//     __BaseUpgradeablePausable__init(owner);\n\n//     config = _config;\n//     sharePrice = fiduMantissa();\n//     IERC20withDec usdc = config.getUSDC();\n//     // Sanity check the address\n//     usdc.totalSupply();\n\n//     // Unlock self for infinite amount\n//     bool success = usdc.approve(address(this), type(uint256).max);\n//     require(success, \"Failed to approve USDC\");\n//   }\n\n//   /**\n//    * @notice Deposits `amount` USDC from msg.sender into the Pool, and returns you the equivalent value of FIDU tokens\n//    * @param amount The amount of USDC to deposit\n//    */\n//   function deposit(uint256 amount) external override whenNotPaused withinTransactionLimit(amount) nonReentrant {\n//     require(amount > 0, \"Must deposit more than zero\");\n//     // Check if the amount of new shares to be added is within limits\n//     uint256 depositShares = getNumShares(amount);\n//     uint256 potentialNewTotalShares = totalShares().add(depositShares);\n//     require(poolWithinLimit(potentialNewTotalShares), \"Deposit would put the Pool over the total limit.\");\n//     emit DepositMade(msg.sender, amount, depositShares);\n//     bool success = doUSDCTransfer(msg.sender, address(this), amount);\n//     require(success, \"Failed to transfer for deposit\");\n\n//     config.getFidu().mintTo(msg.sender, depositShares);\n//   }\n\n//   /**\n//    * @notice Withdraws USDC from the Pool to msg.sender, and burns the equivalent value of FIDU tokens\n//    * @param usdcAmount The amount of USDC to withdraw\n//    */\n//   function withdraw(uint256 usdcAmount) external override whenNotPaused nonReentrant {\n//     require(usdcAmount > 0, \"Must withdraw more than zero\");\n//     // This MUST happen before calculating withdrawShares, otherwise the share price\n//     // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n//     uint256 withdrawShares = getNumShares(usdcAmount);\n//     _withdraw(usdcAmount, withdrawShares);\n//   }\n\n//   /**\n//    * @notice Withdraws USDC (denominated in FIDU terms) from the Pool to msg.sender\n//    * @param fiduAmount The amount of USDC to withdraw in terms of fidu shares\n//    */\n//   function withdrawInFidu(uint256 fiduAmount) external override whenNotPaused nonReentrant {\n//     require(fiduAmount > 0, \"Must withdraw more than zero\");\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n//     uint256 usdcAmount = getUSDCAmountFromShares(fiduAmount);\n//     uint256 withdrawShares = fiduAmount;\n//     _withdraw(usdcAmount, withdrawShares);\n//   }\n\n//   /**\n//    * @notice Collects `interest` USDC in interest and `principal` in principal from `from` and sends it to the Pool.\n//    *  This also increases the share price accordingly. A portion is sent to the Doberman Reserve address\n//    * @param from The address to take the USDC from. Implicitly, the Pool\n//    *  must be authorized to move USDC on behalf of `from`.\n//    * @param interest the interest amount of USDC to move to the Pool\n//    * @param principal the principal amount of USDC to move to the Pool\n//    *\n//    * Requirements:\n//    *  - The caller must be the Credit Desk. Not even the owner can call this function.\n//    */\n//   function collectInterestAndPrincipal(\n//     address from,\n//     uint256 interest,\n//     uint256 principal\n//   ) public override onlyCreditDesk whenNotPaused {\n//     _collectInterestAndPrincipal(from, interest, principal);\n//   }\n\n//   function distributeLosses(address creditlineAddress, int256 writedownDelta)\n//     external\n//     override\n//     onlyCreditDesk\n//     whenNotPaused\n//   {\n//     if (writedownDelta > 0) {\n//       uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n//       sharePrice = sharePrice.add(delta);\n//     } else {\n//       // If delta is negative, convert to positive uint, and sub from sharePrice\n//       uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n//       sharePrice = sharePrice.sub(delta);\n//     }\n//     emit PrincipalWrittendown(creditlineAddress, writedownDelta);\n//   }\n\n//   /**\n//    * @notice Moves `amount` USDC from `from`, to `to`.\n//    * @param from The address to take the USDC from. Implicitly, the Pool\n//    *  must be authorized to move USDC on behalf of `from`.\n//    * @param to The address that the USDC should be moved to\n//    * @param amount the amount of USDC to move to the Pool\n//    *\n//    * Requirements:\n//    *  - The caller must be the Credit Desk. Not even the owner can call this function.\n//    */\n//   function transferFrom(\n//     address from,\n//     address to,\n//     uint256 amount\n//   ) public override onlyCreditDesk whenNotPaused returns (bool) {\n//     bool result = doUSDCTransfer(from, to, amount);\n//     require(result, \"USDC Transfer failed\");\n//     emit TransferMade(from, to, amount);\n//     return result;\n//   }\n\n//   /**\n//    * @notice Moves `amount` USDC from the pool, to `to`. This is similar to transferFrom except we sweep any\n//    * balance we have from compound first and recognize interest. Meant to be called only by the credit desk on drawdown\n//    * @param to The address that the USDC should be moved to\n//    * @param amount the amount of USDC to move to the Pool\n//    *\n//    * Requirements:\n//    *  - The caller must be the Credit Desk. Not even the owner can call this function.\n//    */\n//   function drawdown(address to, uint256 amount) public override onlyCreditDesk whenNotPaused returns (bool) {\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n//     return transferFrom(address(this), to, amount);\n//   }\n\n//   function assets() public view override returns (uint256) {\n//     ICreditDesk creditDesk = config.getCreditDesk();\n//     return\n//       compoundBalance.add(config.getUSDC().balanceOf(address(this))).add(creditDesk.totalLoansOutstanding()).sub(\n//         creditDesk.totalWritedowns()\n//       );\n//   }\n\n//   function migrateToSeniorPool() external onlyAdmin {\n//     // Bring back all USDC\n//     if (compoundBalance > 0) {\n//       sweepFromCompound();\n//     }\n\n//     // Pause deposits/withdrawals\n//     if (!paused()) {\n//       pause();\n//     }\n\n//     // Remove special priveldges from Fidu\n//     bytes32 minterRole = keccak256(\"MINTER_ROLE\");\n//     bytes32 pauserRole = keccak256(\"PAUSER_ROLE\");\n//     config.getFidu().renounceRole(minterRole, address(this));\n//     config.getFidu().renounceRole(pauserRole, address(this));\n\n//     // Move all USDC to the SeniorPool\n//     address seniorPoolAddress = config.seniorPoolAddress();\n//     uint256 balance = config.getUSDC().balanceOf(address(this));\n//     bool success = doUSDCTransfer(address(this), seniorPoolAddress, balance);\n//     require(success, \"Failed to transfer USDC balance to the senior pool\");\n\n//     // Claim our COMP!\n//     address compoundController = address(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n//     bytes memory data = abi.encodeWithSignature(\"claimComp(address)\", address(this));\n//     bytes memory _res;\n//     // solhint-disable-next-line avoid-low-level-calls\n//     (success, _res) = compoundController.call(data);\n//     require(success, \"Failed to claim COMP\");\n\n//     // Send our balance of COMP!\n//     address compToken = address(0xc00e94Cb662C3520282E6f5717214004A7f26888);\n//     data = abi.encodeWithSignature(\"balanceOf(address)\", address(this));\n//     // solhint-disable-next-line avoid-low-level-calls\n//     (success, _res) = compToken.call(data);\n//     uint256 compBalance = toUint256(_res);\n//     data = abi.encodeWithSignature(\"transfer(address,uint256)\", seniorPoolAddress, compBalance);\n//     // solhint-disable-next-line avoid-low-level-calls\n//     (success, _res) = compToken.call(data);\n//     require(success, \"Failed to transfer COMP\");\n//   }\n\n//   function toUint256(bytes memory _bytes) internal pure returns (uint256 value) {\n//     assembly {\n//       value := mload(add(_bytes, 0x20))\n//     }\n//   }\n\n//   /**\n//    * @notice Moves any USDC still in the Pool to Compound, and tracks the amount internally.\n//    * This is done to earn interest on latent funds until we have other borrowers who can use it.\n//    *\n//    * Requirements:\n//    *  - The caller must be an admin.\n//    */\n//   function sweepToCompound() public override onlyAdmin whenNotPaused {\n//     IERC20 usdc = config.getUSDC();\n//     uint256 usdcBalance = usdc.balanceOf(address(this));\n\n//     ICUSDCContract cUSDC = config.getCUSDCContract();\n//     // Approve compound to the exact amount\n//     bool success = usdc.approve(address(cUSDC), usdcBalance);\n//     require(success, \"Failed to approve USDC for compound\");\n\n//     sweepToCompound(cUSDC, usdcBalance);\n\n//     // Remove compound approval to be extra safe\n//     success = config.getUSDC().approve(address(cUSDC), 0);\n//     require(success, \"Failed to approve USDC for compound\");\n//   }\n\n//   /**\n//    * @notice Moves any USDC from Compound back to the Pool, and recognizes interest earned.\n//    * This is done automatically on drawdown or withdraw, but can be called manually if necessary.\n//    *\n//    * Requirements:\n//    *  - The caller must be an admin.\n//    */\n//   function sweepFromCompound() public override onlyAdmin whenNotPaused {\n//     _sweepFromCompound();\n//   }\n\n//   /* Internal Functions */\n\n//   function _withdraw(uint256 usdcAmount, uint256 withdrawShares) internal withinTransactionLimit(usdcAmount) {\n//     IFidu fidu = config.getFidu();\n//     // Determine current shares the address has and the shares requested to withdraw\n//     uint256 currentShares = fidu.balanceOf(msg.sender);\n//     // Ensure the address has enough value in the pool\n//     require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n//     uint256 reserveAmount = usdcAmount.div(config.getWithdrawFeeDenominator());\n//     uint256 userAmount = usdcAmount.sub(reserveAmount);\n\n//     emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n//     // Send the amounts\n//     bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n//     require(success, \"Failed to transfer for withdraw\");\n//     sendToReserve(address(this), reserveAmount, msg.sender);\n\n//     // Burn the shares\n//     fidu.burnFrom(msg.sender, withdrawShares);\n//   }\n\n//   function sweepToCompound(ICUSDCContract cUSDC, uint256 usdcAmount) internal {\n//     // Our current design requires we re-normalize by withdrawing everything and recognizing interest gains\n//     // before we can add additional capital to Compound\n//     require(compoundBalance == 0, \"Cannot sweep when we already have a compound balance\");\n//     require(usdcAmount != 0, \"Amount to sweep cannot be zero\");\n//     uint256 error = cUSDC.mint(usdcAmount);\n//     require(error == 0, \"Sweep to compound failed\");\n//     compoundBalance = usdcAmount;\n//   }\n\n//   function sweepFromCompound(ICUSDCContract cUSDC, uint256 cUSDCAmount) internal {\n//     uint256 cBalance = compoundBalance;\n//     require(cBalance != 0, \"No funds on compound\");\n//     require(cUSDCAmount != 0, \"Amount to sweep cannot be zero\");\n\n//     IERC20 usdc = config.getUSDC();\n//     uint256 preRedeemUSDCBalance = usdc.balanceOf(address(this));\n//     uint256 cUSDCExchangeRate = cUSDC.exchangeRateCurrent();\n//     uint256 redeemedUSDC = cUSDCToUSDC(cUSDCExchangeRate, cUSDCAmount);\n\n//     uint256 error = cUSDC.redeem(cUSDCAmount);\n//     uint256 postRedeemUSDCBalance = usdc.balanceOf(address(this));\n//     require(error == 0, \"Sweep from compound failed\");\n//     require(postRedeemUSDCBalance.sub(preRedeemUSDCBalance) == redeemedUSDC, \"Unexpected redeem amount\");\n\n//     uint256 interestAccrued = redeemedUSDC.sub(cBalance);\n//     _collectInterestAndPrincipal(address(this), interestAccrued, 0);\n//     compoundBalance = 0;\n//   }\n\n//   function _collectInterestAndPrincipal(\n//     address from,\n//     uint256 interest,\n//     uint256 principal\n//   ) internal {\n//     uint256 reserveAmount = interest.div(config.getReserveDenominator());\n//     uint256 poolAmount = interest.sub(reserveAmount);\n//     uint256 increment = usdcToSharePrice(poolAmount);\n//     sharePrice = sharePrice.add(increment);\n\n//     if (poolAmount > 0) {\n//       emit InterestCollected(from, poolAmount, reserveAmount);\n//     }\n//     if (principal > 0) {\n//       emit PrincipalCollected(from, principal);\n//     }\n//     if (reserveAmount > 0) {\n//       sendToReserve(from, reserveAmount, from);\n//     }\n//     // Gas savings: No need to transfer to yourself, which happens in sweepFromCompound\n//     if (from != address(this)) {\n//       bool success = doUSDCTransfer(from, address(this), principal.add(poolAmount));\n//       require(success, \"Failed to collect principal repayment\");\n//     }\n//   }\n\n//   function _sweepFromCompound() internal {\n//     ICUSDCContract cUSDC = config.getCUSDCContract();\n//     sweepFromCompound(cUSDC, cUSDC.balanceOf(address(this)));\n//   }\n\n//   function updateDobermanConfig() external onlyAdmin {\n//     config = DobermanConfig(config.configAddress());\n//     emit DobermanConfigUpdated(msg.sender, address(config));\n//   }\n\n//   function fiduMantissa() internal pure returns (uint256) {\n//     return uint256(10)**uint256(18);\n//   }\n\n//   function usdcMantissa() internal pure returns (uint256) {\n//     return uint256(10)**uint256(6);\n//   }\n\n//   function usdcToFidu(uint256 amount) internal pure returns (uint256) {\n//     return amount.mul(fiduMantissa()).div(usdcMantissa());\n//   }\n\n//   function cUSDCToUSDC(uint256 exchangeRate, uint256 amount) internal pure returns (uint256) {\n//     // See https://compound.finance/docs#protocol-math\n//     // But note, the docs and reality do not agree. Docs imply that that exchange rate is\n//     // scaled by 1e18, but tests and mainnet forking make it appear to be scaled by 1e16\n//     // 1e16 is also what Sheraz at Certik said.\n//     uint256 usdcDecimals = 6;\n//     uint256 cUSDCDecimals = 8;\n\n//     // We multiply in the following order, for the following reasons...\n//     // Amount in cToken (1e8)\n//     // Amount in USDC (but scaled by 1e16, cause that's what exchange rate decimals are)\n//     // Downscale to cToken decimals (1e8)\n//     // Downscale from cToken to USDC decimals (8 to 6)\n//     return amount.mul(exchangeRate).div(10**(18 + usdcDecimals - cUSDCDecimals)).div(10**2);\n//   }\n\n//   function totalShares() internal view returns (uint256) {\n//     return config.getFidu().totalSupply();\n//   }\n\n//   function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n//     return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n//   }\n\n//   function poolWithinLimit(uint256 _totalShares) internal view returns (bool) {\n//     return\n//       _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n//       usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n//   }\n\n//   function transactionWithinLimit(uint256 amount) internal view returns (bool) {\n//     return amount <= config.getNumber(uint256(ConfigOptions.Numbers.TransactionLimit));\n//   }\n\n//   function getNumShares(uint256 amount) internal view returns (uint256) {\n//     return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n//   }\n\n//   function getUSDCAmountFromShares(uint256 fiduAmount) internal view returns (uint256) {\n//     return fiduToUSDC(fiduAmount.mul(sharePrice).div(fiduMantissa()));\n//   }\n\n//   function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n//     return amount.div(fiduMantissa().div(usdcMantissa()));\n//   }\n\n//   function sendToReserve(\n//     address from,\n//     uint256 amount,\n//     address userForEvent\n//   ) internal {\n//     emit ReserveFundsCollected(userForEvent, amount);\n//     bool success = doUSDCTransfer(from, config.reserveAddress(), amount);\n//     require(success, \"Reserve transfer was not successful\");\n//   }\n\n//   function doUSDCTransfer(\n//     address from,\n//     address to,\n//     uint256 amount\n//   ) internal returns (bool) {\n//     require(to != address(0), \"Can't send to zero address\");\n//     IERC20withDec usdc = config.getUSDC();\n//     return usdc.transferFrom(from, to, amount);\n//   }\n\n//   modifier withinTransactionLimit(uint256 amount) {\n//     require(transactionWithinLimit(amount), \"Amount is over the per-transaction limit\");\n//     _;\n//   }\n\n//   modifier onlyCreditDesk() {\n//     require(msg.sender == config.creditDeskAddress(), \"Only the credit desk is allowed to call this function\");\n//     _;\n//   }\n// }\n"
    },
    "contracts/protocol/core/PoolTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../../external/ERC721PresetMinterPauserAutoId.sol\";\nimport \"./DobermanConfig.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport '@openzeppelin/contracts/utils/Counters.sol';\n\n/**\n * @title PoolTokens\n * @notice PoolTokens is an ERC721 compliant contract, which can represent\n *  junior tranche or senior tranche shares of any of the borrower pools.\n * @author Doberman\n */\n\ncontract PoolTokens is IPoolTokens, ERC721PresetMinterPauserAutoIdUpgradeSafe {\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using SafeMath for uint256;\n  using Counters for Counters.Counter;\n\n  struct PoolInfo {\n    uint256 totalMinted;\n    uint256 totalPrincipalRedeemed;\n    bool created;\n  }\n\n  // tokenId => tokenInfo\n  mapping(uint256 => TokenInfo) public tokens;\n  // poolAddress => poolInfo\n  mapping(address => PoolInfo) public pools;\n\n  // event TokenMinted(\n  //   address indexed owner,\n  //   address indexed pool,\n  //   uint256 indexed tokenId,\n  //   uint256 amount,\n  //   uint256 tranche\n  // );\n\n  // event TokenRedeemed(\n  //   address indexed owner,\n  //   address indexed pool,\n  //   uint256 indexed tokenId,\n  //   uint256 principalRedeemed,\n  //   uint256 interestRedeemed,\n  //   uint256 tranche\n  // );\n\n  // event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  /*\n    We are using our own initializer function so that OZ doesn't automatically\n    set owner as msg.sender. Also, it lets us set our config contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(address owner, DobermanConfig _config) external initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ERC165_init_unchained();\n    // This is setting name and symbol of the NFT's\n    __ERC721_init_unchained(\"Doberman V2 Pool Tokens\", \"GFI-V2-PT\");\n    __Pausable_init_unchained();\n    __ERC721Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  /**\n   * @notice Called by pool to create a debt position in a particular tranche and amount\n   * @param params Struct containing the tranche and the amount\n   * @param to The address that should own the position\n   * @return tokenId The token ID (auto-incrementing integer across all pools)\n   */\n  function mint(MintParams calldata params, address to)\n    external\n    virtual\n    override\n    onlyPool\n    whenNotPaused\n    returns (uint256 tokenId)\n  {\n    address poolAddress = _msgSender();\n    tokenId = createToken(params, poolAddress);\n    _mint(to, tokenId);\n    config.getBackerRewards().setPoolTokenAccRewardsPerPrincipalDollarAtMint(_msgSender(), tokenId);\n    emit TokenMinted(to, poolAddress, tokenId, params.principalAmount, params.tranche);\n    return tokenId;\n  }\n\n  /**\n   * @notice Updates a token to reflect the principal and interest amounts that have been redeemed.\n   * @param tokenId The token id to update (must be owned by the pool calling this function)\n   * @param principalRedeemed The incremental amount of principal redeemed (cannot be more than principal deposited)\n   * @param interestRedeemed The incremental amount of interest redeemed\n   */\n  function redeem(\n    uint256 tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed\n  ) external virtual override onlyPool whenNotPaused {\n    TokenInfo storage token = tokens[tokenId];\n    address poolAddr = token.pool;\n    require(token.pool != address(0), \"Invalid tokenId\");\n    require(_msgSender() == poolAddr, \"Only the token's pool can redeem\");\n\n    PoolInfo storage pool = pools[poolAddr];\n    pool.totalPrincipalRedeemed = pool.totalPrincipalRedeemed.add(principalRedeemed);\n    require(pool.totalPrincipalRedeemed <= pool.totalMinted, \"Cannot redeem more than we minted\");\n\n    token.principalRedeemed = token.principalRedeemed.add(principalRedeemed);\n    require(\n      token.principalRedeemed <= token.principalAmount,\n      \"Cannot redeem more than principal-deposited amount for token\"\n    );\n    token.interestRedeemed = token.interestRedeemed.add(interestRedeemed);\n\n    emit TokenRedeemed(ownerOf(tokenId), poolAddr, tokenId, principalRedeemed, interestRedeemed, token.tranche);\n  }\n\n  /**\n   * @dev Burns a specific ERC721 token, and removes the data from our mappings\n   * @param tokenId uint256 id of the ERC721 token to be burned.\n   */\n  function burn(uint256 tokenId) external virtual override whenNotPaused {\n    TokenInfo memory token = _getTokenInfo(tokenId);\n    bool canBurn = _isApprovedOrOwner(_msgSender(), tokenId);\n    bool fromTokenPool = _validPool(_msgSender()) && token.pool == _msgSender();\n    address owner = ownerOf(tokenId);\n    require(canBurn || fromTokenPool, \"ERC721Burnable: caller cannot burn this token\");\n    require(token.principalRedeemed == token.principalAmount, \"Can only burn fully redeemed tokens\");\n    destroyAndBurn(tokenId);\n    emit TokenBurned(owner, token.pool, tokenId);\n  }\n\n  function getTokenInfo(uint256 tokenId) external view virtual override returns (TokenInfo memory) {\n    return _getTokenInfo(tokenId);\n  }\n\n  /**\n   * @notice Called by the DobermanFactory to register the pool as a valid pool. Only valid pools can mint/redeem\n   * tokens\n   * @param newPool The address of the newly created pool\n   */\n  function onPoolCreated(address newPool) external override onlyDobermanFactory {\n    pools[newPool].created = true;\n  }\n\n  /**\n   * @notice Returns a boolean representing whether the spender is the owner or the approved spender of the token\n   * @param spender The address to check\n   * @param tokenId The token id to check for\n   * @return True if approved to redeem/transfer/burn the token, false if not\n   */\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view override returns (bool) {\n    return _isApprovedOrOwner(spender, tokenId);\n  }\n\n  function validPool(address sender) public view virtual override returns (bool) {\n    return _validPool(sender);\n  }\n\n  function createToken(MintParams calldata params, address poolAddress) internal returns (uint256 tokenId) {\n    PoolInfo storage pool = pools[poolAddress];\n\n    _tokenIdTracker.increment();\n    tokenId = _tokenIdTracker.current();\n    tokens[tokenId] = TokenInfo({\n      pool: poolAddress,\n      tranche: params.tranche,\n      principalAmount: params.principalAmount,\n      principalRedeemed: 0,\n      interestRedeemed: 0\n    });\n    pool.totalMinted = pool.totalMinted.add(params.principalAmount);\n    return tokenId;\n  }\n\n  function destroyAndBurn(uint256 tokenId) internal {\n    delete tokens[tokenId];\n    _burn(tokenId);\n  }\n\n  function _validPool(address poolAddress) internal view virtual returns (bool) {\n    return pools[poolAddress].created;\n  }\n\n  function _getTokenInfo(uint256 tokenId) internal view returns (TokenInfo memory) {\n    return tokens[tokenId];\n  }\n\n  /**\n   * @notice Migrates to a new Doberman config address\n   */\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyDobermanFactory() {\n    require(_msgSender() == config.DobermanFactoryAddress(), \"Only Doberman factory is allowed\");\n    _;\n  }\n\n  modifier onlyPool() {\n    require(_validPool(_msgSender()), \"Invalid pool!\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/SeniorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"./Accountant.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\n\n/**\n * @title Doberman's SeniorPool contract\n * @notice Main entry point for senior LPs (a.k.a. capital providers)\n *  Automatically invests across borrower pools using an adjustable strategy.\n * @author Doberman\n */\ncontract SeniorPool is BaseUpgradeablePausable, ISeniorPool {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using SafeMath for uint256;\n\n  uint256 public compoundBalance;\n  mapping(ITranchedPool => uint256) public writedowns;\n\n  event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n  event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n  event InterestCollected(address indexed payer, uint256 amount);\n  event PrincipalCollected(address indexed payer, uint256 amount);\n  event ReserveFundsCollected(address indexed user, uint256 amount);\n\n  event PrincipalWrittenDown(address indexed tranchedPool, int256 amount);\n  event InvestmentMadeInSenior(address indexed tranchedPool, uint256 amount);\n  event InvestmentMadeInJunior(address indexed tranchedPool, uint256 amount);\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  function initialize(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    config = _config;\n    // Initialize sharePrice to be identical to the legacy pool. This is in the initializer\n    // because it must only ever happen once.\n    sharePrice = fiduMantissa();\n    totalLoansOutstanding = 0;\n    totalWritedowns = 0;\n\n    IERC20withDec usdc = config.getUSDC();\n    // Sanity check the address\n    usdc.totalSupply();\n\n    bool success = usdc.approve(address(this), type(uint256).max);\n    require(success, \"Failed to approve USDC\");\n  }\n\n  /**\n   * @notice Deposits `amount` USDC from msg.sender into the SeniorPool, and grants you the\n   *  equivalent value of FIDU tokens\n   * @param amount The amount of USDC to deposit\n   */\n  function deposit(uint256 amount) public override whenNotPaused nonReentrant returns (uint256 depositShares) {\n    require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n    require(amount > 0, \"Must deposit more than zero\");\n    // Check if the amount of new shares to be added is within limits\n    depositShares = getNumShares(amount);\n    uint256 potentialNewTotalShares = totalShares().add(depositShares);\n    require(sharesWithinLimit(potentialNewTotalShares), \"Deposit would put the senior pool over the total limit.\");\n    emit DepositMade(msg.sender, amount, depositShares);\n    bool success = doUSDCTransfer(msg.sender, address(this), amount);\n    require(success, \"Failed to transfer for deposit\");\n\n    config.getFidu().mintTo(msg.sender, depositShares);\n    return depositShares;\n  }\n\n  /**\n   * @notice Identical to deposit, except it allows for a passed up signature to permit\n   *  the Senior Pool to move funds on behalf of the user, all within one transaction.\n   * @param amount The amount of USDC to deposit\n   * @param v secp256k1 signature component\n   * @param r secp256k1 signature component\n   * @param s secp256k1 signature component\n   */\n  function depositWithPermit(\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public override returns (uint256 depositShares) {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n    return deposit(amount);\n  }\n\n  /**\n   * @notice Withdraws USDC from the SeniorPool to msg.sender, and burns the equivalent value of FIDU tokens\n   * @param usdcAmount The amount of USDC to withdraw\n   */\n  function withdraw(uint256 usdcAmount) external override whenNotPaused nonReentrant returns (uint256 amount) {\n    require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n    require(usdcAmount > 0, \"Must withdraw more than zero\");\n    // This MUST happen before calculating withdrawShares, otherwise the share price\n    // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    uint256 withdrawShares = getNumShares(usdcAmount);\n    return _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Withdraws USDC (denominated in FIDU terms) from the SeniorPool to msg.sender\n   * @param fiduAmount The amount of USDC to withdraw in terms of FIDU shares\n   */\n  function withdrawInFidu(uint256 fiduAmount) external override whenNotPaused nonReentrant returns (uint256 amount) {\n    require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n    require(fiduAmount > 0, \"Must withdraw more than zero\");\n    // This MUST happen before calculating withdrawShares, otherwise the share price\n    // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n    uint256 usdcAmount = getUSDCAmountFromShares(fiduAmount);\n    uint256 withdrawShares = fiduAmount;\n    return _withdraw(usdcAmount, withdrawShares);\n  }\n\n  /**\n   * @notice Migrates to a new Doberman config address\n   */\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  /**\n   * @notice Moves any USDC still in the SeniorPool to Compound, and tracks the amount internally.\n   * This is done to earn interest on latent funds until we have other borrowers who can use it.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepToCompound() public override onlyAdmin whenNotPaused {\n    IERC20 usdc = config.getUSDC();\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    // Approve compound to the exact amount\n    bool success = usdc.approve(address(cUSDC), usdcBalance);\n    require(success, \"Failed to approve USDC for compound\");\n\n    sweepToCompound(cUSDC, usdcBalance);\n\n    // Remove compound approval to be extra safe\n    success = config.getUSDC().approve(address(cUSDC), 0);\n    require(success, \"Failed to approve USDC for compound\");\n  }\n\n  /**\n   * @notice Moves any USDC from Compound back to the SeniorPool, and recognizes interest earned.\n   * This is done automatically on drawdown or withdraw, but can be called manually if necessary.\n   *\n   * Requirements:\n   *  - The caller must be an admin.\n   */\n  function sweepFromCompound() public override onlyAdmin whenNotPaused {\n    _sweepFromCompound();\n  }\n\n  /**\n   * @notice Invest in an ITranchedPool's senior tranche using the senior pool's strategy\n   * @param pool An ITranchedPool whose senior tranche should be considered for investment\n   */\n  function invest(ITranchedPool pool) public override whenNotPaused nonReentrant {\n    require(validPool(pool), \"Pool must be valid\");\n\n    if (compoundBalance > 0) {\n      _sweepFromCompound();\n    }\n\n    ISeniorPoolStrategy strategy = config.getSeniorPoolStrategy();\n    uint256 amount = strategy.invest(this, pool);\n\n    require(amount > 0, \"Investment amount must be positive\");\n\n    approvePool(pool, amount);\n    pool.deposit(uint256(ITranchedPool.Tranches.Senior), amount);\n\n    emit InvestmentMadeInSenior(address(pool), amount);\n    totalLoansOutstanding = totalLoansOutstanding.add(amount);\n  }\n\n  function estimateInvestment(ITranchedPool pool) public view override returns (uint256) {\n    require(validPool(pool), \"Pool must be valid\");\n    ISeniorPoolStrategy strategy = config.getSeniorPoolStrategy();\n    return strategy.estimateInvestment(this, pool);\n  }\n\n  /**\n   * @notice Redeem interest and/or principal from an ITranchedPool investment\n   * @param tokenId the ID of an IPoolTokens token to be redeemed\n   */\n  function redeem(uint256 tokenId) public override whenNotPaused nonReentrant {\n    IPoolTokens poolTokens = config.getPoolTokens();\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n\n    ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n    (uint256 interestRedeemed, uint256 principalRedeemed) = pool.withdrawMax(tokenId);\n\n    _collectInterestAndPrincipal(address(pool), interestRedeemed, principalRedeemed);\n  }\n\n  /**\n   * @notice Write down an ITranchedPool investment. This will adjust the senior pool's share price\n   *  down if we're considering the investment a loss, or up if the borrower has subsequently\n   *  made repayments that restore confidence that the full loan will be repaid.\n   * @param tokenId the ID of an IPoolTokens token to be considered for writedown\n   */\n  function writedown(uint256 tokenId) public override whenNotPaused nonReentrant {\n    IPoolTokens poolTokens = config.getPoolTokens();\n    require(address(this) == poolTokens.ownerOf(tokenId), \"Only tokens owned by the senior pool can be written down\");\n\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n    ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n    require(validPool(pool), \"Pool must be valid\");\n\n    uint256 principalRemaining = tokenInfo.principalAmount.sub(tokenInfo.principalRedeemed);\n\n    (uint256 writedownPercent, uint256 writedownAmount) = _calculateWritedown(pool, principalRemaining);\n\n    uint256 prevWritedownAmount = writedowns[pool];\n\n    if (writedownPercent == 0 && prevWritedownAmount == 0) {\n      return;\n    }\n\n    int256 writedownDelta = int256(prevWritedownAmount) - int256(writedownAmount);\n    writedowns[pool] = writedownAmount;\n    distributeLosses(writedownDelta);\n    if (writedownDelta > 0) {\n      // If writedownDelta is positive, that means we got money back. So subtract from totalWritedowns.\n      totalWritedowns = totalWritedowns.sub(uint256(writedownDelta));\n    } else {\n      totalWritedowns = totalWritedowns.add(uint256(writedownDelta * -1));\n    }\n    emit PrincipalWrittenDown(address(pool), writedownDelta);\n  }\n\n  /**\n   * @notice Calculates the writedown amount for a particular pool position\n   * @param tokenId The token reprsenting the position\n   * @return The amount in dollars the principal should be written down by\n   */\n  function calculateWritedown(uint256 tokenId) public view override returns (uint256) {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n\n    uint256 principalRemaining = tokenInfo.principalAmount.sub(tokenInfo.principalRedeemed);\n\n    (, uint256 writedownAmount) = _calculateWritedown(pool, principalRemaining);\n    return writedownAmount;\n  }\n\n  /**\n   * @notice Returns the net assests controlled by and owed to the pool\n   */\n  function assets() public view override returns (uint256) {\n    return\n      compoundBalance.add(config.getUSDC().balanceOf(address(this))).add(totalLoansOutstanding).sub(totalWritedowns);\n  }\n\n  /**\n   * @notice Converts and USDC amount to FIDU amount\n   * @param amount USDC amount to convert to FIDU\n   */\n  function getNumShares(uint256 amount) public view override returns (uint256) {\n    return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n  }\n\n  /* Internal Functions */\n\n  function _calculateWritedown(ITranchedPool pool, uint256 principal)\n    internal\n    view\n    returns (uint256 writedownPercent, uint256 writedownAmount)\n  {\n    return\n      Accountant.calculateWritedownForPrincipal(\n        pool.creditLine(),\n        principal,\n        currentTime(),\n        config.getLatenessGracePeriodInDays(),\n        config.getLatenessMaxDays()\n      );\n  }\n\n  function currentTime() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  function distributeLosses(int256 writedownDelta) internal {\n    if (writedownDelta > 0) {\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n      sharePrice = sharePrice.add(delta);\n    } else {\n      // If delta is negative, convert to positive uint, and sub from sharePrice\n      uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n      sharePrice = sharePrice.sub(delta);\n    }\n  }\n\n  function fiduMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function usdcToFidu(uint256 amount) internal pure returns (uint256) {\n    return amount.mul(fiduMantissa()).div(usdcMantissa());\n  }\n\n  function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(fiduMantissa().div(usdcMantissa()));\n  }\n\n  function getUSDCAmountFromShares(uint256 fiduAmount) internal view returns (uint256) {\n    return fiduToUSDC(fiduAmount.mul(sharePrice).div(fiduMantissa()));\n  }\n\n  function sharesWithinLimit(uint256 _totalShares) internal view returns (bool) {\n    return\n      _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n      usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n  }\n\n  function doUSDCTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal returns (bool) {\n    require(to != address(0), \"Can't send to zero address\");\n    IERC20withDec usdc = config.getUSDC();\n    return usdc.transferFrom(from, to, amount);\n  }\n\n  function _withdraw(uint256 usdcAmount, uint256 withdrawShares) internal returns (uint256 userAmount) {\n    IFidu fidu = config.getFidu();\n    // Determine current shares the address has and the shares requested to withdraw\n    uint256 currentShares = fidu.balanceOf(msg.sender);\n    // Ensure the address has enough value in the pool\n    require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n    uint256 reserveAmount = usdcAmount.div(config.getWithdrawFeeDenominator());\n    userAmount = usdcAmount.sub(reserveAmount);\n\n    emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n    // Send the amounts\n    bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n    require(success, \"Failed to transfer for withdraw\");\n    sendToReserve(reserveAmount, msg.sender);\n\n    // Burn the shares\n    fidu.burnFrom(msg.sender, withdrawShares);\n    return userAmount;\n  }\n\n  function sweepToCompound(ICUSDCContract cUSDC, uint256 usdcAmount) internal {\n    // Our current design requires we re-normalize by withdrawing everything and recognizing interest gains\n    // before we can add additional capital to Compound\n    require(compoundBalance == 0, \"Cannot sweep when we already have a compound balance\");\n    require(usdcAmount != 0, \"Amount to sweep cannot be zero\");\n    uint256 error = cUSDC.mint(usdcAmount);\n    require(error == 0, \"Sweep to compound failed\");\n    compoundBalance = usdcAmount;\n  }\n\n  function _sweepFromCompound() internal {\n    ICUSDCContract cUSDC = config.getCUSDCContract();\n    sweepFromCompound(cUSDC, cUSDC.balanceOf(address(this)));\n  }\n\n  function sweepFromCompound(ICUSDCContract cUSDC, uint256 cUSDCAmount) internal {\n    uint256 cBalance = compoundBalance;\n    require(cBalance != 0, \"No funds on compound\");\n    require(cUSDCAmount != 0, \"Amount to sweep cannot be zero\");\n\n    IERC20 usdc = config.getUSDC();\n    uint256 preRedeemUSDCBalance = usdc.balanceOf(address(this));\n    uint256 cUSDCExchangeRate = cUSDC.exchangeRateCurrent();\n    uint256 redeemedUSDC = cUSDCToUSDC(cUSDCExchangeRate, cUSDCAmount);\n\n    uint256 error = cUSDC.redeem(cUSDCAmount);\n    uint256 postRedeemUSDCBalance = usdc.balanceOf(address(this));\n    require(error == 0, \"Sweep from compound failed\");\n    require(postRedeemUSDCBalance.sub(preRedeemUSDCBalance) == redeemedUSDC, \"Unexpected redeem amount\");\n\n    uint256 interestAccrued = redeemedUSDC.sub(cBalance);\n    uint256 reserveAmount = interestAccrued.div(config.getReserveDenominator());\n    uint256 poolAmount = interestAccrued.sub(reserveAmount);\n\n    _collectInterestAndPrincipal(address(this), poolAmount, 0);\n\n    if (reserveAmount > 0) {\n      sendToReserve(reserveAmount, address(cUSDC));\n    }\n\n    compoundBalance = 0;\n  }\n\n  function cUSDCToUSDC(uint256 exchangeRate, uint256 amount) internal pure returns (uint256) {\n    // See https://compound.finance/docs#protocol-math\n    // But note, the docs and reality do not agree. Docs imply that that exchange rate is\n    // scaled by 1e18, but tests and mainnet forking make it appear to be scaled by 1e16\n    // 1e16 is also what Sheraz at Certik said.\n    uint256 usdcDecimals = 6;\n    uint256 cUSDCDecimals = 8;\n\n    // We multiply in the following order, for the following reasons...\n    // Amount in cToken (1e8)\n    // Amount in USDC (but scaled by 1e16, cause that's what exchange rate decimals are)\n    // Downscale to cToken decimals (1e8)\n    // Downscale from cToken to USDC decimals (8 to 6)\n    return amount.mul(exchangeRate).div(10**(18 + usdcDecimals - cUSDCDecimals)).div(10**2);\n  }\n\n  function _collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) internal {\n    uint256 increment = usdcToSharePrice(interest);\n    sharePrice = sharePrice.add(increment);\n\n    if (interest > 0) {\n      emit InterestCollected(from, interest);\n    }\n    if (principal > 0) {\n      emit PrincipalCollected(from, principal);\n      totalLoansOutstanding = totalLoansOutstanding.sub(principal);\n    }\n  }\n\n  function sendToReserve(uint256 amount, address userForEvent) internal {\n    emit ReserveFundsCollected(userForEvent, amount);\n    bool success = doUSDCTransfer(address(this), config.reserveAddress(), amount);\n    require(success, \"Reserve transfer was not successful\");\n  }\n\n  function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n    return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n  }\n\n  function totalShares() internal view returns (uint256) {\n    return config.getFidu().totalSupply();\n  }\n\n  function validPool(ITranchedPool pool) internal view returns (bool) {\n    return config.getPoolTokens().validPool(address(pool));\n  }\n\n  function approvePool(ITranchedPool pool, uint256 allowance) internal {\n    IERC20withDec usdc = config.getUSDC();\n    bool success = usdc.approve(address(pool), allowance);\n    require(success, \"Failed to approve USDC\");\n  }\n}\n"
    },
    "contracts/protocol/core/SeniorPoolBackup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n// import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n// import \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\n// import \"../../interfaces/ISeniorPool.sol\";\n// import \"../../interfaces/IPoolTokens.sol\";\n// import \"./Accountant.sol\";\n// import \"./BaseUpgradeablePausable.sol\";\n// import \"./ConfigHelper.sol\";\n\n// /**\n//  * @title Doberman's SeniorPool contract\n//  * @notice Main entry point for senior LPs (a.k.a. capital providers)\n//  *  Automatically invests across borrower pools using an adjustable strategy.\n//  * @author Doberman\n//  */\n// contract SeniorPool is BaseUpgradeablePausable, ISeniorPool {\n//   DobermanConfig public config;\n//   using ConfigHelper for DobermanConfig;\n//   using SafeMath for uint256;\n\n//   uint256 public compoundBalance;\n//   mapping(ITranchedPool => uint256) public writedowns;\n\n//   event DepositMade(address indexed capitalProvider, uint256 amount, uint256 shares);\n//   event WithdrawalMade(address indexed capitalProvider, uint256 userAmount, uint256 reserveAmount);\n//   event InterestCollected(address indexed payer, uint256 amount);\n//   event PrincipalCollected(address indexed payer, uint256 amount);\n//   event ReserveFundsCollected(address indexed user, uint256 amount);\n\n//   event PrincipalWrittenDown(address indexed tranchedPool, int256 amount);\n//   event InvestmentMadeInSenior(address indexed tranchedPool, uint256 amount);\n//   event InvestmentMadeInJunior(address indexed tranchedPool, uint256 amount);\n\n//   event DobermanConfigUpdated(address indexed who, address configAddress);\n\n//   function initialize(address owner, DobermanConfig _config) public initializer {\n//     require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n//     __BaseUpgradeablePausable__init(owner);\n\n//     config = _config;\n//     // Initialize sharePrice to be identical to the legacy pool. This is in the initializer\n//     // because it must only ever happen once.\n//     sharePrice = config.getPool().sharePrice();\n//     totalLoansOutstanding = config.getCreditDesk().totalLoansOutstanding();\n//     totalWritedowns = config.getCreditDesk().totalWritedowns();\n\n//     IERC20withDec usdc = config.getUSDC();\n//     // Sanity check the address\n//     usdc.totalSupply();\n\n//     bool success = usdc.approve(address(this), type(uint256).max);\n//     require(success, \"Failed to approve USDC\");\n//   }\n\n//   /**\n//    * @notice Deposits `amount` USDC from msg.sender into the SeniorPool, and grants you the\n//    *  equivalent value of FIDU tokens\n//    * @param amount The amount of USDC to deposit\n//    */\n//   function deposit(uint256 amount) public override whenNotPaused nonReentrant returns (uint256 depositShares) {\n//     require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n//     require(amount > 0, \"Must deposit more than zero\");\n//     // Check if the amount of new shares to be added is within limits\n//     depositShares = getNumShares(amount);\n//     uint256 potentialNewTotalShares = totalShares().add(depositShares);\n//     require(sharesWithinLimit(potentialNewTotalShares), \"Deposit would put the senior pool over the total limit.\");\n//     emit DepositMade(msg.sender, amount, depositShares);\n//     bool success = doUSDCTransfer(msg.sender, address(this), amount);\n//     require(success, \"Failed to transfer for deposit\");\n\n//     config.getFidu().mintTo(msg.sender, depositShares);\n//     return depositShares;\n//   }\n\n//   /**\n//    * @notice Identical to deposit, except it allows for a passed up signature to permit\n//    *  the Senior Pool to move funds on behalf of the user, all within one transaction.\n//    * @param amount The amount of USDC to deposit\n//    * @param v secp256k1 signature component\n//    * @param r secp256k1 signature component\n//    * @param s secp256k1 signature component\n//    */\n//   function depositWithPermit(\n//     uint256 amount,\n//     uint256 deadline,\n//     uint8 v,\n//     bytes32 r,\n//     bytes32 s\n//   ) public override returns (uint256 depositShares) {\n//     IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n//     return deposit(amount);\n//   }\n\n//   /**\n//    * @notice Withdraws USDC from the SeniorPool to msg.sender, and burns the equivalent value of FIDU tokens\n//    * @param usdcAmount The amount of USDC to withdraw\n//    */\n//   function withdraw(uint256 usdcAmount) external override whenNotPaused nonReentrant returns (uint256 amount) {\n//     require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n//     require(usdcAmount > 0, \"Must withdraw more than zero\");\n//     // This MUST happen before calculating withdrawShares, otherwise the share price\n//     // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n//     uint256 withdrawShares = getNumShares(usdcAmount);\n//     return _withdraw(usdcAmount, withdrawShares);\n//   }\n\n//   /**\n//    * @notice Withdraws USDC (denominated in FIDU terms) from the SeniorPool to msg.sender\n//    * @param fiduAmount The amount of USDC to withdraw in terms of FIDU shares\n//    */\n//   function withdrawInFidu(uint256 fiduAmount) external override whenNotPaused nonReentrant returns (uint256 amount) {\n//     require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n//     require(fiduAmount > 0, \"Must withdraw more than zero\");\n//     // This MUST happen before calculating withdrawShares, otherwise the share price\n//     // changes between calculation and burning of Fidu, which creates a asset/liability mismatch\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n//     uint256 usdcAmount = getUSDCAmountFromShares(fiduAmount);\n//     uint256 withdrawShares = fiduAmount;\n//     return _withdraw(usdcAmount, withdrawShares);\n//   }\n\n//   /**\n//    * @notice Migrates to a new Doberman config address\n//    */\n//   function updateDobermanConfig() external onlyAdmin {\n//     config = DobermanConfig(config.configAddress());\n//     emit DobermanConfigUpdated(msg.sender, address(config));\n//   }\n\n//   /**\n//    * @notice Moves any USDC still in the SeniorPool to Compound, and tracks the amount internally.\n//    * This is done to earn interest on latent funds until we have other borrowers who can use it.\n//    *\n//    * Requirements:\n//    *  - The caller must be an admin.\n//    */\n//   function sweepToCompound() public override onlyAdmin whenNotPaused {\n//     IERC20 usdc = config.getUSDC();\n//     uint256 usdcBalance = usdc.balanceOf(address(this));\n\n//     ICUSDCContract cUSDC = config.getCUSDCContract();\n//     // Approve compound to the exact amount\n//     bool success = usdc.approve(address(cUSDC), usdcBalance);\n//     require(success, \"Failed to approve USDC for compound\");\n\n//     sweepToCompound(cUSDC, usdcBalance);\n\n//     // Remove compound approval to be extra safe\n//     success = config.getUSDC().approve(address(cUSDC), 0);\n//     require(success, \"Failed to approve USDC for compound\");\n//   }\n\n//   /**\n//    * @notice Moves any USDC from Compound back to the SeniorPool, and recognizes interest earned.\n//    * This is done automatically on drawdown or withdraw, but can be called manually if necessary.\n//    *\n//    * Requirements:\n//    *  - The caller must be an admin.\n//    */\n//   function sweepFromCompound() public override onlyAdmin whenNotPaused {\n//     _sweepFromCompound();\n//   }\n\n//   /**\n//    * @notice Invest in an ITranchedPool's senior tranche using the senior pool's strategy\n//    * @param pool An ITranchedPool whose senior tranche should be considered for investment\n//    */\n//   function invest(ITranchedPool pool) public override whenNotPaused nonReentrant {\n//     require(validPool(pool), \"Pool must be valid\");\n\n//     if (compoundBalance > 0) {\n//       _sweepFromCompound();\n//     }\n\n//     ISeniorPoolStrategy strategy = config.getSeniorPoolStrategy();\n//     uint256 amount = strategy.invest(this, pool);\n\n//     require(amount > 0, \"Investment amount must be positive\");\n\n//     approvePool(pool, amount);\n//     pool.deposit(uint256(ITranchedPool.Tranches.Senior), amount);\n\n//     emit InvestmentMadeInSenior(address(pool), amount);\n//     totalLoansOutstanding = totalLoansOutstanding.add(amount);\n//   }\n\n//   function estimateInvestment(ITranchedPool pool) public view override returns (uint256) {\n//     require(validPool(pool), \"Pool must be valid\");\n//     ISeniorPoolStrategy strategy = config.getSeniorPoolStrategy();\n//     return strategy.estimateInvestment(this, pool);\n//   }\n\n//   /**\n//    * @notice Redeem interest and/or principal from an ITranchedPool investment\n//    * @param tokenId the ID of an IPoolTokens token to be redeemed\n//    */\n//   function redeem(uint256 tokenId) public override whenNotPaused nonReentrant {\n//     IPoolTokens poolTokens = config.getPoolTokens();\n//     IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n\n//     ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n//     (uint256 interestRedeemed, uint256 principalRedeemed) = pool.withdrawMax(tokenId);\n\n//     _collectInterestAndPrincipal(address(pool), interestRedeemed, principalRedeemed);\n//   }\n\n//   /**\n//    * @notice Write down an ITranchedPool investment. This will adjust the senior pool's share price\n//    *  down if we're considering the investment a loss, or up if the borrower has subsequently\n//    *  made repayments that restore confidence that the full loan will be repaid.\n//    * @param tokenId the ID of an IPoolTokens token to be considered for writedown\n//    */\n//   function writedown(uint256 tokenId) public override whenNotPaused nonReentrant {\n//     IPoolTokens poolTokens = config.getPoolTokens();\n//     require(address(this) == poolTokens.ownerOf(tokenId), \"Only tokens owned by the senior pool can be written down\");\n\n//     IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n//     ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n//     require(validPool(pool), \"Pool must be valid\");\n\n//     uint256 principalRemaining = tokenInfo.principalAmount.sub(tokenInfo.principalRedeemed);\n\n//     (uint256 writedownPercent, uint256 writedownAmount) = _calculateWritedown(pool, principalRemaining);\n\n//     uint256 prevWritedownAmount = writedowns[pool];\n\n//     if (writedownPercent == 0 && prevWritedownAmount == 0) {\n//       return;\n//     }\n\n//     int256 writedownDelta = int256(prevWritedownAmount) - int256(writedownAmount);\n//     writedowns[pool] = writedownAmount;\n//     distributeLosses(writedownDelta);\n//     if (writedownDelta > 0) {\n//       // If writedownDelta is positive, that means we got money back. So subtract from totalWritedowns.\n//       totalWritedowns = totalWritedowns.sub(uint256(writedownDelta));\n//     } else {\n//       totalWritedowns = totalWritedowns.add(uint256(writedownDelta * -1));\n//     }\n//     emit PrincipalWrittenDown(address(pool), writedownDelta);\n//   }\n\n//   /**\n//    * @notice Calculates the writedown amount for a particular pool position\n//    * @param tokenId The token reprsenting the position\n//    * @return The amount in dollars the principal should be written down by\n//    */\n//   function calculateWritedown(uint256 tokenId) public view override returns (uint256) {\n//     IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n//     ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n\n//     uint256 principalRemaining = tokenInfo.principalAmount.sub(tokenInfo.principalRedeemed);\n\n//     (, uint256 writedownAmount) = _calculateWritedown(pool, principalRemaining);\n//     return writedownAmount;\n//   }\n\n//   /**\n//    * @notice Returns the net assests controlled by and owed to the pool\n//    */\n//   function assets() public view override returns (uint256) {\n//     return\n//       compoundBalance.add(config.getUSDC().balanceOf(address(this))).add(totalLoansOutstanding).sub(totalWritedowns);\n//   }\n\n//   /**\n//    * @notice Converts and USDC amount to FIDU amount\n//    * @param amount USDC amount to convert to FIDU\n//    */\n//   function getNumShares(uint256 amount) public view override returns (uint256) {\n//     return usdcToFidu(amount).mul(fiduMantissa()).div(sharePrice);\n//   }\n\n//   /* Internal Functions */\n\n//   function _calculateWritedown(ITranchedPool pool, uint256 principal)\n//     internal\n//     view\n//     returns (uint256 writedownPercent, uint256 writedownAmount)\n//   {\n//     return\n//       Accountant.calculateWritedownForPrincipal(\n//         pool.creditLine(),\n//         principal,\n//         currentTime(),\n//         config.getLatenessGracePeriodInDays(),\n//         config.getLatenessMaxDays()\n//       );\n//   }\n\n//   function currentTime() internal view virtual returns (uint256) {\n//     return block.timestamp;\n//   }\n\n//   function distributeLosses(int256 writedownDelta) internal {\n//     if (writedownDelta > 0) {\n//       uint256 delta = usdcToSharePrice(uint256(writedownDelta));\n//       sharePrice = sharePrice.add(delta);\n//     } else {\n//       // If delta is negative, convert to positive uint, and sub from sharePrice\n//       uint256 delta = usdcToSharePrice(uint256(writedownDelta * -1));\n//       sharePrice = sharePrice.sub(delta);\n//     }\n//   }\n\n//   function fiduMantissa() internal pure returns (uint256) {\n//     return uint256(10)**uint256(18);\n//   }\n\n//   function usdcMantissa() internal pure returns (uint256) {\n//     return uint256(10)**uint256(6);\n//   }\n\n//   function usdcToFidu(uint256 amount) internal pure returns (uint256) {\n//     return amount.mul(fiduMantissa()).div(usdcMantissa());\n//   }\n\n//   function fiduToUSDC(uint256 amount) internal pure returns (uint256) {\n//     return amount.div(fiduMantissa().div(usdcMantissa()));\n//   }\n\n//   function getUSDCAmountFromShares(uint256 fiduAmount) internal view returns (uint256) {\n//     return fiduToUSDC(fiduAmount.mul(sharePrice).div(fiduMantissa()));\n//   }\n\n//   function sharesWithinLimit(uint256 _totalShares) internal view returns (bool) {\n//     return\n//       _totalShares.mul(sharePrice).div(fiduMantissa()) <=\n//       usdcToFidu(config.getNumber(uint256(ConfigOptions.Numbers.TotalFundsLimit)));\n//   }\n\n//   function doUSDCTransfer(\n//     address from,\n//     address to,\n//     uint256 amount\n//   ) internal returns (bool) {\n//     require(to != address(0), \"Can't send to zero address\");\n//     IERC20withDec usdc = config.getUSDC();\n//     return usdc.transferFrom(from, to, amount);\n//   }\n\n//   function _withdraw(uint256 usdcAmount, uint256 withdrawShares) internal returns (uint256 userAmount) {\n//     IFidu fidu = config.getFidu();\n//     // Determine current shares the address has and the shares requested to withdraw\n//     uint256 currentShares = fidu.balanceOf(msg.sender);\n//     // Ensure the address has enough value in the pool\n//     require(withdrawShares <= currentShares, \"Amount requested is greater than what this address owns\");\n\n//     uint256 reserveAmount = usdcAmount.div(config.getWithdrawFeeDenominator());\n//     userAmount = usdcAmount.sub(reserveAmount);\n\n//     emit WithdrawalMade(msg.sender, userAmount, reserveAmount);\n//     // Send the amounts\n//     bool success = doUSDCTransfer(address(this), msg.sender, userAmount);\n//     require(success, \"Failed to transfer for withdraw\");\n//     sendToReserve(reserveAmount, msg.sender);\n\n//     // Burn the shares\n//     fidu.burnFrom(msg.sender, withdrawShares);\n//     return userAmount;\n//   }\n\n//   function sweepToCompound(ICUSDCContract cUSDC, uint256 usdcAmount) internal {\n//     // Our current design requires we re-normalize by withdrawing everything and recognizing interest gains\n//     // before we can add additional capital to Compound\n//     require(compoundBalance == 0, \"Cannot sweep when we already have a compound balance\");\n//     require(usdcAmount != 0, \"Amount to sweep cannot be zero\");\n//     uint256 error = cUSDC.mint(usdcAmount);\n//     require(error == 0, \"Sweep to compound failed\");\n//     compoundBalance = usdcAmount;\n//   }\n\n//   function _sweepFromCompound() internal {\n//     ICUSDCContract cUSDC = config.getCUSDCContract();\n//     sweepFromCompound(cUSDC, cUSDC.balanceOf(address(this)));\n//   }\n\n//   function sweepFromCompound(ICUSDCContract cUSDC, uint256 cUSDCAmount) internal {\n//     uint256 cBalance = compoundBalance;\n//     require(cBalance != 0, \"No funds on compound\");\n//     require(cUSDCAmount != 0, \"Amount to sweep cannot be zero\");\n\n//     IERC20 usdc = config.getUSDC();\n//     uint256 preRedeemUSDCBalance = usdc.balanceOf(address(this));\n//     uint256 cUSDCExchangeRate = cUSDC.exchangeRateCurrent();\n//     uint256 redeemedUSDC = cUSDCToUSDC(cUSDCExchangeRate, cUSDCAmount);\n\n//     uint256 error = cUSDC.redeem(cUSDCAmount);\n//     uint256 postRedeemUSDCBalance = usdc.balanceOf(address(this));\n//     require(error == 0, \"Sweep from compound failed\");\n//     require(postRedeemUSDCBalance.sub(preRedeemUSDCBalance) == redeemedUSDC, \"Unexpected redeem amount\");\n\n//     uint256 interestAccrued = redeemedUSDC.sub(cBalance);\n//     uint256 reserveAmount = interestAccrued.div(config.getReserveDenominator());\n//     uint256 poolAmount = interestAccrued.sub(reserveAmount);\n\n//     _collectInterestAndPrincipal(address(this), poolAmount, 0);\n\n//     if (reserveAmount > 0) {\n//       sendToReserve(reserveAmount, address(cUSDC));\n//     }\n\n//     compoundBalance = 0;\n//   }\n\n//   function cUSDCToUSDC(uint256 exchangeRate, uint256 amount) internal pure returns (uint256) {\n//     // See https://compound.finance/docs#protocol-math\n//     // But note, the docs and reality do not agree. Docs imply that that exchange rate is\n//     // scaled by 1e18, but tests and mainnet forking make it appear to be scaled by 1e16\n//     // 1e16 is also what Sheraz at Certik said.\n//     uint256 usdcDecimals = 6;\n//     uint256 cUSDCDecimals = 8;\n\n//     // We multiply in the following order, for the following reasons...\n//     // Amount in cToken (1e8)\n//     // Amount in USDC (but scaled by 1e16, cause that's what exchange rate decimals are)\n//     // Downscale to cToken decimals (1e8)\n//     // Downscale from cToken to USDC decimals (8 to 6)\n//     return amount.mul(exchangeRate).div(10**(18 + usdcDecimals - cUSDCDecimals)).div(10**2);\n//   }\n\n//   function _collectInterestAndPrincipal(\n//     address from,\n//     uint256 interest,\n//     uint256 principal\n//   ) internal {\n//     uint256 increment = usdcToSharePrice(interest);\n//     sharePrice = sharePrice.add(increment);\n\n//     if (interest > 0) {\n//       emit InterestCollected(from, interest);\n//     }\n//     if (principal > 0) {\n//       emit PrincipalCollected(from, principal);\n//       totalLoansOutstanding = totalLoansOutstanding.sub(principal);\n//     }\n//   }\n\n//   function sendToReserve(uint256 amount, address userForEvent) internal {\n//     emit ReserveFundsCollected(userForEvent, amount);\n//     bool success = doUSDCTransfer(address(this), config.reserveAddress(), amount);\n//     require(success, \"Reserve transfer was not successful\");\n//   }\n\n//   function usdcToSharePrice(uint256 usdcAmount) internal view returns (uint256) {\n//     return usdcToFidu(usdcAmount).mul(fiduMantissa()).div(totalShares());\n//   }\n\n//   function totalShares() internal view returns (uint256) {\n//     return config.getFidu().totalSupply();\n//   }\n\n//   function validPool(ITranchedPool pool) internal view returns (bool) {\n//     return config.getPoolTokens().validPool(address(pool));\n//   }\n\n//   function approvePool(ITranchedPool pool, uint256 allowance) internal {\n//     IERC20withDec usdc = config.getUSDC();\n//     bool success = usdc.approve(address(pool), allowance);\n//     require(success, \"Failed to approve USDC\");\n//   }\n// }\n"
    },
    "contracts/protocol/core/TranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/IV2CreditLine.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"./DobermanConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"../../library/SafeERC20Transfer.sol\";\nimport \"./TranchingLogic.sol\";\n\ncontract TranchedPool is BaseUpgradeablePausable, ITranchedPool, SafeERC20Transfer {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using TranchingLogic for PoolSlice;\n  using TranchingLogic for TrancheInfo;\n  using SafeMath for uint256;\n\n  bytes32 public constant LOCKER_ROLE = keccak256(\"LOCKER_ROLE\");\n  bytes32 public constant SENIOR_ROLE = keccak256(\"SENIOR_ROLE\");\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\n  uint256 public constant SECONDS_PER_DAY = 60;\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\n  uint256 public constant NUM_TRANCHES_PER_SLICE = 2;\n  uint256 public juniorFeePercent;\n  bool public drawdownsPaused;\n  uint256[] public allowedUIDTypes;\n  uint256 public totalDeployed;\n  uint256 public fundableAt;\n\n  PoolSlice[] public poolSlices;\n\n  event DepositMade(address indexed owner, uint256 indexed tranche, uint256 indexed tokenId, uint256 amount);\n  event WithdrawalMade(\n    address indexed owner,\n    uint256 indexed tranche,\n    uint256 indexed tokenId,\n    uint256 interestWithdrawn,\n    uint256 principalWithdrawn\n  );\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n  event TranchedPoolAssessed(address indexed pool);\n  event PaymentApplied(\n    address indexed payer,\n    address indexed pool,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount,\n    uint256 reserveAmount\n  );\n  // Note: This has to exactly match the even in the TranchingLogic library for events to be emitted\n  // correctly\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n  event ReserveFundsCollected(address indexed from, uint256 amount);\n  event CreditLineMigrated(address indexed oldCreditLine, address indexed newCreditLine);\n  event DrawdownMade(address indexed borrower, uint256 amount);\n  event DrawdownsPaused(address indexed pool);\n  event DrawdownsUnpaused(address indexed pool);\n  event EmergencyShutdown(address indexed pool);\n  event TrancheLocked(address indexed pool, uint256 trancheId, uint256 lockedUntil);\n  event SliceCreated(address indexed pool, uint256 sliceId);\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public override initializer {\n    require(address(_config) != address(0) && address(_borrower) != address(0), \"Config/borrower invalid\");\n\n    config = DobermanConfig(_config);\n    address owner = config.protocolAdminAddress();\n    require(owner != address(0), \"Owner invalid\");\n    __BaseUpgradeablePausable__init(owner);\n    _initializeNextSlice(_fundableAt);\n    createAndSetCreditLine(\n      _borrower,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n\n    createdAt = block.timestamp;\n    juniorFeePercent = _juniorFeePercent;\n    if (_allowedUIDTypes.length == 0) {\n      uint256[1] memory defaultAllowedUIDTypes = [config.getGo().ID_TYPE_0()];\n      allowedUIDTypes = defaultAllowedUIDTypes;\n    } else {\n      allowedUIDTypes = _allowedUIDTypes;\n    }\n\n    _setupRole(LOCKER_ROLE, _borrower);\n    _setupRole(LOCKER_ROLE, owner);\n    _setRoleAdmin(LOCKER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(SENIOR_ROLE, OWNER_ROLE);\n\n    // Give the senior pool the ability to deposit into the senior pool\n    _setupRole(SENIOR_ROLE, address(config.getSeniorPool()));\n\n    // Unlock self for infinite amount\n    bool success = config.getUSDC().approve(address(this), type(uint256).max);\n    require(success, \"Failed to approve USDC\");\n  }\n\n  function setAllowedUIDTypes(uint256[] calldata ids) public onlyLocker {\n    require(\n      poolSlices[0].juniorTranche.principalDeposited == 0 && poolSlices[0].seniorTranche.principalDeposited == 0,\n      \"Must not have balance\"\n    );\n    allowedUIDTypes = ids;\n  }\n\n  /**\n   * @notice Deposit a USDC amount into the pool for a tranche. Mints an NFT to the caller representing the position\n   * @param tranche The number representing the tranche to deposit into\n   * @param amount The USDC amount to tranfer from the caller to the pool\n   * @return tokenId The tokenId of the NFT\n   */\n  function deposit(uint256 tranche, uint256 amount)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 tokenId)\n  {\n    TrancheInfo storage trancheInfo = getTrancheInfo(tranche);\n    require(trancheInfo.lockedUntil == 0, \"Tranche locked\");\n    require(amount > 0, \"Must deposit > zero\");\n    require(config.getGo().goOnlyIdTypes(msg.sender, allowedUIDTypes), \"Address not go-listed\");\n    require(block.timestamp > fundableAt, \"Not open for funding\");\n    // senior tranche ids are always odd numbered\n    if (_isSeniorTrancheId(trancheInfo.id)) {\n      require(hasRole(SENIOR_ROLE, _msgSender()), \"Req SENIOR_ROLE\");\n    }\n\n    trancheInfo.principalDeposited = trancheInfo.principalDeposited.add(amount);\n    IPoolTokens.MintParams memory params = IPoolTokens.MintParams({tranche: tranche, principalAmount: amount});\n    tokenId = config.getPoolTokens().mint(params, msg.sender);\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(this), amount);\n    emit DepositMade(msg.sender, tranche, tokenId, amount);\n    return tokenId;\n  }\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public override returns (uint256 tokenId) {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n    return deposit(tranche, amount);\n  }\n\n  /**\n   * @notice Withdraw an already deposited amount if the funds are available\n   * @param tokenId The NFT representing the position\n   * @param amount The amount to withdraw (must be <= interest+principal currently available to withdraw)\n   * @return interestWithdrawn The interest amount that was withdrawn\n   * @return principalWithdrawn The principal amount that was withdrawn\n   */\n  function withdraw(uint256 tokenId, uint256 amount)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    return _withdraw(trancheInfo, tokenInfo, tokenId, amount);\n  }\n\n  /**\n   * @notice Withdraw from many tokens (that the sender owns) in a single transaction\n   * @param tokenIds An array of tokens ids representing the position\n   * @param amounts An array of amounts to withdraw from the corresponding tokenIds\n   */\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) public override {\n    require(tokenIds.length == amounts.length, \"TokensIds and Amounts mismatch\");\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      withdraw(tokenIds[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @notice Similar to withdraw but will withdraw all available funds\n   * @param tokenId The NFT representing the position\n   * @return interestWithdrawn The interest amount that was withdrawn\n   * @return principalWithdrawn The principal amount that was withdrawn\n   */\n  function withdrawMax(uint256 tokenId)\n    external\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    (uint256 interestRedeemable, uint256 principalRedeemable) = redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n\n    uint256 amount = interestRedeemable.add(principalRedeemable);\n\n    return _withdraw(trancheInfo, tokenInfo, tokenId, amount);\n  }\n\n  /**\n   * @notice Draws down the funds (and locks the pool) to the borrower address. Can only be called by the borrower\n   * @param amount The amount to drawdown from the creditline (must be < limit)\n   */\n  function drawdown(uint256 amount) external override onlyLocker whenNotPaused {\n    require(!drawdownsPaused, \"Drawdowns are paused\");\n    if (!locked()) {\n      // Assumes the senior pool has invested already (saves the borrower a separate transaction to lock the pool)\n      _lockPool();\n    }\n    // Drawdown only draws down from the current slice for simplicity. It's harder to account for how much\n    // money is available from previous slices since depositors can redeem after unlock.\n    PoolSlice storage currentSlice = poolSlices[poolSlices.length.sub(1)];\n    uint256 amountAvailable = sharePriceToUsdc(\n      currentSlice.juniorTranche.principalSharePrice,\n      currentSlice.juniorTranche.principalDeposited\n    );\n    amountAvailable = amountAvailable.add(\n      sharePriceToUsdc(currentSlice.seniorTranche.principalSharePrice, currentSlice.seniorTranche.principalDeposited)\n    );\n\n    require(amount <= amountAvailable, \"Insufficient funds in slice\");\n\n    creditLine.drawdown(amount);\n\n    // Update the share price to reflect the amount remaining in the pool\n    uint256 amountRemaining = amountAvailable.sub(amount);\n    uint256 oldJuniorPrincipalSharePrice = currentSlice.juniorTranche.principalSharePrice;\n    uint256 oldSeniorPrincipalSharePrice = currentSlice.seniorTranche.principalSharePrice;\n    currentSlice.juniorTranche.principalSharePrice = currentSlice.juniorTranche.calculateExpectedSharePrice(\n      amountRemaining,\n      currentSlice\n    );\n    currentSlice.seniorTranche.principalSharePrice = currentSlice.seniorTranche.calculateExpectedSharePrice(\n      amountRemaining,\n      currentSlice\n    );\n    currentSlice.principalDeployed = currentSlice.principalDeployed.add(amount);\n    totalDeployed = totalDeployed.add(amount);\n\n    address borrower = creditLine.borrower();\n    safeERC20TransferFrom(config.getUSDC(), address(this), borrower, amount);\n    emit DrawdownMade(borrower, amount);\n    emit SharePriceUpdated(\n      address(this),\n      currentSlice.juniorTranche.id,\n      currentSlice.juniorTranche.principalSharePrice,\n      int256(oldJuniorPrincipalSharePrice.sub(currentSlice.juniorTranche.principalSharePrice)) * -1,\n      currentSlice.juniorTranche.interestSharePrice,\n      0\n    );\n    emit SharePriceUpdated(\n      address(this),\n      currentSlice.seniorTranche.id,\n      currentSlice.seniorTranche.principalSharePrice,\n      int256(oldSeniorPrincipalSharePrice.sub(currentSlice.seniorTranche.principalSharePrice)) * -1,\n      currentSlice.seniorTranche.interestSharePrice,\n      0\n    );\n  }\n\n  /**\n   * @notice Locks the junior tranche, preventing more junior deposits. Gives time for the senior to determine how\n   * much to invest (ensure leverage ratio cannot change for the period)\n   */\n  function lockJuniorCapital() external override onlyLocker whenNotPaused {\n    _lockJuniorCapital(poolSlices.length.sub(1));\n  }\n\n  /**\n   * @notice Locks the pool (locks both senior and junior tranches and starts the drawdown period). Beyond the drawdown\n   * period, any unused capital is available to withdraw by all depositors\n   */\n  function lockPool() external override onlyLocker whenNotPaused {\n    _lockPool();\n  }\n\n  function setFundableAt(uint256 newFundableAt) external override onlyLocker {\n    fundableAt = newFundableAt;\n  }\n\n  function initializeNextSlice(uint256 _fundableAt) external override onlyLocker whenNotPaused {\n    require(locked(), \"Current slice still active\");\n    require(!creditLine.isLate(), \"Creditline is late\");\n    require(creditLine.withinPrincipalGracePeriod(), \"Beyond principal grace period\");\n    _initializeNextSlice(_fundableAt);\n    emit SliceCreated(address(this), poolSlices.length.sub(1));\n  }\n\n  /**\n   * @notice Triggers an assessment of the creditline and the applies the payments according the tranche waterfall\n   */\n  function assess() external override whenNotPaused {\n    _assess();\n  }\n\n  /**\n   * @notice Allows repaying the creditline. Collects the USDC amount from the sender and triggers an assess\n   * @param amount The amount to repay\n   */\n  function pay(uint256 amount) external override whenNotPaused {\n    require(amount > 0, \"Must pay more than zero\");\n    collectPayment(amount);\n    _assess();\n  }\n\n  /**\n   * @notice Migrates to a new Doberman config address\n   */\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    creditLine.updateDobermanConfig();\n    emit DobermanConfigUpdated(msg.sender, address(config));\n  }\n\n  /**\n   * @notice Pauses the pool and sweeps any remaining funds to the treasury reserve.\n   */\n  function emergencyShutdown() public onlyAdmin {\n    if (!paused()) {\n      pause();\n    }\n\n    IERC20withDec usdc = config.getUSDC();\n    address reserveAddress = config.reserveAddress();\n    // Sweep any funds to community reserve\n    uint256 poolBalance = usdc.balanceOf(address(this));\n    if (poolBalance > 0) {\n      safeERC20Transfer(usdc, reserveAddress, poolBalance);\n    }\n\n    uint256 clBalance = usdc.balanceOf(address(creditLine));\n    if (clBalance > 0) {\n      safeERC20TransferFrom(usdc, address(creditLine), reserveAddress, clBalance);\n    }\n    emit EmergencyShutdown(address(this));\n  }\n\n  /**\n   * @notice Pauses all drawdowns (but not deposits/withdraws)\n   */\n  function pauseDrawdowns() public onlyAdmin {\n    drawdownsPaused = true;\n    emit DrawdownsPaused(address(this));\n  }\n\n  /**\n   * @notice Unpause drawdowns\n   */\n  function unpauseDrawdowns() public onlyAdmin {\n    drawdownsPaused = false;\n    emit DrawdownsUnpaused(address(this));\n  }\n\n  /**\n   * @notice Migrates the accounting variables from the current creditline to a brand new one\n   * @param _borrower The borrower address\n   * @param _maxLimit The new max limit\n   * @param _interestApr The new interest APR\n   * @param _paymentPeriodInDays The new payment period in days\n   * @param _termInDays The new term in days\n   * @param _lateFeeApr The new late fee APR\n   */\n  function migrateCreditLine(\n    address _borrower,\n    uint256 _maxLimit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public onlyAdmin {\n    require(_borrower != address(0), \"Borrower must not be empty\");\n    require(_paymentPeriodInDays != 0, \"Payment period invalid\");\n    require(_termInDays != 0, \"Term must not be empty\");\n\n    address originalClAddr = address(creditLine);\n\n    createAndSetCreditLine(\n      _borrower,\n      _maxLimit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n\n    address newClAddr = address(creditLine);\n    TranchingLogic.migrateAccountingVariables(originalClAddr, newClAddr);\n    TranchingLogic.closeCreditLine(originalClAddr);\n    address originalBorrower = IV2CreditLine(originalClAddr).borrower();\n    address newBorrower = IV2CreditLine(newClAddr).borrower();\n    // Ensure Roles\n    if (originalBorrower != newBorrower) {\n      revokeRole(LOCKER_ROLE, originalBorrower);\n      grantRole(LOCKER_ROLE, newBorrower);\n    }\n    // Transfer any funds to new CL\n    uint256 clBalance = config.getUSDC().balanceOf(originalClAddr);\n    if (clBalance > 0) {\n      safeERC20TransferFrom(config.getUSDC(), originalClAddr, newClAddr, clBalance);\n    }\n    emit CreditLineMigrated(originalClAddr, newClAddr);\n  }\n\n  /**\n   * @notice Migrates to a new creditline without copying the accounting variables\n   */\n  function migrateAndSetNewCreditLine(address newCl) public onlyAdmin {\n    require(newCl != address(0), \"Creditline cannot be empty\");\n    address originalClAddr = address(creditLine);\n    // Transfer any funds to new CL\n    uint256 clBalance = config.getUSDC().balanceOf(originalClAddr);\n    if (clBalance > 0) {\n      safeERC20TransferFrom(config.getUSDC(), originalClAddr, newCl, clBalance);\n    }\n    TranchingLogic.closeCreditLine(originalClAddr);\n    // set new CL\n    creditLine = IV2CreditLine(newCl);\n    // sanity check that the new address is in fact a creditline\n    creditLine.limit();\n\n    emit CreditLineMigrated(originalClAddr, address(creditLine));\n  }\n\n  // CreditLine proxy method\n  function setLimit(uint256 newAmount) external onlyAdmin {\n    return creditLine.setLimit(newAmount);\n  }\n\n  function setMaxLimit(uint256 newAmount) external onlyAdmin {\n    return creditLine.setMaxLimit(newAmount);\n  }\n\n  function getTranche(uint256 tranche) public view override returns (TrancheInfo memory) {\n    return getTrancheInfo(tranche);\n  }\n\n  function numSlices() public view returns (uint256) {\n    return poolSlices.length;\n  }\n\n  /**\n   * @notice Converts USDC amounts to share price\n   * @param amount The USDC amount to convert\n   * @param totalShares The total shares outstanding\n   * @return The share price of the input amount\n   */\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\n    return TranchingLogic.usdcToSharePrice(amount, totalShares);\n  }\n\n  /**\n   * @notice Converts share price to USDC amounts\n   * @param sharePrice The share price to convert\n   * @param totalShares The total shares outstanding\n   * @return The USDC amount of the input share price\n   */\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\n    return TranchingLogic.sharePriceToUsdc(sharePrice, totalShares);\n  }\n\n  /**\n   * @notice Returns the total junior capital deposited\n   * @return The total USDC amount deposited into all junior tranches\n   */\n  function totalJuniorDeposits() external view override returns (uint256) {\n    uint256 total;\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      total = total.add(poolSlices[i].juniorTranche.principalDeposited);\n    }\n    return total;\n  }\n\n  /**\n   * @notice Determines the amount of interest and principal redeemable by a particular tokenId\n   * @param tokenId The token representing the position\n   * @return interestRedeemable The interest available to redeem\n   * @return principalRedeemable The principal available to redeem\n   */\n  function availableToWithdraw(uint256 tokenId)\n    public\n    view\n    override\n    returns (uint256 interestRedeemable, uint256 principalRedeemable)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    if (currentTime() > trancheInfo.lockedUntil) {\n      return redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n    } else {\n      return (0, 0);\n    }\n  }\n\n  /* Internal functions  */\n\n  function _withdraw(\n    TrancheInfo storage trancheInfo,\n    IPoolTokens.TokenInfo memory tokenInfo,\n    uint256 tokenId,\n    uint256 amount\n  ) internal returns (uint256 interestWithdrawn, uint256 principalWithdrawn) {\n    require(config.getPoolTokens().isApprovedOrOwner(msg.sender, tokenId), \"Not token owner\");\n    require(config.getGo().goOnlyIdTypes(msg.sender, allowedUIDTypes), \"Address not go-listed\");\n    require(amount > 0, \"Must withdraw more than zero\");\n    (uint256 interestRedeemable, uint256 principalRedeemable) = redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n    uint256 netRedeemable = interestRedeemable.add(principalRedeemable);\n\n    require(amount <= netRedeemable, \"Invalid redeem amount\");\n    require(currentTime() > trancheInfo.lockedUntil, \"Tranche is locked\");\n\n    // If the tranche has not been locked, ensure the deposited amount is correct\n    if (trancheInfo.lockedUntil == 0) {\n      trancheInfo.principalDeposited = trancheInfo.principalDeposited.sub(amount);\n    }\n\n    uint256 interestToRedeem = Math.min(interestRedeemable, amount);\n    uint256 principalToRedeem = Math.min(principalRedeemable, amount.sub(interestToRedeem));\n\n    config.getPoolTokens().redeem(tokenId, principalToRedeem, interestToRedeem);\n    safeERC20TransferFrom(config.getUSDC(), address(this), msg.sender, principalToRedeem.add(interestToRedeem));\n\n    emit WithdrawalMade(msg.sender, tokenInfo.tranche, tokenId, interestToRedeem, principalToRedeem);\n\n    return (interestToRedeem, principalToRedeem);\n  }\n\n  function _isSeniorTrancheId(uint256 trancheId) internal pure returns (bool) {\n    return trancheId.mod(NUM_TRANCHES_PER_SLICE) == 1;\n  }\n\n  function redeemableInterestAndPrincipal(TrancheInfo storage trancheInfo, IPoolTokens.TokenInfo memory tokenInfo)\n    internal\n    view\n    returns (uint256 interestRedeemable, uint256 principalRedeemable)\n  {\n    // This supports withdrawing before or after locking because principal share price starts at 1\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\n\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\n\n    return (interestRedeemable, principalRedeemable);\n  }\n\n  function _lockJuniorCapital(uint256 sliceId) internal {\n    require(!locked(), \"Pool already locked\");\n    require(poolSlices[sliceId].juniorTranche.lockedUntil == 0, \"Junior tranche already locked\");\n\n    uint256 lockedUntil = currentTime().add(config.getDrawdownPeriodInSeconds());\n    poolSlices[sliceId].juniorTranche.lockedUntil = lockedUntil;\n\n    emit TrancheLocked(address(this), poolSlices[sliceId].juniorTranche.id, lockedUntil);\n  }\n\n  function _lockPool() internal {\n    uint256 sliceId = poolSlices.length.sub(1);\n\n    require(poolSlices[sliceId].juniorTranche.lockedUntil > 0, \"Junior tranche must be locked\");\n    // Allow locking the pool only once; do not allow extending the lock of an\n    // already-locked pool. Otherwise the locker could keep the pool locked\n    // indefinitely, preventing withdrawals.\n    require(poolSlices[sliceId].seniorTranche.lockedUntil == 0, \"Lock cannot be extended\");\n\n    uint256 currentTotal = poolSlices[sliceId].juniorTranche.principalDeposited.add(\n      poolSlices[sliceId].seniorTranche.principalDeposited\n    );\n    creditLine.setLimit(Math.min(creditLine.limit().add(currentTotal), creditLine.maxLimit()));\n\n    // We start the drawdown period, so backers can withdraw unused capital after borrower draws down\n    uint256 lockPeriod = config.getDrawdownPeriodInSeconds();\n    poolSlices[sliceId].seniorTranche.lockedUntil = currentTime().add(lockPeriod);\n    poolSlices[sliceId].juniorTranche.lockedUntil = currentTime().add(lockPeriod);\n    emit TrancheLocked(\n      address(this),\n      poolSlices[sliceId].seniorTranche.id,\n      poolSlices[sliceId].seniorTranche.lockedUntil\n    );\n    emit TrancheLocked(\n      address(this),\n      poolSlices[sliceId].juniorTranche.id,\n      poolSlices[sliceId].juniorTranche.lockedUntil\n    );\n  }\n\n  function _initializeNextSlice(uint256 newFundableAt) internal {\n    uint256 numSlices = poolSlices.length;\n    require(numSlices < 5, \"Cannot exceed 5 slices\");\n    poolSlices.push(\n      PoolSlice({\n        seniorTranche: TrancheInfo({\n          id: numSlices.mul(NUM_TRANCHES_PER_SLICE).add(1),\n          principalSharePrice: usdcToSharePrice(1, 1),\n          interestSharePrice: 0,\n          principalDeposited: 0,\n          lockedUntil: 0\n        }),\n        juniorTranche: TrancheInfo({\n          id: numSlices.mul(NUM_TRANCHES_PER_SLICE).add(2),\n          principalSharePrice: usdcToSharePrice(1, 1),\n          interestSharePrice: 0,\n          principalDeposited: 0,\n          lockedUntil: 0\n        }),\n        totalInterestAccrued: 0,\n        principalDeployed: 0\n      })\n    );\n    fundableAt = newFundableAt;\n  }\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) internal returns (uint256 totalReserveAmount) {\n    safeERC20TransferFrom(config.getUSDC(), from, address(this), principal.add(interest), \"Failed to collect payment\");\n    uint256 reserveFeePercent = ONE_HUNDRED.div(config.getReserveDenominator()); // Convert the denonminator to percent\n\n    ApplyResult memory result = TranchingLogic.applyToAllSeniorTranches(\n      poolSlices,\n      interest,\n      principal,\n      reserveFeePercent,\n      totalDeployed,\n      creditLine,\n      juniorFeePercent\n    );\n\n    totalReserveAmount = result.reserveDeduction.add(\n      TranchingLogic.applyToAllJuniorTranches(\n        poolSlices,\n        result.interestRemaining,\n        result.principalRemaining,\n        reserveFeePercent,\n        totalDeployed,\n        creditLine\n      )\n    );\n\n    sendToReserve(totalReserveAmount);\n    return totalReserveAmount;\n  }\n\n  // If the senior tranche of the current slice is locked, then the pool is not open to any more deposits\n  // (could throw off leverage ratio)\n  function locked() internal view returns (bool) {\n    return poolSlices[poolSlices.length.sub(1)].seniorTranche.lockedUntil > 0;\n  }\n\n  function createAndSetCreditLine(\n    address _borrower,\n    uint256 _maxLimit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) internal {\n    address _creditLine = config.getDobermanFactory().createCreditLine();\n    creditLine = IV2CreditLine(_creditLine);\n    creditLine.initialize(\n      address(config),\n      address(this), // Set self as the owner\n      _borrower,\n      _maxLimit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n  }\n\n  function getTrancheInfo(uint256 trancheId) internal view returns (TrancheInfo storage) {\n    require(trancheId > 0 && trancheId <= poolSlices.length.mul(NUM_TRANCHES_PER_SLICE), \"Unsupported tranche\");\n    uint256 sliceId = ((trancheId.add(trancheId.mod(NUM_TRANCHES_PER_SLICE))).div(NUM_TRANCHES_PER_SLICE)).sub(1);\n    PoolSlice storage slice = poolSlices[sliceId];\n    TrancheInfo storage trancheInfo = trancheId.mod(NUM_TRANCHES_PER_SLICE) == 1\n      ? slice.seniorTranche\n      : slice.juniorTranche;\n    return trancheInfo;\n  }\n\n  function currentTime() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  function sendToReserve(uint256 amount) internal {\n    emit ReserveFundsCollected(address(this), amount);\n    safeERC20TransferFrom(\n      config.getUSDC(),\n      address(this),\n      config.reserveAddress(),\n      amount,\n      \"Failed to send to reserve\"\n    );\n  }\n\n  function collectPayment(uint256 amount) internal {\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(creditLine), amount, \"Failed to collect payment\");\n  }\n\n  function _assess() internal {\n    // We need to make sure the pool is locked before we allocate rewards to ensure it's not\n    // possible to game rewards by sandwiching an interest payment to an unlocked pool\n    // It also causes issues trying to allocate payments to an empty slice (divide by zero)\n    require(locked(), \"Pool is not locked\");\n\n    uint256 interestAccrued = creditLine.totalInterestAccrued();\n    (uint256 paymentRemaining, uint256 interestPayment, uint256 principalPayment) = creditLine.assess();\n    interestAccrued = creditLine.totalInterestAccrued().sub(interestAccrued);\n\n    // Split the interest accrued proportionally across slices so we know how much interest goes to each slice\n    // We need this because the slice start at different times, so we cannot retroactively allocate the interest\n    // linearly\n    uint256[] memory principalPaymentsPerSlice = new uint256[](poolSlices.length);\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      uint256 interestForSlice = TranchingLogic.scaleByFraction(\n        interestAccrued,\n        poolSlices[i].principalDeployed,\n        totalDeployed\n      );\n      principalPaymentsPerSlice[i] = TranchingLogic.scaleByFraction(\n        principalPayment,\n        poolSlices[i].principalDeployed,\n        totalDeployed\n      );\n      poolSlices[i].totalInterestAccrued = poolSlices[i].totalInterestAccrued.add(interestForSlice);\n    }\n\n    if (interestPayment > 0 || principalPayment > 0) {\n      uint256 reserveAmount = collectInterestAndPrincipal(\n        address(creditLine),\n        interestPayment,\n        principalPayment.add(paymentRemaining)\n      );\n\n      for (uint256 i = 0; i < poolSlices.length; i++) {\n        poolSlices[i].principalDeployed = poolSlices[i].principalDeployed.sub(principalPaymentsPerSlice[i]);\n        totalDeployed = totalDeployed.sub(principalPaymentsPerSlice[i]);\n      }\n\n      config.getBackerRewards().allocateRewards(interestPayment);\n\n      emit PaymentApplied(\n        creditLine.borrower(),\n        address(this),\n        interestPayment,\n        principalPayment,\n        paymentRemaining,\n        reserveAmount\n      );\n    }\n    emit TranchedPoolAssessed(address(this));\n  }\n\n  modifier onlyLocker() {\n    require(hasRole(LOCKER_ROLE, msg.sender), \"Must have locker role\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/TranchingLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IV2CreditLine.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title TranchingLogic\n * @notice Library for handling the payments waterfall\n * @author Doberman\n */\n\nlibrary TranchingLogic {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for uint256;\n\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\n\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\n    return totalShares == 0 ? 0 : amount.mul(FP_SCALING_FACTOR).div(totalShares);\n  }\n\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\n    return sharePrice.mul(totalShares).div(FP_SCALING_FACTOR);\n  }\n\n  function redeemableInterestAndPrincipal(\n    ITranchedPool.TrancheInfo storage trancheInfo,\n    IPoolTokens.TokenInfo memory tokenInfo\n  ) public view returns (uint256 interestRedeemable, uint256 principalRedeemable) {\n    // This supports withdrawing before or after locking because principal share price starts at 1\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\n\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\n\n    return (interestRedeemable, principalRedeemable);\n  }\n\n  function calculateExpectedSharePrice(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 sharePrice = usdcToSharePrice(amount, tranche.principalDeposited);\n    return scaleByPercentOwnership(tranche, sharePrice, slice);\n  }\n\n  function scaleForSlice(\n    ITranchedPool.PoolSlice memory slice,\n    uint256 amount,\n    uint256 totalDeployed\n  ) public pure returns (uint256) {\n    return scaleByFraction(amount, slice.principalDeployed, totalDeployed);\n  }\n\n  // We need to create this struct so we don't run into a stack too deep error due to too many variables\n  function getSliceInfo(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed,\n    uint256 reserveFeePercent\n  ) public view returns (ITranchedPool.SliceInfo memory) {\n    (uint256 interestAccrued, uint256 principalAccrued) = getTotalInterestAndPrincipal(\n      slice,\n      creditLine,\n      totalDeployed\n    );\n    return\n      ITranchedPool.SliceInfo({\n        reserveFeePercent: reserveFeePercent,\n        interestAccrued: interestAccrued,\n        principalAccrued: principalAccrued\n      });\n  }\n\n  function getTotalInterestAndPrincipal(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed\n  ) public view returns (uint256 interestAccrued, uint256 principalAccrued) {\n    principalAccrued = creditLine.principalOwed();\n    // In addition to principal actually owed, we need to account for early principal payments\n    // If the borrower pays back 5K early on a 10K loan, the actual principal accrued should be\n    // 5K (balance- deployed) + 0 (principal owed)\n    principalAccrued = totalDeployed.sub(creditLine.balance()).add(principalAccrued);\n    // Now we need to scale that correctly for the slice we're interested in\n    principalAccrued = scaleForSlice(slice, principalAccrued, totalDeployed);\n    // Finally, we need to account for partial drawdowns. e.g. If 20K was deposited, and only 10K was drawn down,\n    // Then principal accrued should start at 10K (total deposited - principal deployed), not 0. This is because\n    // share price starts at 1, and is decremented by what was drawn down.\n    uint256 totalDeposited = slice.seniorTranche.principalDeposited.add(slice.juniorTranche.principalDeposited);\n    principalAccrued = totalDeposited.sub(slice.principalDeployed).add(principalAccrued);\n    return (slice.totalInterestAccrued, principalAccrued);\n  }\n\n  function scaleByFraction(\n    uint256 amount,\n    uint256 fraction,\n    uint256 total\n  ) public pure returns (uint256) {\n    FixedPoint.Unsigned memory totalAsFixedPoint = FixedPoint.fromUnscaledUint(total);\n    FixedPoint.Unsigned memory fractionAsFixedPoint = FixedPoint.fromUnscaledUint(fraction);\n    return fractionAsFixedPoint.div(totalAsFixedPoint).mul(amount).div(FP_SCALING_FACTOR).rawValue;\n  }\n\n  function applyToAllSeniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine,\n    uint256 juniorFeePercent\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    ITranchedPool.ApplyResult memory seniorApplyResult;\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n\n      // Since slices cannot be created when the loan is late, all interest collected can be assumed to split\n      // pro-rata across the slices. So we scale the interest and principal to the slice\n      ITranchedPool.ApplyResult memory applyResult = applyToSeniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        juniorFeePercent,\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].seniorTranche, applyResult);\n      seniorApplyResult.interestRemaining = seniorApplyResult.interestRemaining.add(applyResult.interestRemaining);\n      seniorApplyResult.principalRemaining = seniorApplyResult.principalRemaining.add(applyResult.principalRemaining);\n      seniorApplyResult.reserveDeduction = seniorApplyResult.reserveDeduction.add(applyResult.reserveDeduction);\n    }\n    return seniorApplyResult;\n  }\n\n  function applyToAllJuniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine\n  ) public returns (uint256 totalReserveAmount) {\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n      // Any remaining interest and principal is then shared pro-rata with the junior slices\n      ITranchedPool.ApplyResult memory applyResult = applyToJuniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].juniorTranche, applyResult);\n      totalReserveAmount = totalReserveAmount.add(applyResult.reserveDeduction);\n    }\n    return totalReserveAmount;\n  }\n\n  function emitSharePriceUpdatedEvent(\n    ITranchedPool.TrancheInfo memory tranche,\n    ITranchedPool.ApplyResult memory applyResult\n  ) internal {\n    emit SharePriceUpdated(\n      address(this),\n      tranche.id,\n      tranche.principalSharePrice,\n      int256(tranche.principalSharePrice.sub(applyResult.oldPrincipalSharePrice)),\n      tranche.interestSharePrice,\n      int256(tranche.interestSharePrice.sub(applyResult.oldInterestSharePrice))\n    );\n  }\n\n  function applyToSeniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 juniorFeePercent,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // First determine the expected share price for the senior tranche. This is the gross amount the senior\n    // tranche should receive.\n    uint256 expectedInterestSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.interestAccrued,\n      slice\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n\n    // Deduct the junior fee and the protocol reserve\n    uint256 desiredNetInterestSharePrice = scaleByFraction(\n      expectedInterestSharePrice,\n      ONE_HUNDRED.sub(juniorFeePercent.add(sliceInfo.reserveFeePercent)),\n      ONE_HUNDRED\n    );\n    // Collect protocol fee interest received (we've subtracted this from the senior portion above)\n    uint256 reserveDeduction = scaleByFraction(interestRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    uint256 oldInterestSharePrice = slice.seniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.seniorTranche.principalSharePrice;\n    // Apply the interest remaining so we get up to the netInterestSharePrice\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.seniorTranche,\n      interestRemaining,\n      principalRemaining,\n      desiredNetInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyToJuniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // Then fill up the junior tranche with all the interest remaining, upto the principal share price\n    uint256 expectedInterestSharePrice = slice.juniorTranche.interestSharePrice.add(\n      usdcToSharePrice(interestRemaining, slice.juniorTranche.principalDeposited)\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.juniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n    uint256 oldInterestSharePrice = slice.juniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.juniorTranche.principalSharePrice;\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.juniorTranche,\n      interestRemaining,\n      principalRemaining,\n      expectedInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n\n    // All remaining interest and principal is applied towards the junior tranche as interest\n    interestRemaining = interestRemaining.add(principalRemaining);\n    // Since any principal remaining is treated as interest (there is \"extra\" interest to be distributed)\n    // we need to make sure to collect the protocol fee on the additional interest (we only deducted the\n    // fee on the original interest portion)\n    uint256 reserveDeduction = scaleByFraction(principalRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    principalRemaining = 0;\n\n    (interestRemaining, principalRemaining) = applyByAmount(\n      slice.juniorTranche,\n      interestRemaining.add(principalRemaining),\n      0,\n      interestRemaining.add(principalRemaining),\n      0\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyBySharePrice(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestSharePrice,\n    uint256 desiredPrincipalSharePrice\n  ) public returns (uint256, uint256) {\n    uint256 desiredInterestAmount = desiredAmountFromSharePrice(\n      desiredInterestSharePrice,\n      tranche.interestSharePrice,\n      tranche.principalDeposited\n    );\n    uint256 desiredPrincipalAmount = desiredAmountFromSharePrice(\n      desiredPrincipalSharePrice,\n      tranche.principalSharePrice,\n      tranche.principalDeposited\n    );\n    return applyByAmount(tranche, interestRemaining, principalRemaining, desiredInterestAmount, desiredPrincipalAmount);\n  }\n\n  function applyByAmount(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestAmount,\n    uint256 desiredPrincipalAmount\n  ) public returns (uint256, uint256) {\n    uint256 totalShares = tranche.principalDeposited;\n    uint256 newSharePrice;\n\n    (interestRemaining, newSharePrice) = applyToSharePrice(\n      interestRemaining,\n      tranche.interestSharePrice,\n      desiredInterestAmount,\n      totalShares\n    );\n    tranche.interestSharePrice = newSharePrice;\n\n    (principalRemaining, newSharePrice) = applyToSharePrice(\n      principalRemaining,\n      tranche.principalSharePrice,\n      desiredPrincipalAmount,\n      totalShares\n    );\n    tranche.principalSharePrice = newSharePrice;\n    return (interestRemaining, principalRemaining);\n  }\n\n  function migrateAccountingVariables(address originalClAddr, address newClAddr) public {\n    IV2CreditLine originalCl = IV2CreditLine(originalClAddr);\n    IV2CreditLine newCl = IV2CreditLine(newClAddr);\n\n    // Copy over all accounting variables\n    newCl.setBalance(originalCl.balance());\n    newCl.setLimit(originalCl.limit());\n    newCl.setInterestOwed(originalCl.interestOwed());\n    newCl.setPrincipalOwed(originalCl.principalOwed());\n    newCl.setTermEndTime(originalCl.termEndTime());\n    newCl.setNextDueTime(originalCl.nextDueTime());\n    newCl.setInterestAccruedAsOf(originalCl.interestAccruedAsOf());\n    newCl.setLastFullPaymentTime(originalCl.lastFullPaymentTime());\n    newCl.setTotalInterestAccrued(originalCl.totalInterestAccrued());\n  }\n\n  function closeCreditLine(address originalCl) public {\n    // Close out old CL\n    IV2CreditLine oldCreditLine = IV2CreditLine(originalCl);\n    oldCreditLine.setBalance(0);\n    oldCreditLine.setLimit(0);\n    oldCreditLine.setMaxLimit(0);\n  }\n\n  function desiredAmountFromSharePrice(\n    uint256 desiredSharePrice,\n    uint256 actualSharePrice,\n    uint256 totalShares\n  ) public pure returns (uint256) {\n    // If the desired share price is lower, then ignore it, and leave it unchanged\n    if (desiredSharePrice < actualSharePrice) {\n      desiredSharePrice = actualSharePrice;\n    }\n    uint256 sharePriceDifference = desiredSharePrice.sub(actualSharePrice);\n    return sharePriceToUsdc(sharePriceDifference, totalShares);\n  }\n\n  function applyToSharePrice(\n    uint256 amountRemaining,\n    uint256 currentSharePrice,\n    uint256 desiredAmount,\n    uint256 totalShares\n  ) public pure returns (uint256, uint256) {\n    // If no money left to apply, or don't need any changes, return the original amounts\n    if (amountRemaining == 0 || desiredAmount == 0) {\n      return (amountRemaining, currentSharePrice);\n    }\n    if (amountRemaining < desiredAmount) {\n      // We don't have enough money to adjust share price to the desired level. So just use whatever amount is left\n      desiredAmount = amountRemaining;\n    }\n    uint256 sharePriceDifference = usdcToSharePrice(desiredAmount, totalShares);\n    return (amountRemaining.sub(desiredAmount), currentSharePrice.add(sharePriceDifference));\n  }\n\n  function scaleByPercentOwnership(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 totalDeposited = slice.juniorTranche.principalDeposited.add(slice.seniorTranche.principalDeposited);\n    return scaleByFraction(amount, tranche.principalDeposited, totalDeposited);\n  }\n}\n"
    },
    "contracts/protocol/core/UniqueIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\";\n\nimport \"../../external/ERC1155PresetPauserUpgradeable.sol\";\nimport \"../../interfaces/IUniqueIdentity.sol\";\n\n/**\n * @title UniqueIdentity\n * @notice UniqueIdentity is an ERC1155-compliant contract for representing\n * the identity verification status of addresses.\n * @author Doberman\n */\n\ncontract UniqueIdentity is ERC1155PresetPauserUpgradeable, IUniqueIdentity {\n  bytes32 public constant SIGNER_ROLE = keccak256(\"SIGNER_ROLE\");\n\n  uint256 public constant ID_TYPE_0 = 0;\n  uint256 public constant ID_TYPE_1 = 1;\n  uint256 public constant ID_TYPE_2 = 2;\n  uint256 public constant ID_TYPE_3 = 3;\n  uint256 public constant ID_TYPE_4 = 4;\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  uint256 public constant MINT_COST_PER_TOKEN = 830000 gwei;\n\n  /// @dev We include a nonce in every hashed message, and increment the nonce as part of a\n  /// state-changing operation, so as to prevent replay attacks, i.e. the reuse of a signature.\n  mapping(address => uint256) public nonces;\n  mapping(uint256 => bool) public supportedUIDTypes;\n\n  function initialize(address owner, string memory uri) public initializer {\n    require(owner != address(0), \"Owner address cannot be empty\");\n\n    __ERC1155PresetPauser_init(owner, uri);\n    __UniqueIdentity_init(owner);\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __UniqueIdentity_init(address owner) internal initializer {\n    __UniqueIdentity_init_unchained(owner);\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __UniqueIdentity_init_unchained(address owner) internal initializer {\n    _setupRole(SIGNER_ROLE, owner);\n    _setRoleAdmin(SIGNER_ROLE, OWNER_ROLE);\n  }\n\n  function setSupportedUIDTypes(uint256[] calldata ids, bool[] calldata values) public onlyAdmin {\n    require(ids.length == values.length, \"accounts and ids length mismatch\");\n    for (uint256 i = 0; i < ids.length; ++i) {\n      supportedUIDTypes[ids[i]] = values[i];\n    }\n  }\n\n  /**\n   * @dev Gets the token name.\n   * @return string representing the token name\n   */\n  function name() public pure returns (string memory) {\n    return \"Unique Identity\";\n  }\n\n  /**\n   * @dev Gets the token symbol.\n   * @return string representing the token symbol\n   */\n  function symbol() public pure returns (string memory) {\n    return \"UID\";\n  }\n\n  function mint(\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) public payable override onlySigner(_msgSender(), id, expiresAt, signature) incrementNonce(_msgSender()) {\n    require(msg.value >= MINT_COST_PER_TOKEN, \"Token mint requires 0.00083 ETH\");\n    require(supportedUIDTypes[id] == true, \"Token id not supported\");\n    require(balanceOf(_msgSender(), id) == 0, \"Balance before mint must be 0\");\n\n    _mint(_msgSender(), id, 1, \"\");\n  }\n\n  function burn(\n    address account,\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) public override onlySigner(account, id, expiresAt, signature) incrementNonce(account) {\n    _burn(account, id, 1);\n\n    uint256 accountBalance = balanceOf(account, id);\n    require(accountBalance == 0, \"Balance after burn must be 0\");\n  }\n\n  function _beforeTokenTransfer(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) internal override(ERC1155PresetPauserUpgradeable) {\n    require(\n      (from == address(0) && to != address(0)) || (from != address(0) && to == address(0)),\n      \"Only mint or burn transfers are allowed\"\n    );\n    super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n  }\n\n  modifier onlySigner(\n    address account,\n    uint256 id,\n    uint256 expiresAt,\n    bytes calldata signature\n  ) {\n    require(block.timestamp < expiresAt, \"Signature has expired\");\n\n    bytes32 hash = keccak256(abi.encodePacked(account, id, expiresAt, address(this), nonces[account], block.chainid));\n    bytes32 ethSignedMessage = ECDSAUpgradeable.toEthSignedMessageHash(hash);\n    require(hasRole(SIGNER_ROLE, ECDSAUpgradeable.recover(ethSignedMessage, signature)), \"Invalid signer\");\n    _;\n  }\n\n  modifier incrementNonce(address account) {\n    nonces[account] += 1;\n    _;\n  }\n}\n"
    },
    "contracts/protocol/periphery/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier:MIT\n// solhint-disable no-inline-assembly\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public trustedForwarder;\n\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal override virtual view returns (bytes memory ret) {\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // we copy the msg.data , except the last 20 bytes (and update the total length)\n            assembly {\n                let ptr := mload(0x40)\n                // copy only size-20 bytes\n                let size := sub(calldatasize(),20)\n                // structure RLP data as <offset> <length> <bytes>\n                mstore(ptr, 0x20)\n                mstore(add(ptr,32), size)\n                calldatacopy(add(ptr,64), 0, size)\n                return(ptr, add(size,64))\n            }\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/protocol/periphery/Borrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../core/BaseUpgradeablePausable.sol\";\nimport \"../core/ConfigHelper.sol\";\nimport \"../core/CreditLine.sol\";\nimport \"../core/DobermanConfig.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IBorrower.sol\";\nimport \"./BaseRelayRecipient.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title Doberman's Borrower contract\n * @notice These contracts represent the a convenient way for a borrower to interact with Doberman\n *  They are 100% optional. However, they let us add many sophisticated and convient features for borrowers\n *  while still keeping our core protocol small and secure. We therefore expect most borrowers will use them.\n *  This contract is the \"official\" borrower contract that will be maintained by Doberman governance. However,\n *  in theory, anyone can fork or create their own version, or not use any contract at all. The core functionality\n *  is completely agnostic to whether it is interacting with a contract or an externally owned account (EOA).\n * @author Doberman\n */\n\ncontract Borrower is BaseUpgradeablePausable, BaseRelayRecipient, IBorrower {\n  using SafeMath for uint256;\n\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  address private constant USDT_ADDRESS = address(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n  address private constant BUSD_ADDRESS = address(0x4Fabb145d64652a948d72533023f6E7A623C7C53);\n  address private constant GUSD_ADDRESS = address(0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd);\n  address private constant DAI_ADDRESS = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n\n  function initialize(address owner, address _config) external override initializer {\n    require(owner != address(0) && _config != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = DobermanConfig(_config);\n\n    // trustedForwarder = config.trustedForwarderAddress();\n\n    // Handle default approvals. Pool, and OneInch for maximum amounts\n    // address oneInch = config.oneInchAddress();\n    // IERC20withDec usdc = config.getUSDC();\n    // usdc.approve(oneInch, type(uint256).max);\n    // bytes memory data = abi.encodeWithSignature(\"approve(address,uint256)\", oneInch, type(uint256).max);\n    // invoke(USDT_ADDRESS, data);\n    // invoke(BUSD_ADDRESS, data);\n    // invoke(GUSD_ADDRESS, data);\n    // invoke(DAI_ADDRESS, data);\n  }\n\n  function lockJuniorCapital(address poolAddress) external onlyAdmin {\n    ITranchedPool(poolAddress).lockJuniorCapital();\n  }\n\n  function lockPool(address poolAddress) external onlyAdmin {\n    ITranchedPool(poolAddress).lockPool();\n  }\n\n  /**\n   * @notice Allows a borrower to drawdown on their creditline through the CreditDesk.\n   * @param poolAddress The creditline from which they would like to drawdown\n   * @param amount The amount, in USDC atomic units, that a borrower wishes to drawdown\n   * @param addressToSendTo The address where they would like the funds sent. If the zero address is passed,\n   *  it will be defaulted to the contracts address (msg.sender). This is a convenience feature for when they would\n   *  like the funds sent to an exchange or alternate wallet, different from the authentication address\n   */\n  function drawdown(\n    address poolAddress,\n    uint256 amount,\n    address addressToSendTo\n  ) external onlyAdmin {\n    ITranchedPool(poolAddress).drawdown(amount);\n\n    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {\n      addressToSendTo = _msgSender();\n    }\n\n    transferERC20(config.usdcAddress(), addressToSendTo, amount);\n  }\n\n  function drawdownWithSwapOnOneInch(\n    address poolAddress,\n    uint256 amount,\n    address addressToSendTo,\n    address toToken,\n    uint256 minTargetAmount,\n    uint256[] calldata exchangeDistribution\n  ) public onlyAdmin {\n    // Drawdown to the Borrower contract\n    ITranchedPool(poolAddress).drawdown(amount);\n\n    // Do the swap\n    swapOnOneInch(config.usdcAddress(), toToken, amount, minTargetAmount, exchangeDistribution);\n\n    // Default to sending to the owner, and don't let funds stay in this contract\n    if (addressToSendTo == address(0) || addressToSendTo == address(this)) {\n      addressToSendTo = _msgSender();\n    }\n\n    // Fulfill the send to\n    bytes memory _data = abi.encodeWithSignature(\"balanceOf(address)\", address(this));\n    uint256 receivedAmount = toUint256(invoke(toToken, _data));\n    transferERC20(toToken, addressToSendTo, receivedAmount);\n  }\n\n  function transferERC20(\n    address token,\n    address to,\n    uint256 amount\n  ) public onlyAdmin {\n    bytes memory _data = abi.encodeWithSignature(\"transfer(address,uint256)\", to, amount);\n    invoke(token, _data);\n  }\n\n  /**\n   * @notice Allows a borrower to payback loans by calling the `pay` function directly on the CreditDesk\n   * @param poolAddress The credit line to be paid back\n   * @param amount The amount, in USDC atomic units, that the borrower wishes to pay\n   */\n  function pay(address poolAddress, uint256 amount) external onlyAdmin {\n    IERC20withDec usdc = config.getUSDC();\n    bool success = usdc.transferFrom(_msgSender(), address(this), amount);\n    require(success, \"Failed to transfer USDC\");\n    _transferAndPay(usdc, poolAddress, amount);\n  }\n\n  function payMultiple(address[] calldata pools, uint256[] calldata amounts) external onlyAdmin {\n    require(pools.length == amounts.length, \"Pools and amounts must be the same length\");\n\n    uint256 totalAmount;\n    for (uint256 i = 0; i < amounts.length; i++) {\n      totalAmount = totalAmount.add(amounts[i]);\n    }\n\n    IERC20withDec usdc = config.getUSDC();\n    // Do a single transfer, which is cheaper\n    bool success = usdc.transferFrom(_msgSender(), address(this), totalAmount);\n    require(success, \"Failed to transfer USDC\");\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      _transferAndPay(usdc, pools[i], amounts[i]);\n    }\n  }\n\n  function payInFull(address poolAddress, uint256 amount) external onlyAdmin {\n    IERC20withDec usdc = config.getUSDC();\n    bool success = usdc.transferFrom(_msgSender(), address(this), amount);\n    require(success, \"Failed to transfer USDC\");\n\n    _transferAndPay(usdc, poolAddress, amount);\n    require(ITranchedPool(poolAddress).creditLine().balance() == 0, \"Failed to fully pay off creditline\");\n  }\n\n  function payWithSwapOnOneInch(\n    address poolAddress,\n    uint256 originAmount,\n    address fromToken,\n    uint256 minTargetAmount,\n    uint256[] calldata exchangeDistribution\n  ) external onlyAdmin {\n    transferFrom(fromToken, _msgSender(), address(this), originAmount);\n    IERC20withDec usdc = config.getUSDC();\n    swapOnOneInch(fromToken, address(usdc), originAmount, minTargetAmount, exchangeDistribution);\n    uint256 usdcBalance = usdc.balanceOf(address(this));\n    _transferAndPay(usdc, poolAddress, usdcBalance);\n  }\n\n  function payMultipleWithSwapOnOneInch(\n    address[] calldata pools,\n    uint256[] calldata minAmounts,\n    uint256 originAmount,\n    address fromToken,\n    uint256[] calldata exchangeDistribution\n  ) external onlyAdmin {\n    require(pools.length == minAmounts.length, \"Pools and amounts must be the same length\");\n\n    uint256 totalMinAmount = 0;\n    for (uint256 i = 0; i < minAmounts.length; i++) {\n      totalMinAmount = totalMinAmount.add(minAmounts[i]);\n    }\n\n    transferFrom(fromToken, _msgSender(), address(this), originAmount);\n\n    IERC20withDec usdc = config.getUSDC();\n    swapOnOneInch(fromToken, address(usdc), originAmount, totalMinAmount, exchangeDistribution);\n\n    for (uint256 i = 0; i < minAmounts.length; i++) {\n      _transferAndPay(usdc, pools[i], minAmounts[i]);\n    }\n\n    uint256 remainingUSDC = usdc.balanceOf(address(this));\n    if (remainingUSDC > 0) {\n      _transferAndPay(usdc, pools[0], remainingUSDC);\n    }\n  }\n\n  function _transferAndPay(\n    IERC20withDec usdc,\n    address poolAddress,\n    uint256 amount\n  ) internal {\n    ITranchedPool pool = ITranchedPool(poolAddress);\n    // We don't use transferFrom since it would require a separate approval per creditline\n    bool success = usdc.transfer(address(pool.creditLine()), amount);\n    require(success, \"USDC Transfer to creditline failed\");\n    pool.assess();\n  }\n\n  function transferFrom(\n    address erc20,\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal {\n    bytes memory _data;\n    // Do a low-level invoke on this transfer, since Tether fails if we use the normal IERC20 interface\n    _data = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", sender, recipient, amount);\n    invoke(address(erc20), _data);\n  }\n\n  function swapOnOneInch(\n    address fromToken,\n    address toToken,\n    uint256 originAmount,\n    uint256 minTargetAmount,\n    uint256[] calldata exchangeDistribution\n  ) internal {\n    bytes memory _data = abi.encodeWithSignature(\n      \"swap(address,address,uint256,uint256,uint256[],uint256)\",\n      fromToken,\n      toToken,\n      originAmount,\n      minTargetAmount,\n      exchangeDistribution,\n      0\n    );\n    invoke(config.oneInchAddress(), _data);\n  }\n\n  /**\n   * @notice Performs a generic transaction.\n   * @param _target The address for the transaction.\n   * @param _data The data of the transaction.\n   * Mostly copied from Argent:\n   * https://github.com/argentlabs/argent-contracts/blob/develop/contracts/wallet/BaseWallet.sol#L111\n   */\n  function invoke(address _target, bytes memory _data) internal returns (bytes memory) {\n    // External contracts can be compiled with different Solidity versions\n    // which can cause \"revert without reason\" when called through,\n    // for example, a standard IERC20 ABI compiled on the latest version.\n    // This low-level call avoids that issue.\n\n    bool success;\n    bytes memory _res;\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, _res) = _target.call(_data);\n    if (!success && _res.length > 0) {\n      // solhint-disable-next-line no-inline-assembly\n      assembly {\n        returndatacopy(0, 0, returndatasize())\n        revert(0, returndatasize())\n      }\n    } else if (!success) {\n      revert(\"VM: wallet invoke reverted\");\n    }\n    return _res;\n  }\n\n  function toUint256(bytes memory _bytes) internal pure returns (uint256 value) {\n    assembly {\n      value := mload(add(_bytes, 0x20))\n    }\n  }\n\n  // OpenZeppelin contracts come with support for GSN _msgSender() (which just defaults to msg.sender)\n  // Since there are two different versions of the function in the hierarchy, we need to instruct solidity to\n  // use the relay recipient version which can actually pull the real sender from the parameters.\n  // https://www.notion.so/My-contract-is-using-OpenZeppelin-How-do-I-add-GSN-support-2bee7e9d5f774a0cbb60d3a8de03e9fb\n  function _msgSender() internal view override(ContextUpgradeable, BaseRelayRecipient) returns (address) {\n    return BaseRelayRecipient._msgSender();\n  }\n\n  function _msgData() internal view override(ContextUpgradeable, BaseRelayRecipient) returns (bytes memory ret) {\n    return BaseRelayRecipient._msgData();\n  }\n\n  function versionRecipient() external pure override returns (string memory) {\n    return \"2.0.0\";\n  }\n}\n"
    },
    "contracts/protocol/periphery/TransferRestrictedVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport \"../../external/ERC721PresetMinterPauserAutoId.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/IFidu.sol\";\nimport \"../core/BaseUpgradeablePausable.sol\";\nimport \"../core/DobermanConfig.sol\";\nimport \"../core/ConfigHelper.sol\";\nimport \"../../library/SafeERC20Transfer.sol\";\n\ncontract TransferRestrictedVault is\n  ERC721PresetMinterPauserAutoIdUpgradeSafe,\n  ReentrancyGuardUpgradeable,\n  SafeERC20Transfer\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  uint256 public constant SECONDS_PER_DAY = 60;\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using SafeMath for uint256;\n  using Counters for Counters.Counter;\n\n  struct PoolTokenPosition {\n    uint256 tokenId;\n    uint256 lockedUntil;\n  }\n\n  struct FiduPosition {\n    uint256 amount;\n    uint256 lockedUntil;\n  }\n\n  // tokenId => poolTokenPosition\n  mapping(uint256 => PoolTokenPosition) public poolTokenPositions;\n  // tokenId => fiduPosition\n  mapping(uint256 => FiduPosition) public fiduPositions;\n\n  /*\n    We are using our own initializer function so that OZ doesn't automatically\n    set owner as msg.sender. Also, it lets us set our config contract\n  */\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(address owner, DobermanConfig _config) external initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __Context_init_unchained();\n    __AccessControl_init_unchained();\n    __ReentrancyGuard_init_unchained();\n    __ERC165_init_unchained();\n    __ERC721_init_unchained(\"Doberman V2 Accredited Investor Tokens\", \"GFI-V2-AI\");\n    __Pausable_init_unchained();\n    __ERC721Pausable_init_unchained();\n\n    config = _config;\n\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(OWNER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function depositJunior(ITranchedPool tranchedPool, uint256 amount) public nonReentrant {\n    require(config.getGo().go(msg.sender), \"This address has not been go-listed\");\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(this), amount);\n\n    approveSpender(address(tranchedPool), amount);\n    uint256 poolTokenId = tranchedPool.deposit(uint256(ITranchedPool.Tranches.Junior), amount);\n\n    uint256 transferRestrictionPeriodInSeconds = SECONDS_PER_DAY.mul(config.getTransferRestrictionPeriodInDays());\n\n    _tokenIdTracker.increment();\n    uint256 tokenId = _tokenIdTracker.current();\n    poolTokenPositions[tokenId] = PoolTokenPosition({\n      tokenId: poolTokenId,\n      lockedUntil: block.timestamp.add(transferRestrictionPeriodInSeconds)\n    });\n    _mint(msg.sender, tokenId);\n  }\n\n  function depositJuniorWithPermit(\n    ITranchedPool tranchedPool,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n    depositJunior(tranchedPool, amount);\n  }\n\n  function depositSenior(uint256 amount) public nonReentrant {\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(this), amount);\n\n    ISeniorPool seniorPool = config.getSeniorPool();\n    approveSpender(address(seniorPool), amount);\n    uint256 depositShares = seniorPool.deposit(amount);\n\n    uint256 transferRestrictionPeriodInSeconds = SECONDS_PER_DAY.mul(config.getTransferRestrictionPeriodInDays());\n\n    _tokenIdTracker.increment();\n    uint256 tokenId = _tokenIdTracker.current();\n    fiduPositions[tokenId] = FiduPosition({\n      amount: depositShares,\n      lockedUntil: block.timestamp.add(transferRestrictionPeriodInSeconds)\n    });\n    _mint(msg.sender, tokenId);\n  }\n\n  function depositSeniorWithPermit(\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n    depositSenior(amount);\n  }\n\n  function withdrawSenior(uint256 tokenId, uint256 usdcAmount) public nonReentrant onlyTokenOwner(tokenId) {\n    IFidu fidu = config.getFidu();\n    ISeniorPool seniorPool = config.getSeniorPool();\n\n    uint256 fiduBalanceBefore = fidu.balanceOf(address(this));\n\n    uint256 receivedAmount = seniorPool.withdraw(usdcAmount);\n\n    uint256 fiduUsed = fiduBalanceBefore.sub(fidu.balanceOf(address(this)));\n\n    FiduPosition storage fiduPosition = fiduPositions[tokenId];\n\n    uint256 fiduPositionAmount = fiduPosition.amount;\n    require(fiduPositionAmount >= fiduUsed, \"Not enough Fidu for withdrawal\");\n    fiduPosition.amount = fiduPositionAmount.sub(fiduUsed);\n\n    safeERC20Transfer(config.getUSDC(), msg.sender, receivedAmount);\n  }\n\n  function withdrawSeniorInFidu(uint256 tokenId, uint256 shares) public nonReentrant onlyTokenOwner(tokenId) {\n    FiduPosition storage fiduPosition = fiduPositions[tokenId];\n    uint256 fiduPositionAmount = fiduPosition.amount;\n    require(fiduPositionAmount >= shares, \"Not enough Fidu for withdrawal\");\n\n    fiduPosition.amount = fiduPositionAmount.sub(shares);\n    uint256 usdcAmount = config.getSeniorPool().withdrawInFidu(shares);\n    safeERC20Transfer(config.getUSDC(), msg.sender, usdcAmount);\n  }\n\n  function withdrawJunior(uint256 tokenId, uint256 amount)\n    public\n    nonReentrant\n    onlyTokenOwner(tokenId)\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    PoolTokenPosition storage position = poolTokenPositions[tokenId];\n    require(position.lockedUntil > 0, \"Position is empty\");\n\n    IPoolTokens poolTokens = config.getPoolTokens();\n    uint256 poolTokenId = position.tokenId;\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(poolTokenId);\n    ITranchedPool pool = ITranchedPool(tokenInfo.pool);\n\n    (interestWithdrawn, principalWithdrawn) = pool.withdraw(poolTokenId, amount);\n    uint256 totalWithdrawn = interestWithdrawn.add(principalWithdrawn);\n    safeERC20Transfer(config.getUSDC(), msg.sender, totalWithdrawn);\n    return (interestWithdrawn, principalWithdrawn);\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 tokenId, // solhint-disable-line no-unused-vars\n    uint256 batchSize\n  ) internal virtual override(ERC721PresetMinterPauserAutoIdUpgradeSafe) {\n    // AccreditedInvestor tokens can never be transferred. The underlying positions,\n    // however, can be transferred after the timelock expires.\n    require(from == address(0) || to == address(0), \"TransferRestrictedVault tokens cannot be transferred\");\n  }\n\n  /**\n   * @dev This method assumes that positions are mutually exclusive i.e. that the token\n   *  represents a position in either PoolTokens or Fidu, but not both.\n   */\n  function transferPosition(uint256 tokenId, address to) public nonReentrant {\n    require(ownerOf(tokenId) == msg.sender, \"Cannot transfer position of token you don't own\");\n\n    FiduPosition storage fiduPosition = fiduPositions[tokenId];\n    if (fiduPosition.lockedUntil > 0) {\n      require(\n        block.timestamp >= fiduPosition.lockedUntil,\n        \"Underlying position cannot be transferred until lockedUntil\"\n      );\n\n      transferFiduPosition(fiduPosition, to);\n      delete fiduPositions[tokenId];\n    }\n\n    PoolTokenPosition storage poolTokenPosition = poolTokenPositions[tokenId];\n    if (poolTokenPosition.lockedUntil > 0) {\n      require(\n        block.timestamp >= poolTokenPosition.lockedUntil,\n        \"Underlying position cannot be transferred until lockedUntil\"\n      );\n\n      transferPoolTokenPosition(poolTokenPosition, to);\n      delete poolTokenPositions[tokenId];\n    }\n\n    _burn(tokenId);\n  }\n\n  function transferPoolTokenPosition(PoolTokenPosition storage position, address to) internal {\n    IPoolTokens poolTokens = config.getPoolTokens();\n    poolTokens.safeTransferFrom(address(this), to, position.tokenId);\n  }\n\n  function transferFiduPosition(FiduPosition storage position, address to) internal {\n    IFidu fidu = config.getFidu();\n    safeERC20Transfer(fidu, to, position.amount);\n  }\n\n  function approveSpender(address spender, uint256 allowance) internal {\n    IERC20withDec usdc = config.getUSDC();\n    safeERC20Approve(usdc, spender, allowance);\n  }\n\n  modifier onlyTokenOwner(uint256 tokenId) {\n    require(ownerOf(tokenId) == msg.sender, \"Only the token owner is allowed to call this function\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/periphery/V2Migrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"../core/BaseUpgradeablePausable.sol\";\nimport \"../core/ConfigHelper.sol\";\nimport \"../core/CreditLine.sol\";\nimport \"../core/DobermanConfig.sol\";\nimport \"../../interfaces/IMigrate.sol\";\n\n/**\n * @title V2 Migrator Contract\n * @notice This is a one-time use contract solely for the purpose of migrating from our V1\n *  to our V2 architecture. It will be temporarily granted authority from the Doberman governance,\n *  and then revokes it's own authority and transfers it back to governance.\n * @author Doberman\n */\n\ncontract V2Migrator is BaseUpgradeablePausable {\n  bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n  bytes32 public constant GO_LISTER_ROLE = keccak256(\"GO_LISTER_ROLE\");\n  using SafeMath for uint256;\n\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n\n  mapping(address => address) public borrowerContracts;\n  event CreditLineMigrated(address indexed owner, address indexed clToMigrate, address newCl, address tranchedPool);\n\n  function initialize(address owner, address _config) external initializer {\n    require(owner != address(0) && _config != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = DobermanConfig(_config);\n  }\n\n  function migratePhase1(DobermanConfig newConfig) external onlyAdmin {\n    pauseEverything();\n    migrateToNewConfig(newConfig);\n    migrateToSeniorPool(newConfig);\n  }\n\n  function migrateCreditLines(\n    DobermanConfig newConfig,\n    address[][] calldata creditLinesToMigrate,\n    uint256[][] calldata migrationData\n  ) external onlyAdmin {\n    IMigrate creditDesk = IMigrate(newConfig.creditDeskAddress());\n    IDobermanFactory factory = newConfig.getDobermanFactory();\n    for (uint256 i = 0; i < creditLinesToMigrate.length; i++) {\n      address[] calldata clData = creditLinesToMigrate[i];\n      uint256[] calldata data = migrationData[i];\n      address clAddress = clData[0];\n      address owner = clData[1];\n      address borrowerContract = borrowerContracts[owner];\n      if (borrowerContract == address(0)) {\n        borrowerContract = factory.createBorrower(owner);\n        borrowerContracts[owner] = borrowerContract;\n      }\n      (address newCl, address pool) = creditDesk.migrateV1CreditLine(\n        clAddress,\n        borrowerContract,\n        data[0],\n        data[1],\n        data[2],\n        data[3],\n        data[4]\n      );\n      emit CreditLineMigrated(owner, clAddress, newCl, pool);\n    }\n  }\n\n  function bulkAddToGoList(DobermanConfig newConfig, address[] calldata members) external onlyAdmin {\n    newConfig.bulkAddToGoList(members);\n  }\n\n  function pauseEverything() internal {\n    IMigrate(config.creditDeskAddress()).pause();\n    IMigrate(config.poolAddress()).pause();\n    IMigrate(config.fiduAddress()).pause();\n  }\n\n  function migrateToNewConfig(DobermanConfig newConfig) internal {\n    uint256 key = uint256(ConfigOptions.Addresses.DobermanConfig);\n    config.setAddress(key, address(newConfig));\n\n    IMigrate(config.creditDeskAddress()).updateDobermanConfig();\n    IMigrate(config.poolAddress()).updateDobermanConfig();\n    IMigrate(config.fiduAddress()).updateDobermanConfig();\n    IMigrate(config.DobermanFactoryAddress()).updateDobermanConfig();\n\n    key = uint256(ConfigOptions.Numbers.DrawdownPeriodInSeconds);\n    newConfig.setNumber(key, 24 * 60 * 60);\n\n    key = uint256(ConfigOptions.Numbers.TransferRestrictionPeriodInDays);\n    newConfig.setNumber(key, 365);\n\n    key = uint256(ConfigOptions.Numbers.LeverageRatio);\n    // 1e18 is the LEVERAGE_RATIO_DECIMALS\n    newConfig.setNumber(key, 3 * 1e18);\n  }\n\n  function upgradeImplementations(DobermanConfig _config, address[] calldata newDeployments) public {\n    address newPoolAddress = newDeployments[0];\n    address newCreditDeskAddress = newDeployments[1];\n    address newFiduAddress = newDeployments[2];\n    address newDobermanFactoryAddress = newDeployments[3];\n\n    bytes memory data;\n    IMigrate pool = IMigrate(_config.poolAddress());\n    IMigrate creditDesk = IMigrate(_config.creditDeskAddress());\n    IMigrate fidu = IMigrate(_config.fiduAddress());\n    IMigrate DobermanFactory = IMigrate(_config.DobermanFactoryAddress());\n\n    // Upgrade implementations\n    pool.changeImplementation(newPoolAddress, data);\n    creditDesk.changeImplementation(newCreditDeskAddress, data);\n    fidu.changeImplementation(newFiduAddress, data);\n    DobermanFactory.changeImplementation(newDobermanFactoryAddress, data);\n  }\n\n  function migrateToSeniorPool(DobermanConfig newConfig) internal {\n    IMigrate(config.fiduAddress()).grantRole(MINTER_ROLE, newConfig.seniorPoolAddress());\n    IMigrate(config.poolAddress()).unpause();\n    IMigrate(newConfig.poolAddress()).migrateToSeniorPool();\n  }\n\n  function closeOutMigration(DobermanConfig newConfig) external onlyAdmin {\n    IMigrate fidu = IMigrate(newConfig.fiduAddress());\n    IMigrate creditDesk = IMigrate(newConfig.creditDeskAddress());\n    IMigrate oldPool = IMigrate(newConfig.poolAddress());\n    IMigrate DobermanFactory = IMigrate(newConfig.DobermanFactoryAddress());\n\n    fidu.unpause();\n    fidu.renounceRole(MINTER_ROLE, address(this));\n    fidu.renounceRole(OWNER_ROLE, address(this));\n    fidu.renounceRole(PAUSER_ROLE, address(this));\n\n    creditDesk.renounceRole(OWNER_ROLE, address(this));\n    creditDesk.renounceRole(PAUSER_ROLE, address(this));\n\n    oldPool.renounceRole(OWNER_ROLE, address(this));\n    oldPool.renounceRole(PAUSER_ROLE, address(this));\n\n    DobermanFactory.renounceRole(OWNER_ROLE, address(this));\n    DobermanFactory.renounceRole(PAUSER_ROLE, address(this));\n\n    config.renounceRole(PAUSER_ROLE, address(this));\n    config.renounceRole(OWNER_ROLE, address(this));\n\n    newConfig.renounceRole(OWNER_ROLE, address(this));\n    newConfig.renounceRole(PAUSER_ROLE, address(this));\n    newConfig.renounceRole(GO_LISTER_ROLE, address(this));\n  }\n}\n"
    },
    "contracts/rewards/BackerRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../library/Babylonian.sol\";\n\nimport \"../library/SafeERC20Transfer.sol\";\nimport \"../protocol/core/ConfigHelper.sol\";\nimport \"../protocol/core/BaseUpgradeablePausable.sol\";\nimport \"../interfaces/IPoolTokens.sol\";\nimport \"../interfaces/ITranchedPool.sol\";\nimport \"../interfaces/IBackerRewards.sol\";\n\n// Basically, Every time a interest payment comes back\n// we keep a running total of dollars (totalInterestReceived) until it reaches the maxInterestDollarsEligible limit\n// Every dollar of interest received from 0->maxInterestDollarsEligible\n// has a allocated amount of rewards based on a sqrt function.\n\n// When a interest payment comes in for a given Pool or the pool balance increases\n// we recalculate the pool's accRewardsPerPrincipalDollar\n\n// equation ref `_calculateNewGrossGFIRewardsForInterestAmount()`:\n// (sqrtNewTotalInterest - sqrtOrigTotalInterest) / sqrtMaxInterestDollarsEligible * (totalRewards / totalGFISupply)\n\n// When a PoolToken is minted, we set the mint price to the pool's current accRewardsPerPrincipalDollar\n// Every time a PoolToken withdraws rewards, we determine the allocated rewards,\n// increase that PoolToken's rewardsClaimed, and transfer the owner the gfi\n\ncontract BackerRewards is IBackerRewards, BaseUpgradeablePausable, SafeERC20Transfer {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using SafeMath for uint256;\n\n  struct BackerRewardsInfo {\n    uint256 accRewardsPerPrincipalDollar; // accumulator gfi per interest dollar\n  }\n\n  struct BackerRewardsTokenInfo {\n    uint256 rewardsClaimed; // gfi claimed\n    uint256 accRewardsPerPrincipalDollarAtMint; // Pool's accRewardsPerPrincipalDollar at PoolToken mint()\n  }\n\n  uint256 public totalRewards; // total amount of GFI rewards available, times 1e18\n  uint256 public maxInterestDollarsEligible; // interest $ eligible for gfi rewards, times 1e18\n  uint256 public totalInterestReceived; // counter of total interest repayments, times 1e6\n  uint256 public totalRewardPercentOfTotalGFI; // totalRewards/totalGFISupply, times 1e18\n\n  mapping(uint256 => BackerRewardsTokenInfo) public tokens; // poolTokenId -> BackerRewardsTokenInfo\n\n  mapping(address => BackerRewardsInfo) public pools; // pool.address -> BackerRewardsInfo\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(address owner, DobermanConfig _config) public initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n    __BaseUpgradeablePausable__init(owner);\n    config = _config;\n  }\n\n  /**\n   * @notice Calculates the accRewardsPerPrincipalDollar for a given pool,\n   when a interest payment is received by the protocol\n   * @param _interestPaymentAmount The amount of total dollars the interest payment, expects 10^6 value\n   */\n  function allocateRewards(uint256 _interestPaymentAmount) external override onlyPool {\n    // note: do not use a require statment because that will TranchedPool kill execution\n    if (_interestPaymentAmount > 0) {\n      _allocateRewards(_interestPaymentAmount);\n    }\n  }\n\n  /**\n   * @notice Set the total gfi rewards and the % of total GFI\n   * @param _totalRewards The amount of GFI rewards available, expects 10^18 value\n   */\n  function setTotalRewards(uint256 _totalRewards) public onlyAdmin {\n    totalRewards = _totalRewards;\n    uint256 totalGFISupply = config.getGFI().totalSupply();\n    totalRewardPercentOfTotalGFI = _totalRewards.mul(mantissa()).div(totalGFISupply).mul(100);\n    emit BackerRewardsSetTotalRewards(_msgSender(), _totalRewards, totalRewardPercentOfTotalGFI);\n  }\n\n  /**\n   * @notice Set the total interest received to date.\n   This should only be called once on contract deploy.\n   * @param _totalInterestReceived The amount of interest the protocol has received to date, expects 10^6 value\n   */\n  function setTotalInterestReceived(uint256 _totalInterestReceived) public onlyAdmin {\n    totalInterestReceived = _totalInterestReceived;\n    emit BackerRewardsSetTotalInterestReceived(_msgSender(), _totalInterestReceived);\n  }\n\n  /**\n   * @notice Set the max dollars across the entire protocol that are eligible for GFI rewards\n   * @param _maxInterestDollarsEligible The amount of interest dollars eligible for GFI rewards, expects 10^18 value\n   */\n  function setMaxInterestDollarsEligible(uint256 _maxInterestDollarsEligible) public onlyAdmin {\n    maxInterestDollarsEligible = _maxInterestDollarsEligible;\n    emit BackerRewardsSetMaxInterestDollarsEligible(_msgSender(), _maxInterestDollarsEligible);\n  }\n\n  /**\n   * @notice When a pool token is minted for multiple drawdowns,\n   set accRewardsPerPrincipalDollarAtMint to the current accRewardsPerPrincipalDollar price\n   * @param tokenId Pool token id\n   */\n  function setPoolTokenAccRewardsPerPrincipalDollarAtMint(address poolAddress, uint256 tokenId) external override {\n    require(_msgSender() == config.poolTokensAddress(), \"Invalid sender!\");\n    require(config.getPoolTokens().validPool(poolAddress), \"Invalid pool!\");\n    if (tokens[tokenId].accRewardsPerPrincipalDollarAtMint != 0) {\n      return;\n    }\n    IPoolTokens poolTokens = config.getPoolTokens();\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n    require(poolAddress == tokenInfo.pool, \"PoolAddress must equal PoolToken pool address\");\n\n    tokens[tokenId].accRewardsPerPrincipalDollarAtMint = pools[tokenInfo.pool].accRewardsPerPrincipalDollar;\n  }\n\n  /**\n   * @notice Calculate the gross available gfi rewards for a PoolToken\n   * @param tokenId Pool token id\n   * @return The amount of GFI claimable\n   */\n  function poolTokenClaimableRewards(uint256 tokenId) public view returns (uint256) {\n    IPoolTokens poolTokens = config.getPoolTokens();\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n\n    // Note: If a TranchedPool is oversubscribed, reward allocation's scale down proportionately.\n\n    uint256 diffOfAccRewardsPerPrincipalDollar = pools[tokenInfo.pool].accRewardsPerPrincipalDollar.sub(\n      tokens[tokenId].accRewardsPerPrincipalDollarAtMint\n    );\n    uint256 rewardsClaimed = tokens[tokenId].rewardsClaimed.mul(mantissa());\n\n    /*\n      equation for token claimable rewards:\n        token.principalAmount\n        * (pool.accRewardsPerPrincipalDollar - token.accRewardsPerPrincipalDollarAtMint)\n        - token.rewardsClaimed\n    */\n\n    return\n      usdcToAtomic(tokenInfo.principalAmount).mul(diffOfAccRewardsPerPrincipalDollar).sub(rewardsClaimed).div(\n        mantissa()\n      );\n  }\n\n  /**\n   * @notice PoolToken request to withdraw multiple PoolTokens allocated rewards\n   * @param tokenIds Array of pool token id\n   */\n  function withdrawMultiple(uint256[] calldata tokenIds) public {\n    require(tokenIds.length > 0, \"TokensIds length must not be 0\");\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      withdraw(tokenIds[i]);\n    }\n  }\n\n  /**\n   * @notice PoolToken request to withdraw all allocated rewards\n   * @param tokenId Pool token id\n   */\n  function withdraw(uint256 tokenId) public {\n    uint256 totalClaimableRewards = poolTokenClaimableRewards(tokenId);\n    uint256 poolTokenRewardsClaimed = tokens[tokenId].rewardsClaimed;\n    IPoolTokens poolTokens = config.getPoolTokens();\n    IPoolTokens.TokenInfo memory tokenInfo = poolTokens.getTokenInfo(tokenId);\n\n    address poolAddr = tokenInfo.pool;\n    require(config.getPoolTokens().validPool(poolAddr), \"Invalid pool!\");\n    require(msg.sender == poolTokens.ownerOf(tokenId), \"Must be owner of PoolToken\");\n\n    BaseUpgradeablePausable pool = BaseUpgradeablePausable(poolAddr);\n    require(!pool.paused(), \"Pool withdraw paused\");\n\n    ITranchedPool tranchedPool = ITranchedPool(poolAddr);\n    require(!tranchedPool.creditLine().isLate(), \"Pool is late on payments\");\n\n    tokens[tokenId].rewardsClaimed = poolTokenRewardsClaimed.add(totalClaimableRewards);\n    safeERC20Transfer(config.getGFI(), poolTokens.ownerOf(tokenId), totalClaimableRewards);\n    emit BackerRewardsClaimed(_msgSender(), tokenId, totalClaimableRewards);\n  }\n\n  /* Internal functions  */\n  function _allocateRewards(uint256 _interestPaymentAmount) internal {\n    uint256 _totalInterestReceived = totalInterestReceived;\n    if (usdcToAtomic(_totalInterestReceived) >= maxInterestDollarsEligible) {\n      return;\n    }\n\n    address _poolAddress = _msgSender();\n\n    // Gross GFI Rewards earned for incoming interest dollars\n    uint256 newGrossRewards = _calculateNewGrossGFIRewardsForInterestAmount(_interestPaymentAmount);\n\n    ITranchedPool pool = ITranchedPool(_poolAddress);\n    BackerRewardsInfo storage _poolInfo = pools[_poolAddress];\n\n    uint256 totalJuniorDeposits = pool.totalJuniorDeposits();\n    if (totalJuniorDeposits == 0) {\n      return;\n    }\n\n    // example: (6708203932437400000000 * 10^18) / (100000*10^18)\n    _poolInfo.accRewardsPerPrincipalDollar = _poolInfo.accRewardsPerPrincipalDollar.add(\n      newGrossRewards.mul(mantissa()).div(usdcToAtomic(totalJuniorDeposits))\n    );\n\n    totalInterestReceived = _totalInterestReceived.add(_interestPaymentAmount);\n  }\n\n  /**\n   * @notice Calculate the rewards earned for a given interest payment\n   * @param _interestPaymentAmount interest payment amount times 1e6\n   */\n  function _calculateNewGrossGFIRewardsForInterestAmount(uint256 _interestPaymentAmount)\n    internal\n    view\n    returns (uint256)\n  {\n    uint256 totalGFISupply = config.getGFI().totalSupply();\n\n    // incoming interest payment, times * 1e18 divided by 1e6\n    uint256 interestPaymentAmount = usdcToAtomic(_interestPaymentAmount);\n\n    // all-time interest payments prior to the incoming amount, times 1e18\n    uint256 _previousTotalInterestReceived = usdcToAtomic(totalInterestReceived);\n    uint256 sqrtOrigTotalInterest = Babylonian.sqrt(_previousTotalInterestReceived);\n\n    // sum of new interest payment + previous total interest payments, times 1e18\n    uint256 newTotalInterest = usdcToAtomic(\n      atomicToUSDC(_previousTotalInterestReceived).add(atomicToUSDC(interestPaymentAmount))\n    );\n\n    // interest payment passed the maxInterestDollarsEligible cap, should only partially be rewarded\n    if (newTotalInterest > maxInterestDollarsEligible) {\n      newTotalInterest = maxInterestDollarsEligible;\n    }\n\n    /*\n      equation:\n        (sqrtNewTotalInterest-sqrtOrigTotalInterest)\n        * totalRewardPercentOfTotalGFI\n        / sqrtMaxInterestDollarsEligible\n        / 100\n        * totalGFISupply\n        / 10^18\n\n      example scenario:\n      - new payment = 5000*10^18\n      - original interest received = 0*10^18\n      - total reward percent = 3 * 10^18\n      - max interest dollars = 1 * 10^27 ($1 billion)\n      - totalGfiSupply = 100_000_000 * 10^18\n\n      example math:\n        (70710678118 - 0)\n        * 3000000000000000000\n        / 31622776601683\n        / 100\n        * 100000000000000000000000000\n        / 10^18\n        = 6708203932437400000000 (6,708.2039 GFI)\n    */\n    uint256 sqrtDiff = Babylonian.sqrt(newTotalInterest).sub(sqrtOrigTotalInterest);\n    uint256 sqrtMaxInterestDollarsEligible = Babylonian.sqrt(maxInterestDollarsEligible);\n\n    require(sqrtMaxInterestDollarsEligible > 0, \"maxInterestDollarsEligible must not be zero\");\n\n    uint256 newGrossRewards = sqrtDiff\n      .mul(totalRewardPercentOfTotalGFI)\n      .div(sqrtMaxInterestDollarsEligible)\n      .div(100)\n      .mul(totalGFISupply)\n      .div(mantissa());\n\n    // Extra safety check to make sure the logic is capped at a ceiling of potential rewards\n    // Calculating the gfi/$ for first dollar of interest to the protocol, and multiplying by new interest amount\n    uint256 absoluteMaxGfiCheckPerDollar = Babylonian\n      .sqrt((uint256)(1).mul(mantissa()))\n      .mul(totalRewardPercentOfTotalGFI)\n      .div(sqrtMaxInterestDollarsEligible)\n      .div(100)\n      .mul(totalGFISupply)\n      .div(mantissa());\n    require(\n      newGrossRewards < absoluteMaxGfiCheckPerDollar.mul(newTotalInterest),\n      \"newGrossRewards cannot be greater then the max gfi per dollar\"\n    );\n\n    return newGrossRewards;\n  }\n\n  function mantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(18);\n  }\n\n  function usdcMantissa() internal pure returns (uint256) {\n    return uint256(10)**uint256(6);\n  }\n\n  function usdcToAtomic(uint256 amount) internal pure returns (uint256) {\n    return amount.mul(mantissa()).div(usdcMantissa());\n  }\n\n  function atomicToUSDC(uint256 amount) internal pure returns (uint256) {\n    return amount.div(mantissa().div(usdcMantissa()));\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(_msgSender(), address(config));\n  }\n\n  /* ======== MODIFIERS  ======== */\n\n  modifier onlyPool() {\n    require(config.getPoolTokens().validPool(_msgSender()), \"Invalid pool!\");\n    _;\n  }\n\n  /* ======== EVENTS ======== */\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n  event BackerRewardsClaimed(address indexed owner, uint256 indexed tokenId, uint256 amount);\n  event BackerRewardsSetTotalRewards(address indexed owner, uint256 totalRewards, uint256 totalRewardPercentOfTotalGFI);\n  event BackerRewardsSetTotalInterestReceived(address indexed owner, uint256 totalInterestReceived);\n  event BackerRewardsSetMaxInterestDollarsEligible(address indexed owner, uint256 maxInterestDollarsEligible);\n}\n"
    },
    "contracts/rewards/CommunityRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport \"../external/ERC721PresetMinterPauserAutoId.sol\";\nimport \"../interfaces/IERC20withDec.sol\";\nimport \"../interfaces/ICommunityRewards.sol\";\nimport \"../protocol/core/DobermanConfig.sol\";\nimport \"../protocol/core/ConfigHelper.sol\";\n\nimport \"../library/CommunityRewardsVesting.sol\";\n\ncontract CommunityRewards is ICommunityRewards, ERC721PresetMinterPauserAutoIdUpgradeSafe, ReentrancyGuardUpgradeable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20withDec;\n  using ConfigHelper for DobermanConfig;\n  using Counters for Counters.Counter;\n\n  using CommunityRewardsVesting for CommunityRewardsVesting.Rewards;\n\n  /* ==========     EVENTS      ========== */\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n\n  /* ========== STATE VARIABLES ========== */\n\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  bytes32 public constant DISTRIBUTOR_ROLE = keccak256(\"DISTRIBUTOR_ROLE\");\n\n  DobermanConfig public config;\n\n  /// @notice Total rewards available for granting, denominated in `rewardsToken()`\n  uint256 public rewardsAvailable;\n\n  /// @notice Token launch time in seconds. This is used in vesting.\n  uint256 public tokenLaunchTimeInSeconds;\n\n  /// @dev NFT tokenId => rewards grant\n  mapping(uint256 => CommunityRewardsVesting.Rewards) public grants;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(\n    address owner,\n    DobermanConfig _config,\n    uint256 _tokenLaunchTimeInSeconds\n  ) external initializer {\n    require(owner != address(0) && address(_config) != address(0), \"Owner and config addresses cannot be empty\");\n\n    __Context_init_unchained();\n    __ERC165_init_unchained();\n    __ERC721_init_unchained(\"Doberman V2 Community Rewards Tokens\", \"GFI-V2-CR\");\n    __ERC721Pausable_init_unchained();\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n    _setupRole(DISTRIBUTOR_ROLE, owner);\n\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(DISTRIBUTOR_ROLE, OWNER_ROLE);\n\n    tokenLaunchTimeInSeconds = _tokenLaunchTimeInSeconds;\n\n    config = _config;\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @notice The token being disbursed as rewards\n  function rewardsToken() public view override returns (IERC20withDec) {\n    return config.getGFI();\n  }\n\n  /// @notice Returns the rewards claimable by a given grant token, taking into\n  ///   account vesting schedule.\n  /// @return rewards Amount of rewards denominated in `rewardsToken()`\n  function claimableRewards(uint256 tokenId) public view override returns (uint256 rewards) {\n    return grants[tokenId].claimable();\n  }\n\n  /// @notice Returns the rewards that will have vested for some grant with the given params.\n  /// @return rewards Amount of rewards denominated in `rewardsToken()`\n  function totalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 granted,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    uint256 revokedAt,\n    uint256 time\n  ) external pure override returns (uint256 rewards) {\n    return CommunityRewardsVesting.getTotalVestedAt(start, end, granted, cliffLength, vestingInterval, revokedAt, time);\n  }\n\n  /* ========== MUTATIVE, ADMIN-ONLY FUNCTIONS ========== */\n\n  /// @notice Transfer rewards from msg.sender, to be used for reward distribution\n  function loadRewards(uint256 rewards) external override onlyAdmin {\n    require(rewards > 0, \"Cannot load 0 rewards\");\n\n    rewardsAvailable = rewardsAvailable.add(rewards);\n\n    rewardsToken().safeTransferFrom(msg.sender, address(this), rewards);\n\n    emit RewardAdded(rewards);\n  }\n\n  /// @notice Revokes rewards that have not yet vested, for a grant. The unvested rewards are\n  /// now considered available for allocation in another grant.\n  /// @param tokenId The tokenId corresponding to the grant whose unvested rewards to revoke.\n  function revokeGrant(uint256 tokenId) external override whenNotPaused onlyAdmin {\n    CommunityRewardsVesting.Rewards storage grant_ = grants[tokenId];\n\n    require(grant_.totalGranted > 0, \"Grant not defined for token id\");\n    require(grant_.revokedAt == 0, \"Grant has already been revoked\");\n\n    uint256 totalUnvested = grant_.totalUnvestedAt(block.timestamp);\n    require(totalUnvested > 0, \"Grant has fully vested\");\n\n    rewardsAvailable = rewardsAvailable.add(totalUnvested);\n\n    grant_.revokedAt = block.timestamp;\n\n    emit GrantRevoked(tokenId, totalUnvested);\n  }\n\n  function setTokenLaunchTimeInSeconds(uint256 _tokenLaunchTimeInSeconds) external onlyAdmin {\n    tokenLaunchTimeInSeconds = _tokenLaunchTimeInSeconds;\n  }\n\n  /// @notice updates current config\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(_msgSender(), address(config));\n  }\n\n  /* ========== MUTATIVE, NON-ADMIN-ONLY FUNCTIONS ========== */\n\n  /// @notice Grant rewards to a recipient. The recipient address receives an\n  ///   an NFT representing their rewards grant. They can present the NFT to `getReward()`\n  ///   to claim their rewards. Rewards vest over a schedule.\n  /// @param recipient The recipient of the grant.\n  /// @param amount The amount of `rewardsToken()` to grant.\n  /// @param vestingLength The duration (in seconds) over which the grant vests.\n  /// @param cliffLength The duration (in seconds) from the start of the grant, before which has elapsed\n  /// the vested amount remains 0.\n  /// @param vestingInterval The interval (in seconds) at which vesting occurs. Must be a factor of `vestingLength`.\n  function grant(\n    address recipient,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  ) external override nonReentrant whenNotPaused onlyDistributor returns (uint256 tokenId) {\n    return _grant(recipient, amount, vestingLength, cliffLength, vestingInterval);\n  }\n\n  function _grant(\n    address recipient,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval\n  ) internal returns (uint256 tokenId) {\n    require(amount > 0, \"Cannot grant 0 amount\");\n    require(cliffLength <= vestingLength, \"Cliff length cannot exceed vesting length\");\n    require(vestingLength.mod(vestingInterval) == 0, \"Vesting interval must be a factor of vesting length\");\n    require(amount <= rewardsAvailable, \"Cannot grant amount due to insufficient funds\");\n\n    rewardsAvailable = rewardsAvailable.sub(amount);\n\n    _tokenIdTracker.increment();\n    tokenId = _tokenIdTracker.current();\n\n    grants[tokenId] = CommunityRewardsVesting.Rewards({\n      totalGranted: amount,\n      totalClaimed: 0,\n      startTime: tokenLaunchTimeInSeconds,\n      endTime: tokenLaunchTimeInSeconds.add(vestingLength),\n      cliffLength: cliffLength,\n      vestingInterval: vestingInterval,\n      revokedAt: 0\n    });\n\n    _mint(recipient, tokenId);\n\n    emit Granted(recipient, tokenId, amount, vestingLength, cliffLength, vestingInterval);\n\n    return tokenId;\n  }\n\n  /// @notice Claim rewards for a given grant\n  /// @param tokenId A grant token ID\n  function getReward(uint256 tokenId) external override nonReentrant whenNotPaused {\n    require(ownerOf(tokenId) == msg.sender, \"access denied\");\n    uint256 reward = claimableRewards(tokenId);\n    if (reward > 0) {\n      grants[tokenId].claim(reward);\n      rewardsToken().safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, tokenId, reward);\n    }\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n\n  function isDistributor() public view returns (bool) {\n    return hasRole(DISTRIBUTOR_ROLE, _msgSender());\n  }\n\n  modifier onlyDistributor() {\n    require(isDistributor(), \"Must have distributor role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/rewards/MerkleDirectDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/MerkleDistributor.sol.\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../interfaces/IERC20withDec.sol\";\nimport \"../interfaces/IMerkleDirectDistributor.sol\";\nimport \"../protocol/core/BaseUpgradeablePausable.sol\";\n\ncontract MerkleDirectDistributor is IMerkleDirectDistributor, BaseUpgradeablePausable {\n  using SafeERC20 for IERC20withDec;\n\n  address public override gfi;\n  bytes32 public override merkleRoot;\n\n  // @dev This is a packed array of booleans.\n  mapping(uint256 => uint256) private acceptedBitMap;\n\n  function initialize(\n    address owner,\n    address _gfi,\n    bytes32 _merkleRoot\n  ) public initializer {\n    require(owner != address(0), \"Owner address cannot be empty\");\n    require(_gfi != address(0), \"GFI address cannot be empty\");\n    require(_merkleRoot != 0, \"Invalid Merkle root\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    gfi = _gfi;\n    merkleRoot = _merkleRoot;\n  }\n\n  function isGrantAccepted(uint256 index) public view override returns (bool) {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    uint256 acceptedWord = acceptedBitMap[acceptedWordIndex];\n    uint256 mask = (1 << acceptedBitIndex);\n    return acceptedWord & mask == mask;\n  }\n\n  function _setGrantAccepted(uint256 index) private {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    acceptedBitMap[acceptedWordIndex] = acceptedBitMap[acceptedWordIndex] | (1 << acceptedBitIndex);\n  }\n\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    bytes32[] calldata merkleProof\n  ) external override whenNotPaused {\n    require(!isGrantAccepted(index), \"Grant already accepted\");\n\n    // Verify the merkle proof.\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount));\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \"Invalid proof\");\n\n    // Mark it accepted and perform the granting.\n    _setGrantAccepted(index);\n    IERC20withDec(gfi).safeTransfer(msg.sender, amount);\n\n    emit GrantAccepted(index, msg.sender, amount);\n  }\n}\n"
    },
    "contracts/rewards/MerkleDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable-next-line max-line-length\n// Adapted from https://github.com/Uniswap/merkle-distributor/blob/c3255bfa2b684594ecd562cacd7664b0f18330bf/contracts/MerkleDistributor.sol.\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\nimport \"../interfaces/ICommunityRewards.sol\";\nimport \"../interfaces/IMerkleDistributor.sol\";\n\ncontract MerkleDistributor is IMerkleDistributor {\n  address public immutable override communityRewards;\n  bytes32 public immutable override merkleRoot;\n\n  // @dev This is a packed array of booleans.\n  mapping(uint256 => uint256) private acceptedBitMap;\n\n  constructor(address communityRewards_, bytes32 merkleRoot_) {\n    require(communityRewards_ != address(0), \"Cannot use the null address\");\n    require(merkleRoot_ != 0, \"Invalid merkle root provided\");\n    communityRewards = communityRewards_;\n    merkleRoot = merkleRoot_;\n  }\n\n  function isGrantAccepted(uint256 index) public view override returns (bool) {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    uint256 acceptedWord = acceptedBitMap[acceptedWordIndex];\n    uint256 mask = (1 << acceptedBitIndex);\n    return acceptedWord & mask == mask;\n  }\n\n  function _setGrantAccepted(uint256 index) private {\n    uint256 acceptedWordIndex = index / 256;\n    uint256 acceptedBitIndex = index % 256;\n    acceptedBitMap[acceptedWordIndex] = acceptedBitMap[acceptedWordIndex] | (1 << acceptedBitIndex);\n  }\n\n  function acceptGrant(\n    uint256 index,\n    uint256 amount,\n    uint256 vestingLength,\n    uint256 cliffLength,\n    uint256 vestingInterval,\n    bytes32[] calldata merkleProof\n  ) external override {\n    require(!isGrantAccepted(index), \"Grant already accepted\");\n\n    // Verify the merkle proof.\n    //\n    /// @dev Per the Warning in\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#non-standard-packed-mode,\n    /// it is important that no more than one of the arguments to `abi.encodePacked()` here be a\n    /// dynamic type (see definition in\n    /// https://github.com/ethereum/solidity/blob/v0.6.12/docs/abi-spec.rst#formal-specification-of-the-encoding).\n    bytes32 node = keccak256(abi.encodePacked(index, msg.sender, amount, vestingLength, cliffLength, vestingInterval));\n    require(MerkleProof.verify(merkleProof, merkleRoot, node), \"Invalid proof\");\n\n    // Mark it accepted and perform the granting.\n    _setGrantAccepted(index);\n    uint256 tokenId = ICommunityRewards(communityRewards).grant(\n      msg.sender,\n      amount,\n      vestingLength,\n      cliffLength,\n      vestingInterval\n    );\n\n    emit GrantAccepted(tokenId, index, msg.sender, amount, vestingLength, cliffLength, vestingInterval);\n  }\n}\n"
    },
    "contracts/rewards/StakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport \"../external/ERC721PresetMinterPauserAutoId.sol\";\nimport \"../interfaces/IERC20withDec.sol\";\nimport \"../interfaces/ISeniorPool.sol\";\nimport \"../protocol/core/DobermanConfig.sol\";\nimport \"../protocol/core/ConfigHelper.sol\";\nimport \"../protocol/core/BaseUpgradeablePausable.sol\";\n\nimport \"../library/StakingRewardsVesting.sol\";\n\ncontract StakingRewards is ERC721PresetMinterPauserAutoIdUpgradeSafe, ReentrancyGuardUpgradeable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20withDec;\n  using ConfigHelper for DobermanConfig;\n  using Counters for Counters.Counter;\n\n  using StakingRewardsVesting for StakingRewardsVesting.Rewards;\n\n  enum LockupPeriod {\n    SixMonths,\n    TwelveMonths,\n    TwentyFourMonths\n  }\n\n  struct StakedPosition {\n    // @notice Staked amount denominated in `stakingToken().decimals()`\n    uint256 amount;\n    // @notice Struct describing rewards owed with vesting\n    StakingRewardsVesting.Rewards rewards;\n    // @notice Multiplier applied to staked amount when locking up position\n    uint256 leverageMultiplier;\n    // @notice Time in seconds after which position can be unstaked\n    uint256 lockedUntil;\n  }\n\n  /* ========== EVENTS =================== */\n  event RewardsParametersUpdated(\n    address indexed who,\n    uint256 targetCapacity,\n    uint256 minRate,\n    uint256 maxRate,\n    uint256 minRateAtPercent,\n    uint256 maxRateAtPercent\n  );\n  event TargetCapacityUpdated(address indexed who, uint256 targetCapacity);\n  event VestingScheduleUpdated(address indexed who, uint256 vestingLength);\n  event MinRateUpdated(address indexed who, uint256 minRate);\n  event MaxRateUpdated(address indexed who, uint256 maxRate);\n  event MinRateAtPercentUpdated(address indexed who, uint256 minRateAtPercent);\n  event MaxRateAtPercentUpdated(address indexed who, uint256 maxRateAtPercent);\n  event LeverageMultiplierUpdated(address indexed who, LockupPeriod lockupPeriod, uint256 leverageMultiplier);\n\n  /* ========== STATE VARIABLES ========== */\n\n  uint256 private constant MULTIPLIER_DECIMALS = 1e18;\n\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n\n  DobermanConfig public config;\n\n  /// @notice The block timestamp when rewards were last checkpointed\n  uint256 public lastUpdateTime;\n\n  /// @notice Accumulated rewards per token at the last checkpoint\n  uint256 public accumulatedRewardsPerToken;\n\n  /// @notice Total rewards available for disbursement at the last checkpoint, denominated in `rewardsToken()`\n  uint256 public rewardsAvailable;\n\n  /// @notice StakedPosition tokenId => accumulatedRewardsPerToken at the position's last checkpoint\n  mapping(uint256 => uint256) public positionToAccumulatedRewardsPerToken;\n\n  /// @notice Desired supply of staked tokens. The reward rate adjusts in a range\n  ///   around this value to incentivize staking or unstaking to maintain it.\n  uint256 public targetCapacity;\n\n  /// @notice The minimum total disbursed rewards per second, denominated in `rewardsToken()`\n  uint256 public minRate;\n\n  /// @notice The maximum total disbursed rewards per second, denominated in `rewardsToken()`\n  uint256 public maxRate;\n\n  /// @notice The percent of `targetCapacity` at which the reward rate reaches `maxRate`.\n  ///  Represented with `MULTIPLIER_DECIMALS`.\n  uint256 public maxRateAtPercent;\n\n  /// @notice The percent of `targetCapacity` at which the reward rate reaches `minRate`.\n  ///  Represented with `MULTIPLIER_DECIMALS`.\n  uint256 public minRateAtPercent;\n\n  /// @notice The duration in seconds over which rewards vest\n  uint256 public vestingLength;\n\n  /// @dev Supply of staked tokens, excluding leverage due to lock-up boosting, denominated in\n  ///   `stakingToken().decimals()`\n  uint256 public totalStakedSupply;\n\n  /// @dev Supply of staked tokens, including leverage due to lock-up boosting, denominated in\n  ///   `stakingToken().decimals()`\n  uint256 private totalLeveragedStakedSupply;\n\n  /// @dev A mapping from lockup periods to leverage multipliers used to boost rewards.\n  ///   See `stakeWithLockup`.\n  mapping(LockupPeriod => uint256) private leverageMultipliers;\n\n  /// @dev NFT tokenId => staked position\n  mapping(uint256 => StakedPosition) public positions;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __initialize__(address owner, DobermanConfig _config) external initializer {\n    __Context_init_unchained();\n    __ERC165_init_unchained();\n    __ERC721_init_unchained(\"Doberman V2 LP Staking Tokens\", \"GFI-V2-LPS\");\n    __ERC721Pausable_init_unchained();\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n\n    config = _config;\n\n    vestingLength = 365 days;\n\n    // Set defaults for leverage multipliers (no boosting)\n    leverageMultipliers[LockupPeriod.SixMonths] = MULTIPLIER_DECIMALS; // 1x\n    leverageMultipliers[LockupPeriod.TwelveMonths] = MULTIPLIER_DECIMALS; // 1x\n    leverageMultipliers[LockupPeriod.TwentyFourMonths] = MULTIPLIER_DECIMALS; // 1x\n  }\n\n  /* ========== VIEWS ========== */\n\n  /// @notice Returns the staked balance of a given position token\n  /// @param tokenId A staking position token ID\n  /// @return Amount of staked tokens denominated in `stakingToken().decimals()`\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256) {\n    return positions[tokenId].amount;\n  }\n\n  /// @notice The address of the token being disbursed as rewards\n  function rewardsToken() public view returns (IERC20withDec) {\n    return config.getGFI();\n  }\n\n  /// @notice The address of the token that can be staked\n  function stakingToken() public view returns (IERC20withDec) {\n    return config.getFidu();\n  }\n\n  /// @notice The additional rewards earned per token, between the provided time and the last\n  ///   time rewards were checkpointed, given the prevailing `rewardRate()`. This amount is limited\n  ///   by the amount of rewards that are available for distribution; if there aren't enough\n  ///   rewards in the balance of this contract, then we shouldn't be giving them out.\n  /// @return Amount of rewards denominated in `rewardsToken().decimals()`.\n  function additionalRewardsPerTokenSinceLastUpdate(uint256 time) internal view returns (uint256) {\n    require(time >= lastUpdateTime, \"Invalid end time for range\");\n\n    if (totalLeveragedStakedSupply == 0) {\n      return 0;\n    }\n    uint256 rewardsSinceLastUpdate = Math.min(time.sub(lastUpdateTime).mul(rewardRate()), rewardsAvailable);\n    uint256 additionalRewardsPerToken = rewardsSinceLastUpdate.mul(stakingTokenMantissa()).div(\n      totalLeveragedStakedSupply\n    );\n    // Prevent perverse, infinite-mint scenario where totalLeveragedStakedSupply is a fraction of a token.\n    // Since it's used as the denominator, this could make additionalRewardPerToken larger than the total number\n    // of tokens that should have been disbursed in the elapsed time. The attacker would need to find\n    // a way to reduce totalLeveragedStakedSupply while maintaining a staked position of >= 1.\n    // See: https://twitter.com/Mudit__Gupta/status/1409463917290557440\n    if (additionalRewardsPerToken > rewardsSinceLastUpdate) {\n      return 0;\n    }\n    return additionalRewardsPerToken;\n  }\n\n  /// @notice Returns accumulated rewards per token up to the current block timestamp\n  /// @return Amount of rewards denominated in `rewardsToken().decimals()`\n  function rewardPerToken() public view returns (uint256) {\n    uint256 additionalRewardsPerToken = additionalRewardsPerTokenSinceLastUpdate(block.timestamp);\n    return accumulatedRewardsPerToken.add(additionalRewardsPerToken);\n  }\n\n  /// @notice Returns rewards earned by a given position token from its last checkpoint up to the\n  ///   current block timestamp.\n  /// @param tokenId A staking position token ID\n  /// @return Amount of rewards denominated in `rewardsToken().decimals()`\n  function earnedSinceLastCheckpoint(uint256 tokenId) public view returns (uint256) {\n    StakedPosition storage position = positions[tokenId];\n    uint256 leveredAmount = positionToLeveredAmount(position);\n    return\n      leveredAmount.mul(rewardPerToken().sub(positionToAccumulatedRewardsPerToken[tokenId])).div(\n        stakingTokenMantissa()\n      );\n  }\n\n  /// @notice Returns the rewards claimable by a given position token at the most recent checkpoint, taking into\n  ///   account vesting schedule.\n  /// @return rewards Amount of rewards denominated in `rewardsToken()`\n  function claimableRewards(uint256 tokenId) public view returns (uint256 rewards) {\n    return positions[tokenId].rewards.claimable();\n  }\n\n  /// @notice Returns the rewards that will have vested for some position with the given params.\n  /// @return rewards Amount of rewards denominated in `rewardsToken()`\n  function totalVestedAt(\n    uint256 start,\n    uint256 end,\n    uint256 time,\n    uint256 grantedAmount\n  ) external pure returns (uint256 rewards) {\n    return StakingRewardsVesting.totalVestedAt(start, end, time, grantedAmount);\n  }\n\n  /// @notice Number of rewards, in `rewardsToken().decimals()`, to disburse each second\n  function rewardRate() internal view returns (uint256) {\n    // The reward rate can be thought of as a piece-wise function:\n    //\n    //   let intervalStart = (maxRateAtPercent * targetCapacity),\n    //       intervalEnd = (minRateAtPercent * targetCapacity),\n    //       x = totalStakedSupply\n    //   in\n    //     if x < intervalStart\n    //       y = maxRate\n    //     if x > intervalEnd\n    //       y = minRate\n    //     else\n    //       y = maxRate - (maxRate - minRate) * (x - intervalStart) / (intervalEnd - intervalStart)\n    //\n    // See an example here:\n    // solhint-disable-next-line max-line-length\n    // https://www.wolframalpha.com/input/?i=Piecewise%5B%7B%7B1000%2C+x+%3C+50%7D%2C+%7B100%2C+x+%3E+300%7D%2C+%7B1000+-+%281000+-+100%29+*+%28x+-+50%29+%2F+%28300+-+50%29+%2C+50+%3C+x+%3C+300%7D%7D%5D\n    //\n    // In that example:\n    //   maxRateAtPercent = 0.5, minRateAtPercent = 3, targetCapacity = 100, maxRate = 1000, minRate = 100\n    uint256 intervalStart = targetCapacity.mul(maxRateAtPercent).div(MULTIPLIER_DECIMALS);\n    uint256 intervalEnd = targetCapacity.mul(minRateAtPercent).div(MULTIPLIER_DECIMALS);\n    uint256 x = totalStakedSupply;\n\n    // Subsequent computation would overflow\n    if (intervalEnd <= intervalStart) {\n      return 0;\n    }\n\n    if (x < intervalStart) {\n      return maxRate;\n    }\n\n    if (x > intervalEnd) {\n      return minRate;\n    }\n\n    return maxRate.sub(maxRate.sub(minRate).mul(x.sub(intervalStart)).div(intervalEnd.sub(intervalStart)));\n  }\n\n  function positionToLeveredAmount(StakedPosition storage position) internal view returns (uint256) {\n    return toLeveredAmount(position.amount, position.leverageMultiplier);\n  }\n\n  function toLeveredAmount(uint256 amount, uint256 leverageMultiplier) internal pure returns (uint256) {\n    return amount.mul(leverageMultiplier).div(MULTIPLIER_DECIMALS);\n  }\n\n  function stakingTokenMantissa() internal view returns (uint256) {\n    return uint256(10)**stakingToken().decimals();\n  }\n\n  /// @notice The amount of rewards currently being earned per token per second. This amount takes into\n  ///   account how many rewards are actually available for disbursal -- unlike `rewardRate()` which does not.\n  ///   This function is intended for public consumption, to know the rate at which rewards are being\n  ///   earned, and not as an input to the mutative calculations in this contract.\n  /// @return Amount of rewards denominated in `rewardsToken().decimals()`.\n  function currentEarnRatePerToken() public view returns (uint256) {\n    uint256 time = block.timestamp == lastUpdateTime ? block.timestamp + 1 : block.timestamp;\n    uint256 elapsed = time.sub(lastUpdateTime);\n    return additionalRewardsPerTokenSinceLastUpdate(time).div(elapsed);\n  }\n\n  /// @notice The amount of rewards currently being earned per second, for a given position. This function\n  ///   is intended for public consumption, to know the rate at which rewards are being earned\n  ///   for a given position, and not as an input to the mutative calculations in this contract.\n  /// @return Amount of rewards denominated in `rewardsToken().decimals()`.\n  function positionCurrentEarnRate(uint256 tokenId) external view returns (uint256) {\n    StakedPosition storage position = positions[tokenId];\n    uint256 leveredAmount = positionToLeveredAmount(position);\n    return currentEarnRatePerToken().mul(leveredAmount).div(stakingTokenMantissa());\n  }\n\n  /* ========== MUTATIVE FUNCTIONS ========== */\n\n  /// @notice Stake `stakingToken()` to earn rewards. When you call this function, you'll receive an\n  ///   an NFT representing your staked position. You can present your NFT to `getReward` or `unstake`\n  ///   to claim rewards or unstake your tokens respectively. Rewards vest over a schedule.\n  /// @dev This function checkpoints rewards.\n  /// @param amount The amount of `stakingToken()` to stake\n  function stake(uint256 amount) external nonReentrant whenNotPaused updateReward(0) {\n    _stakeWithLockup(msg.sender, msg.sender, amount, 0, MULTIPLIER_DECIMALS);\n  }\n\n  /// @notice Stake `stakingToken()` and lock your position for a period of time to boost your rewards.\n  ///   When you call this function, you'll receive an an NFT representing your staked position.\n  ///   You can present your NFT to `getReward` or `unstake` to claim rewards or unstake your tokens\n  ///   respectively. Rewards vest over a schedule.\n  ///\n  ///   A locked position's rewards are boosted using a multiplier on the staked balance. For example,\n  ///   if I lock 100 tokens for a 2x multiplier, my rewards will be calculated as if I staked 200 tokens.\n  ///   This mechanism is similar to curve.fi's CRV-boosting vote-locking. Locked positions cannot be\n  ///   unstaked until after the position's lockedUntil timestamp.\n  /// @dev This function checkpoints rewards.\n  /// @param amount The amount of `stakingToken()` to stake\n  /// @param lockupPeriod The period over which to lock staked tokens\n  function stakeWithLockup(uint256 amount, LockupPeriod lockupPeriod)\n    external\n    nonReentrant\n    whenNotPaused\n    updateReward(0)\n  {\n    uint256 lockDuration = lockupPeriodToDuration(lockupPeriod);\n    uint256 leverageMultiplier = getLeverageMultiplier(lockupPeriod);\n    uint256 lockedUntil = block.timestamp.add(lockDuration);\n    _stakeWithLockup(msg.sender, msg.sender, amount, lockedUntil, leverageMultiplier);\n  }\n\n  /// @notice Deposit to SeniorPool and stake your shares in the same transaction.\n  /// @param usdcAmount The amount of USDC to deposit into the senior pool. All shares from deposit\n  ///   will be staked.\n  function depositAndStake(uint256 usdcAmount) public nonReentrant whenNotPaused updateReward(0) {\n    uint256 fiduAmount = depositToSeniorPool(usdcAmount);\n    uint256 lockedUntil = 0;\n    uint256 tokenId = _stakeWithLockup(address(this), msg.sender, fiduAmount, lockedUntil, MULTIPLIER_DECIMALS);\n    emit DepositedAndStaked(msg.sender, usdcAmount, tokenId, fiduAmount, lockedUntil, MULTIPLIER_DECIMALS);\n  }\n\n  function depositToSeniorPool(uint256 usdcAmount) internal returns (uint256 fiduAmount) {\n    require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n    IERC20withDec usdc = config.getUSDC();\n    usdc.safeTransferFrom(msg.sender, address(this), usdcAmount);\n\n    ISeniorPool seniorPool = config.getSeniorPool();\n    usdc.safeIncreaseAllowance(address(seniorPool), usdcAmount);\n    return seniorPool.deposit(usdcAmount);\n  }\n\n  /// @notice Identical to `depositAndStake`, except it allows for a signature to be passed that permits\n  ///   this contract to move funds on behalf of the user.\n  /// @param usdcAmount The amount of USDC to deposit\n  /// @param v secp256k1 signature component\n  /// @param r secp256k1 signature component\n  /// @param s secp256k1 signature component\n  function depositWithPermitAndStake(\n    uint256 usdcAmount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), usdcAmount, deadline, v, r, s);\n    depositAndStake(usdcAmount);\n  }\n\n  /// @notice Deposit to the `SeniorPool` and stake your shares with a lock-up in the same transaction.\n  /// @param usdcAmount The amount of USDC to deposit into the senior pool. All shares from deposit\n  ///   will be staked.\n  /// @param lockupPeriod The period over which to lock staked tokens\n  function depositAndStakeWithLockup(uint256 usdcAmount, LockupPeriod lockupPeriod)\n    public\n    nonReentrant\n    whenNotPaused\n    updateReward(0)\n  {\n    uint256 fiduAmount = depositToSeniorPool(usdcAmount);\n    uint256 lockDuration = lockupPeriodToDuration(lockupPeriod);\n    uint256 leverageMultiplier = getLeverageMultiplier(lockupPeriod);\n    uint256 lockedUntil = block.timestamp.add(lockDuration);\n    uint256 tokenId = _stakeWithLockup(address(this), msg.sender, fiduAmount, lockedUntil, leverageMultiplier);\n    emit DepositedAndStaked(msg.sender, usdcAmount, tokenId, fiduAmount, lockedUntil, leverageMultiplier);\n  }\n\n  function lockupPeriodToDuration(LockupPeriod lockupPeriod) internal pure returns (uint256 lockDuration) {\n    if (lockupPeriod == LockupPeriod.SixMonths) {\n      return 365 days / 2;\n    } else if (lockupPeriod == LockupPeriod.TwelveMonths) {\n      return 365 days;\n    } else if (lockupPeriod == LockupPeriod.TwentyFourMonths) {\n      return 365 days * 2;\n    } else {\n      revert(\"unsupported LockupPeriod\");\n    }\n  }\n\n  /// @notice Get the leverage multiplier used to boost rewards for a given lockup period.\n  ///   See `stakeWithLockup`. The leverage multiplier is denominated in `MULTIPLIER_DECIMALS`.\n  function getLeverageMultiplier(LockupPeriod lockupPeriod) public view returns (uint256) {\n    uint256 leverageMultiplier = leverageMultipliers[lockupPeriod];\n    require(leverageMultiplier > 0, \"unsupported LockupPeriod\");\n    return leverageMultiplier;\n  }\n\n  /// @notice Identical to `depositAndStakeWithLockup`, except it allows for a signature to be passed that permits\n  ///   this contract to move funds on behalf of the user.\n  /// @param usdcAmount The amount of USDC to deposit\n  /// @param lockupPeriod The period over which to lock staked tokens\n  /// @param v secp256k1 signature component\n  /// @param r secp256k1 signature component\n  /// @param s secp256k1 signature component\n  function depositWithPermitAndStakeWithLockup(\n    uint256 usdcAmount,\n    LockupPeriod lockupPeriod,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), usdcAmount, deadline, v, r, s);\n    depositAndStakeWithLockup(usdcAmount, lockupPeriod);\n  }\n\n  function _stakeWithLockup(\n    address staker,\n    address nftRecipient,\n    uint256 amount,\n    uint256 lockedUntil,\n    uint256 leverageMultiplier\n  ) internal returns (uint256 tokenId) {\n    require(amount > 0, \"Cannot stake 0\");\n\n    _tokenIdTracker.increment();\n    tokenId = _tokenIdTracker.current();\n\n    // Ensure we snapshot accumulatedRewardsPerToken for tokenId after it is available\n    // We do this before setting the position, because we don't want `earned` to (incorrectly) account for\n    // position.amount yet. This is equivalent to using the updateReward(msg.sender) modifier in the original\n    // synthetix contract, where the modifier is called before any staking balance for that address is recorded\n    _updateReward(tokenId);\n\n    positions[tokenId] = StakedPosition({\n      amount: amount,\n      rewards: StakingRewardsVesting.Rewards({\n        totalUnvested: 0,\n        totalVested: 0,\n        totalPreviouslyVested: 0,\n        totalClaimed: 0,\n        startTime: block.timestamp,\n        endTime: block.timestamp.add(vestingLength)\n      }),\n      leverageMultiplier: leverageMultiplier,\n      lockedUntil: lockedUntil\n    });\n    _mint(nftRecipient, tokenId);\n\n    uint256 leveredAmount = positionToLeveredAmount(positions[tokenId]);\n    totalLeveragedStakedSupply = totalLeveragedStakedSupply.add(leveredAmount);\n    totalStakedSupply = totalStakedSupply.add(amount);\n\n    // Staker is address(this) when using depositAndStake or other convenience functions\n    if (staker != address(this)) {\n      stakingToken().safeTransferFrom(staker, address(this), amount);\n    }\n\n    emit Staked(nftRecipient, tokenId, amount, lockedUntil, leverageMultiplier);\n\n    return tokenId;\n  }\n\n  /// @notice Unstake an amount of `stakingToken()` associated with a given position and transfer to msg.sender.\n  ///   Unvested rewards will be forfeited, but remaining staked amount will continue to accrue rewards.\n  ///   Positions that are still locked cannot be unstaked until the position's lockedUntil time has passed.\n  /// @dev This function checkpoints rewards\n  /// @param tokenId A staking position token ID\n  /// @param amount Amount of `stakingToken()` to be unstaked from the position\n  function unstake(uint256 tokenId, uint256 amount) public nonReentrant whenNotPaused updateReward(tokenId) {\n    _unstake(tokenId, amount);\n    stakingToken().safeTransfer(msg.sender, amount);\n  }\n\n  function unstakeAndWithdraw(uint256 tokenId, uint256 usdcAmount) public nonReentrant whenNotPaused {\n    (uint256 usdcReceivedAmount, uint256 fiduAmount) = _unstakeAndWithdraw(tokenId, usdcAmount);\n\n    emit UnstakedAndWithdrew(msg.sender, usdcReceivedAmount, tokenId, fiduAmount);\n  }\n\n  function _unstakeAndWithdraw(uint256 tokenId, uint256 usdcAmount)\n    internal\n    updateReward(tokenId)\n    returns (uint256 usdcAmountReceived, uint256 fiduUsed)\n  {\n    require(config.getGo().goSeniorPool(msg.sender), \"This address has not been go-listed\");\n    ISeniorPool seniorPool = config.getSeniorPool();\n    IFidu fidu = config.getFidu();\n\n    uint256 fiduBalanceBefore = fidu.balanceOf(address(this));\n\n    usdcAmountReceived = seniorPool.withdraw(usdcAmount);\n\n    fiduUsed = fiduBalanceBefore.sub(fidu.balanceOf(address(this)));\n\n    _unstake(tokenId, fiduUsed);\n    config.getUSDC().safeTransfer(msg.sender, usdcAmountReceived);\n\n    return (usdcAmountReceived, fiduUsed);\n  }\n\n  function unstakeAndWithdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata usdcAmounts)\n    public\n    nonReentrant\n    whenNotPaused\n  {\n    require(tokenIds.length == usdcAmounts.length, \"tokenIds and usdcAmounts must be the same length\");\n\n    uint256 usdcReceivedAmountTotal = 0;\n    uint256[] memory fiduAmounts = new uint256[](usdcAmounts.length);\n    for (uint256 i = 0; i < usdcAmounts.length; i++) {\n      (uint256 usdcReceivedAmount, uint256 fiduAmount) = _unstakeAndWithdraw(tokenIds[i], usdcAmounts[i]);\n\n      usdcReceivedAmountTotal = usdcReceivedAmountTotal.add(usdcReceivedAmount);\n      fiduAmounts[i] = fiduAmount;\n    }\n\n    emit UnstakedAndWithdrewMultiple(msg.sender, usdcReceivedAmountTotal, tokenIds, fiduAmounts);\n  }\n\n  function unstakeAndWithdrawInFidu(uint256 tokenId, uint256 fiduAmount) public nonReentrant whenNotPaused {\n    uint256 usdcReceivedAmount = _unstakeAndWithdrawInFidu(tokenId, fiduAmount);\n\n    emit UnstakedAndWithdrew(msg.sender, usdcReceivedAmount, tokenId, fiduAmount);\n  }\n\n  function _unstakeAndWithdrawInFidu(uint256 tokenId, uint256 fiduAmount)\n    internal\n    updateReward(tokenId)\n    returns (uint256 usdcReceivedAmount)\n  {\n    usdcReceivedAmount = config.getSeniorPool().withdrawInFidu(fiduAmount);\n    _unstake(tokenId, fiduAmount);\n    config.getUSDC().safeTransfer(msg.sender, usdcReceivedAmount);\n    return usdcReceivedAmount;\n  }\n\n  function unstakeAndWithdrawMultipleInFidu(uint256[] calldata tokenIds, uint256[] calldata fiduAmounts)\n    public\n    nonReentrant\n    whenNotPaused\n  {\n    require(tokenIds.length == fiduAmounts.length, \"tokenIds and usdcAmounts must be the same length\");\n\n    uint256 usdcReceivedAmountTotal = 0;\n    for (uint256 i = 0; i < fiduAmounts.length; i++) {\n      uint256 usdcReceivedAmount = _unstakeAndWithdrawInFidu(tokenIds[i], fiduAmounts[i]);\n\n      usdcReceivedAmountTotal = usdcReceivedAmountTotal.add(usdcReceivedAmount);\n    }\n\n    emit UnstakedAndWithdrewMultiple(msg.sender, usdcReceivedAmountTotal, tokenIds, fiduAmounts);\n  }\n\n  function _unstake(uint256 tokenId, uint256 amount) internal {\n    require(ownerOf(tokenId) == msg.sender, \"access denied\");\n    require(amount > 0, \"Cannot unstake 0\");\n\n    StakedPosition storage position = positions[tokenId];\n    uint256 prevAmount = position.amount;\n    require(amount <= prevAmount, \"cannot unstake more than staked balance\");\n\n    require(block.timestamp >= position.lockedUntil, \"staked funds are locked\");\n\n    // By this point, leverageMultiplier should always be 1x due to the reset logic in updateReward.\n    // But we subtract leveredAmount from totalLeveragedStakedSupply anyway, since that is technically correct.\n    uint256 leveredAmount = toLeveredAmount(amount, position.leverageMultiplier);\n    totalLeveragedStakedSupply = totalLeveragedStakedSupply.sub(leveredAmount);\n    totalStakedSupply = totalStakedSupply.sub(amount);\n    position.amount = prevAmount.sub(amount);\n\n    // Slash unvested rewards\n    uint256 slashingPercentage = amount.mul(StakingRewardsVesting.PERCENTAGE_DECIMALS).div(prevAmount);\n    position.rewards.slash(slashingPercentage);\n\n    emit Unstaked(msg.sender, tokenId, amount);\n  }\n\n  /// @notice \"Kick\" a user's reward multiplier. If they are past their lock-up period, their reward\n  ///   multipler will be reset to 1x.\n  /// @dev This will also checkpoint their rewards up to the current time.\n  // solhint-disable-next-line no-empty-blocks\n  function kick(uint256 tokenId) public nonReentrant whenNotPaused updateReward(tokenId) {}\n\n  /// @notice Claim rewards for a given staked position\n  /// @param tokenId A staking position token ID\n  function getReward(uint256 tokenId) public nonReentrant whenNotPaused updateReward(tokenId) {\n    require(ownerOf(tokenId) == msg.sender, \"access denied\");\n    uint256 reward = claimableRewards(tokenId);\n    if (reward > 0) {\n      positions[tokenId].rewards.claim(reward);\n      rewardsToken().safeTransfer(msg.sender, reward);\n      emit RewardPaid(msg.sender, tokenId, reward);\n    }\n  }\n\n  /// @notice Unstake the position's full amount and claim all rewards\n  /// @param tokenId A staking position token ID\n  function exit(uint256 tokenId) external {\n    unstake(tokenId, positions[tokenId].amount);\n    getReward(tokenId);\n  }\n\n  function exitAndWithdraw(uint256 tokenId) external {\n    unstakeAndWithdrawInFidu(tokenId, positions[tokenId].amount);\n    getReward(tokenId);\n  }\n\n  /* ========== RESTRICTED FUNCTIONS ========== */\n\n  /// @notice Transfer rewards from msg.sender, to be used for reward distribution\n  function loadRewards(uint256 rewards) public onlyAdmin updateReward(0) {\n    rewardsToken().safeTransferFrom(msg.sender, address(this), rewards);\n    rewardsAvailable = rewardsAvailable.add(rewards);\n    emit RewardAdded(rewards);\n  }\n\n  function setRewardsParameters(\n    uint256 _targetCapacity,\n    uint256 _minRate,\n    uint256 _maxRate,\n    uint256 _minRateAtPercent,\n    uint256 _maxRateAtPercent\n  ) public onlyAdmin updateReward(0) {\n    require(_maxRate >= _minRate, \"maxRate must be >= then minRate\");\n    require(_maxRateAtPercent <= _minRateAtPercent, \"maxRateAtPercent must be <= minRateAtPercent\");\n    targetCapacity = _targetCapacity;\n    minRate = _minRate;\n    maxRate = _maxRate;\n    minRateAtPercent = _minRateAtPercent;\n    maxRateAtPercent = _maxRateAtPercent;\n\n    emit RewardsParametersUpdated(msg.sender, targetCapacity, minRate, maxRate, minRateAtPercent, maxRateAtPercent);\n  }\n\n  function setLeverageMultiplier(LockupPeriod lockupPeriod, uint256 leverageMultiplier)\n    public\n    onlyAdmin\n    updateReward(0)\n  {\n    leverageMultipliers[lockupPeriod] = leverageMultiplier;\n    emit LeverageMultiplierUpdated(msg.sender, lockupPeriod, leverageMultiplier);\n  }\n\n  function setVestingSchedule(uint256 _vestingLength) public onlyAdmin updateReward(0) {\n    vestingLength = _vestingLength;\n    emit VestingScheduleUpdated(msg.sender, vestingLength);\n  }\n\n  function updateDobermanConfig() external onlyAdmin {\n    config = DobermanConfig(config.configAddress());\n    emit DobermanConfigUpdated(_msgSender(), address(config));\n  }\n\n  /* ========== MODIFIERS ========== */\n\n  modifier updateReward(uint256 tokenId) {\n    _updateReward(tokenId);\n    _;\n  }\n\n  function _updateReward(uint256 tokenId) internal {\n    uint256 prevAccumulatedRewardsPerToken = accumulatedRewardsPerToken;\n\n    accumulatedRewardsPerToken = rewardPerToken();\n    uint256 rewardsJustDistributed = totalLeveragedStakedSupply\n      .mul(accumulatedRewardsPerToken.sub(prevAccumulatedRewardsPerToken))\n      .div(stakingTokenMantissa());\n    rewardsAvailable = rewardsAvailable.sub(rewardsJustDistributed);\n    lastUpdateTime = block.timestamp;\n\n    if (tokenId != 0) {\n      uint256 additionalRewards = earnedSinceLastCheckpoint(tokenId);\n\n      StakedPosition storage position = positions[tokenId];\n      StakingRewardsVesting.Rewards storage rewards = position.rewards;\n      rewards.totalUnvested = rewards.totalUnvested.add(additionalRewards);\n      rewards.checkpoint();\n\n      positionToAccumulatedRewardsPerToken[tokenId] = accumulatedRewardsPerToken;\n\n      // If position is unlocked, reset its leverageMultiplier back to 1x\n      uint256 lockedUntil = position.lockedUntil;\n      uint256 leverageMultiplier = position.leverageMultiplier;\n      uint256 amount = position.amount;\n      if (lockedUntil > 0 && block.timestamp >= lockedUntil && leverageMultiplier > MULTIPLIER_DECIMALS) {\n        uint256 prevLeveredAmount = toLeveredAmount(amount, leverageMultiplier);\n        uint256 newLeveredAmount = toLeveredAmount(amount, MULTIPLIER_DECIMALS);\n        position.leverageMultiplier = MULTIPLIER_DECIMALS;\n        totalLeveragedStakedSupply = totalLeveragedStakedSupply.sub(prevLeveredAmount).add(newLeveredAmount);\n      }\n    }\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n\n  /* ========== EVENTS ========== */\n\n  event RewardAdded(uint256 reward);\n  event Staked(address indexed user, uint256 indexed tokenId, uint256 amount, uint256 lockedUntil, uint256 multiplier);\n  event DepositedAndStaked(\n    address indexed user,\n    uint256 depositedAmount,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 lockedUntil,\n    uint256 multiplier\n  );\n  event Unstaked(address indexed user, uint256 indexed tokenId, uint256 amount);\n  event UnstakedAndWithdrew(address indexed user, uint256 usdcReceivedAmount, uint256 indexed tokenId, uint256 amount);\n  event UnstakedAndWithdrewMultiple(\n    address indexed user,\n    uint256 usdcReceivedAmount,\n    uint256[] tokenIds,\n    uint256[] amounts\n  );\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}