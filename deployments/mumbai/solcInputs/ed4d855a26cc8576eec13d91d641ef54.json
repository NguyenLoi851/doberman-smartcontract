{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(account),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SignedSafeMath {\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        return a + b;\n    }\n}\n"
    },
    "contracts/external/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// solhint-disable\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\";\n\n/**\n * @title Library for fixed point arithmetic on uints\n */\nlibrary FixedPoint {\n  using SafeMath for uint256;\n  using SignedSafeMath for int256;\n\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For unsigned values:\n  //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\n\n  // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\n  struct Unsigned {\n    uint256 rawValue;\n  }\n\n  /**\n   * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a uint to convert into a FixedPoint.\n   * @return the converted FixedPoint.\n   */\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if equal, or False.\n   */\n  function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return add(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts two `Unsigned`s, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return sub(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\n   * @param a a uint256.\n   * @param b a FixedPoint.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return sub(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as a uint256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because FP_SCALING_FACTOR != 0.\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.\n   * @param b a uint256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Unsigned`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\n    if (mod != 0) {\n      return Unsigned(mulFloor.add(1));\n    } else {\n      return Unsigned(mulFloor);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Unsigned` and an unscaled uint256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.\n   * @param b a FixedPoint.\n   * @return the product of `a` and `b`.\n   */\n  function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Unsigned(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as a uint256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    return Unsigned(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a uint256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    return div(fromUnscaledUint(a), b);\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an `Unsigned` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\n    uint256 divFloor = aScaled.div(b.rawValue);\n    uint256 mod = aScaled.mod(b.rawValue);\n    if (mod != 0) {\n      return Unsigned(divFloor.add(1));\n    } else {\n      return Unsigned(divFloor);\n    }\n  }\n\n  /**\n   * @notice Divides one `Unsigned` by an unscaled uint256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Unsigned(a.rawValue.div(b))\"\n    // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\n    // This creates the possibility of overflow if b is very large.\n    return divCeil(a, fromUnscaledUint(b));\n  }\n\n  /**\n   * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint numerator.\n   * @param b a uint256 denominator.\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\n    output = fromUnscaledUint(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n\n  // ------------------------------------------------- SIGNED -------------------------------------------------------------\n  // Supports 18 decimals. E.g., 1e18 represents \"1\", 5e17 represents \"0.5\".\n  // For signed values:\n  //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\n\n  struct Signed {\n    int256 rawValue;\n  }\n\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\n    require(a.rawValue >= 0, \"Negative value provided\");\n    return Unsigned(uint256(a.rawValue));\n  }\n\n  function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\n    require(a.rawValue <= uint256(type(int256).max), \"Unsigned too large\");\n    return Signed(int256(a.rawValue));\n  }\n\n  /**\n   * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\n   * @param a int to convert into a FixedPoint.Signed.\n   * @return the converted FixedPoint.Signed.\n   */\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\n    return Signed(a.mul(SFP_SCALING_FACTOR));\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a int256.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue == fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if equal, or False.\n   */\n  function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue == b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue > fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a > b`, or False.\n   */\n  function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue > b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is greater than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a >= b`, or False.\n   */\n  function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue < fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a < b`, or False.\n   */\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue < b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\n    return a.rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\n  }\n\n  /**\n   * @notice Whether `a` is less than or equal to `b`.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return True if `a <= b`, or False.\n   */\n  function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\n  }\n\n  /**\n   * @notice The minimum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the minimum of `a` and `b`.\n   */\n  function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue < b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice The maximum of `a` and `b`.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the maximum of `a` and `b`.\n   */\n  function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return a.rawValue > b.rawValue ? a : b;\n  }\n\n  /**\n   * @notice Adds two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.add(b.rawValue));\n  }\n\n  /**\n   * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the sum of `a` and `b`.\n   */\n  function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return add(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts two `Signed`s, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.sub(b.rawValue));\n  }\n\n  /**\n   * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return sub(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\n   * @param a an int256.\n   * @param b a FixedPoint.Signed.\n   * @return the difference of `a` and `b`.\n   */\n  function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return sub(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\n    // stored internally as an int256 ~10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\n    // would round to 3, but this computation produces the result 2.\n    // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\n   * @dev This will \"floor\" the product.\n   * @param a a FixedPoint.Signed.\n   * @param b an int256.\n   * @return the product of `a` and `b`.\n   */\n  function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Multiplies two `Signed`s and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(mulTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(mulTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Multiplies an `Signed` and an unscaled int256 and \"ceil's\" the product, reverting on overflow.\n   * @param a a FixedPoint.Signed.\n   * @param b a FixedPoint.Signed.\n   * @return the product of `a` and `b`.\n   */\n  function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\n    return Signed(a.rawValue.mul(b));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    // There are two caveats with this computation:\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\n    // 10^41 is stored internally as an int256 10^59.\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    return Signed(a.rawValue.div(b));\n  }\n\n  /**\n   * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\n   * @dev This will \"floor\" the quotient.\n   * @param a an int256 numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\n    return div(fromUnscaledInt(a), b);\n  }\n\n  /**\n   * @notice Divides one `Signed` by an `Signed` and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b a FixedPoint denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\n    int256 divTowardsZero = aScaled.div(b.rawValue);\n    // Manual mod because SignedSafeMath doesn't support it.\n    int256 mod = aScaled % b.rawValue;\n    if (mod != 0) {\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\n      return Signed(divTowardsZero.add(valueToAdd));\n    } else {\n      return Signed(divTowardsZero);\n    }\n  }\n\n  /**\n   * @notice Divides one `Signed` by an unscaled int256 and \"ceil's\" the quotient, reverting on overflow or division by 0.\n   * @param a a FixedPoint numerator.\n   * @param b an int256 denominator.\n   * @return the quotient of `a` divided by `b`.\n   */\n  function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\n    // Because it is possible that a quotient gets truncated, we can't just call \"Signed(a.rawValue.div(b))\"\n    // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\n    // This creates the possibility of overflow if b is very large.\n    return divAwayFromZero(a, fromUnscaledInt(b));\n  }\n\n  /**\n   * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\n   * @dev This will \"floor\" the result.\n   * @param a a FixedPoint.Signed.\n   * @param b a uint256 (negative exponents are not allowed).\n   * @return output is `a` to the power of `b`.\n   */\n  function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\n    output = fromUnscaledInt(1);\n    for (uint256 i = 0; i < b; i = i.add(1)) {\n      output = mul(output, a);\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IBackerRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\ninterface IBackerRewards {\n  function allocateRewards(uint256 _interestPaymentAmount) external;\n\n  function setPoolTokenAccRewardsPerPrincipalDollarAtMint(address poolAddress, uint256 tokenId) external;\n}\n"
    },
    "contracts/interfaces/ICreditDesk.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract ICreditDesk {\n  uint256 public totalWritedowns;\n  uint256 public totalLoansOutstanding;\n\n  function setUnderwriterGovernanceLimit(address underwriterAddress, uint256 limit) external virtual;\n\n  function drawdown(address creditLineAddress, uint256 amount) external virtual;\n\n  function pay(address creditLineAddress, uint256 amount) external virtual;\n\n  function assessCreditLine(address creditLineAddress) external virtual;\n\n  function applyPayment(address creditLineAddress, uint256 amount) external virtual;\n\n  function getNextPaymentAmount(address creditLineAddress, uint256 asOfBLock) external view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface ICreditLine {\n  function borrower() external view returns (address);\n\n  function limit() external view returns (uint256);\n\n  function maxLimit() external view returns (uint256);\n\n  function interestApr() external view returns (uint256);\n\n  function paymentPeriodInDays() external view returns (uint256);\n\n  function principalGracePeriodInDays() external view returns (uint256);\n\n  function termInDays() external view returns (uint256);\n\n  function lateFeeApr() external view returns (uint256);\n\n  function isLate() external view returns (bool);\n\n  function withinPrincipalGracePeriod() external view returns (bool);\n\n  // Accounting variables\n  function balance() external view returns (uint256);\n\n  function interestOwed() external view returns (uint256);\n\n  function principalOwed() external view returns (uint256);\n\n  function termEndTime() external view returns (uint256);\n\n  function nextDueTime() external view returns (uint256);\n\n  function interestAccruedAsOf() external view returns (uint256);\n\n  function lastFullPaymentTime() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICUSDCContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/compound-finance/compound-protocol/blob/master/contracts/CTokenInterfaces.sol\npragma solidity 0.8.4;\n\nimport \"./IERC20withDec.sol\";\n\ninterface ICUSDCContract is IERC20withDec {\n  /*** User Interface ***/\n\n  function mint(uint256 mintAmount) external returns (uint256);\n\n  function redeem(uint256 redeemTokens) external returns (uint256);\n\n  function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n  function borrow(uint256 borrowAmount) external returns (uint256);\n\n  function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n  function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n  function liquidateBorrow(\n    address borrower,\n    uint256 repayAmount,\n    address cTokenCollateral\n  ) external returns (uint256);\n\n  function getAccountSnapshot(address account)\n    external\n    view\n    returns (\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function balanceOfUnderlying(address owner) external returns (uint256);\n\n  function exchangeRateCurrent() external returns (uint256);\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint256 addAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDobermanConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IDobermanConfig {\n  function getNumber(uint256 index) external returns (uint256);\n\n  function getAddress(uint256 index) external returns (address);\n\n  function setAddress(uint256 index, address newAddress) external returns (address);\n\n  function setNumber(uint256 index, uint256 newNumber) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IDobermanFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\ninterface IDobermanFactory {\n  function createCreditLine() external returns (address);\n\n  function createBorrower(address owner) external returns (address);\n\n  function createPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function createMigratedPool(\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256[] calldata _allowedUIDTypes\n  ) external returns (address);\n\n  function updateDobermanConfig() external;\n}\n"
    },
    "contracts/interfaces/IERC20withDec.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nOnly addition is the `decimals` function, which we need, and which both our Fidu and USDC use, along with most ERC20's.\n*/\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20withDec is IERC20 {\n  /**\n   * @dev Returns the number of decimals used for the token\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IFidu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./IERC20withDec.sol\";\n\ninterface IFidu is IERC20withDec {\n  function mintTo(address to, uint256 amount) external;\n\n  function burnFrom(address to, uint256 amount) external;\n\n  function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/interfaces/IGo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IGo {\n  uint256 public constant ID_TYPE_0 = 0;\n  uint256 public constant ID_TYPE_1 = 1;\n  uint256 public constant ID_TYPE_2 = 2;\n  uint256 public constant ID_TYPE_3 = 3;\n  uint256 public constant ID_TYPE_4 = 4;\n  uint256 public constant ID_TYPE_5 = 5;\n  uint256 public constant ID_TYPE_6 = 6;\n  uint256 public constant ID_TYPE_7 = 7;\n  uint256 public constant ID_TYPE_8 = 8;\n  uint256 public constant ID_TYPE_9 = 9;\n  uint256 public constant ID_TYPE_10 = 10;\n\n  /// @notice Returns the address of the UniqueIdentity contract.\n  function uniqueIdentity() external virtual returns (address);\n\n  function go(address account) public view virtual returns (bool);\n\n  function goOnlyIdTypes(address account, uint256[] calldata onlyIdTypes) public view virtual returns (bool);\n\n  function goSeniorPool(address account) public view virtual returns (bool);\n\n  function updateDobermanConfig() external virtual;\n}\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nabstract contract IPool {\n  uint256 public sharePrice;\n\n  function deposit(uint256 amount) external virtual;\n\n  function withdraw(uint256 usdcAmount) external virtual;\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual;\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) public virtual;\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual returns (bool);\n\n  function drawdown(address to, uint256 amount) public virtual returns (bool);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function distributeLosses(address creditlineAddress, int256 writedownDelta) external virtual;\n\n  function assets() public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/IPoolTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\";\n\ninterface IPoolTokens is IERC721Upgradeable {\n  event TokenMinted(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 amount,\n    uint256 tranche\n  );\n\n  event TokenRedeemed(\n    address indexed owner,\n    address indexed pool,\n    uint256 indexed tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed,\n    uint256 tranche\n  );\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\n\n  struct TokenInfo {\n    address pool;\n    uint256 tranche;\n    uint256 principalAmount;\n    uint256 principalRedeemed;\n    uint256 interestRedeemed;\n  }\n\n  struct MintParams {\n    uint256 principalAmount;\n    uint256 tranche;\n  }\n\n  function mint(MintParams calldata params, address to) external returns (uint256);\n\n  function redeem(\n    uint256 tokenId,\n    uint256 principalRedeemed,\n    uint256 interestRedeemed\n  ) external;\n\n  function burn(uint256 tokenId) external;\n\n  function onPoolCreated(address newPool) external;\n\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\n\n  function validPool(address sender) external view returns (bool);\n\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ISeniorPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ITranchedPool.sol\";\n\nabstract contract ISeniorPool {\n  uint256 public sharePrice;\n  uint256 public totalLoansOutstanding;\n  uint256 public totalWritedowns;\n\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\n\n  function depositWithPermit(\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 depositShares);\n\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\n\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\n\n  function sweepToCompound() public virtual;\n\n  function sweepFromCompound() public virtual;\n\n  function invest(ITranchedPool pool) public virtual;\n\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\n\n  function redeem(uint256 tokenId) public virtual;\n\n  function writedown(uint256 tokenId) public virtual;\n\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\n\n  function assets() public view virtual returns (uint256);\n\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISeniorPoolStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ISeniorPool.sol\";\nimport \"./ITranchedPool.sol\";\n\nabstract contract ISeniorPoolStrategy {\n  function getLeverageRatio(ITranchedPool pool) public view virtual returns (uint256);\n\n  function invest(ISeniorPool seniorPool, ITranchedPool pool) public view virtual returns (uint256 amount);\n\n  function estimateInvestment(ISeniorPool seniorPool, ITranchedPool pool) public view virtual returns (uint256);\n}\n"
    },
    "contracts/interfaces/ITranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./IV2CreditLine.sol\";\n\nabstract contract ITranchedPool {\n  IV2CreditLine public creditLine;\n  uint256 public createdAt;\n\n  enum Tranches {\n    Reserved,\n    Senior,\n    Junior\n  }\n\n  struct TrancheInfo {\n    uint256 id;\n    uint256 principalDeposited;\n    uint256 principalSharePrice;\n    uint256 interestSharePrice;\n    uint256 lockedUntil;\n  }\n\n  struct PoolSlice {\n    TrancheInfo seniorTranche;\n    TrancheInfo juniorTranche;\n    uint256 totalInterestAccrued;\n    uint256 principalDeployed;\n  }\n\n  struct SliceInfo {\n    uint256 reserveFeePercent;\n    uint256 interestAccrued;\n    uint256 principalAccrued;\n  }\n\n  struct ApplyResult {\n    uint256 interestRemaining;\n    uint256 principalRemaining;\n    uint256 reserveDeduction;\n    uint256 oldInterestSharePrice;\n    uint256 oldPrincipalSharePrice;\n  }\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public virtual;\n\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\n\n  function pay(uint256 amount) external virtual;\n\n  function lockJuniorCapital() external virtual;\n\n  function lockPool() external virtual;\n\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\n\n  function totalJuniorDeposits() external view virtual returns (uint256);\n\n  function drawdown(uint256 amount) external virtual;\n\n  function setFundableAt(uint256 timestamp) external virtual;\n\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\n\n  function assess() external virtual;\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual returns (uint256 tokenId);\n\n  function availableToWithdraw(uint256 tokenId)\n    external\n    view\n    virtual\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\n\n  function withdraw(uint256 tokenId, uint256 amount)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMax(uint256 tokenId)\n    external\n    virtual\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\n\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\n  \n  function withdrawMaxMultiple(uint256[] calldata tokenIds) external virtual;\n}\n"
    },
    "contracts/interfaces/IV2CreditLine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./ICreditLine.sol\";\n\nabstract contract IV2CreditLine is ICreditLine {\n  function principal() external view virtual returns (uint256);\n\n  function totalInterestAccrued() external view virtual returns (uint256);\n\n  function termStartTime() external view virtual returns (uint256);\n\n  function setLimit(uint256 newAmount) external virtual;\n\n  function setMaxLimit(uint256 newAmount) external virtual;\n\n  function setBalance(uint256 newBalance) external virtual;\n\n  function setPrincipal(uint256 _principal) external virtual;\n\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\n\n  function drawdown(uint256 amount) external virtual;\n\n  function assess()\n    external\n    virtual\n    returns (\n      uint256,\n      uint256,\n      uint256\n    );\n\n  function initialize(\n    address _config,\n    address owner,\n    address _borrower,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public virtual;\n\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\n\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\n\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\n\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\n\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\n\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\n\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\n\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\n\n  function updateDobermanConfig() external virtual;\n}\n"
    },
    "contracts/library/SafeERC20Transfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title Safe ERC20 Transfer\n * @notice Reverts when transfer is not successful\n * @author Doberman\n */\nabstract contract SafeERC20Transfer {\n  function safeERC20Transfer(\n    IERC20 erc20,\n    address to,\n    uint256 amount,\n    string memory message\n  ) internal {\n    require(to != address(0), \"Can't send to zero address\");\n    bool success = erc20.transfer(to, amount);\n    require(success, message);\n  }\n\n  function safeERC20Transfer(\n    IERC20 erc20,\n    address to,\n    uint256 amount\n  ) internal {\n    safeERC20Transfer(erc20, to, amount, \"Failed to transfer ERC20\");\n  }\n\n  function safeERC20TransferFrom(\n    IERC20 erc20,\n    address from,\n    address to,\n    uint256 amount,\n    string memory message\n  ) internal {\n    require(to != address(0), \"Can't send to zero address\");\n    bool success = erc20.transferFrom(from, to, amount);\n    require(success, message);\n  }\n\n  function safeERC20TransferFrom(\n    IERC20 erc20,\n    address from,\n    address to,\n    uint256 amount\n  ) internal {\n    string memory message = \"Failed to transfer ERC20\";\n    safeERC20TransferFrom(erc20, from, to, amount, message);\n  }\n\n  function safeERC20Approve(\n    IERC20 erc20,\n    address spender,\n    uint256 allowance,\n    string memory message\n  ) internal {\n    bool success = erc20.approve(spender, allowance);\n    require(success, message);\n  }\n\n  function safeERC20Approve(\n    IERC20 erc20,\n    address spender,\n    uint256 allowance\n  ) internal {\n    string memory message = \"Failed to approve ERC20\";\n    safeERC20Approve(erc20, spender, allowance, message);\n  }\n}\n"
    },
    "contracts/protocol/core/BaseUpgradeablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./PauserPausable.sol\";\n\n/**\n * @title BaseUpgradeablePausable contract\n * @notice This is our Base contract that most other contracts inherit from. It includes many standard\n *  useful abilities like ugpradeability, pausability, access control, and re-entrancy guards.\n * @author Doberman\n */\n\ncontract BaseUpgradeablePausable is\n  Initializable,\n  AccessControlUpgradeable,\n  PauserPausable,\n  ReentrancyGuardUpgradeable\n{\n  bytes32 public constant OWNER_ROLE = keccak256(\"OWNER_ROLE\");\n  using SafeMath for uint256;\n  // Pre-reserving a few slots in the base contract in case we need to add things in the future.\n  // This does not actually take up gas cost or storage cost, but it does reserve the storage slots.\n  // See OpenZeppelin's use of this pattern here:\n  // https://github.com/OpenZeppelin/openzeppelin-contracts-ethereum-package/blob/master/contracts/GSN/Context.sol#L37\n  uint256[50] private __gap1;\n  uint256[50] private __gap2;\n  uint256[50] private __gap3;\n  uint256[50] private __gap4;\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __BaseUpgradeablePausable__init(address owner) public onlyInitializing {\n    require(owner != address(0), \"Owner cannot be the zero address\");\n    __AccessControl_init_unchained();\n    __Pausable_init_unchained();\n    __ReentrancyGuard_init_unchained();\n\n    _setupRole(OWNER_ROLE, owner);\n    _setupRole(PAUSER_ROLE, owner);\n\n    _setRoleAdmin(PAUSER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(OWNER_ROLE, OWNER_ROLE);\n  }\n\n  function isAdmin() public view returns (bool) {\n    return hasRole(OWNER_ROLE, _msgSender());\n  }\n\n  modifier onlyAdmin() {\n    require(isAdmin(), \"Must have admin role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./DobermanConfig.sol\";\nimport \"../../interfaces/IPool.sol\";\nimport \"../../interfaces/IFidu.sol\";\nimport \"../../interfaces/ISeniorPool.sol\";\nimport \"../../interfaces/ISeniorPoolStrategy.sol\";\nimport \"../../interfaces/ICreditDesk.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/ICUSDCContract.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../interfaces/IBackerRewards.sol\";\nimport \"../../interfaces/IDobermanFactory.sol\";\nimport \"../../interfaces/IGo.sol\";\n\n/**\n * @title ConfigHelper\n * @notice A convenience library for getting easy access to other contracts and constants within the\n *  protocol, through the use of the DobermanConfig contract\n * @author Doberman\n */\n\nlibrary ConfigHelper {\n  function getPool(DobermanConfig config) internal view returns (IPool) {\n    return IPool(poolAddress(config));\n  }\n\n  function getSeniorPool(DobermanConfig config) internal view returns (ISeniorPool) {\n    return ISeniorPool(seniorPoolAddress(config));\n  }\n\n  function getSeniorPoolStrategy(DobermanConfig config) internal view returns (ISeniorPoolStrategy) {\n    return ISeniorPoolStrategy(seniorPoolStrategyAddress(config));\n  }\n\n  function getUSDC(DobermanConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(usdcAddress(config));\n  }\n\n  function getCreditDesk(DobermanConfig config) internal view returns (ICreditDesk) {\n    return ICreditDesk(creditDeskAddress(config));\n  }\n\n  function getFidu(DobermanConfig config) internal view returns (IFidu) {\n    return IFidu(fiduAddress(config));\n  }\n\n  function getCUSDCContract(DobermanConfig config) internal view returns (ICUSDCContract) {\n    return ICUSDCContract(cusdcContractAddress(config));\n  }\n\n  function getPoolTokens(DobermanConfig config) internal view returns (IPoolTokens) {\n    return IPoolTokens(poolTokensAddress(config));\n  }\n\n  function getBackerRewards(DobermanConfig config) internal view returns (IBackerRewards) {\n    return IBackerRewards(backerRewardsAddress(config));\n  }\n\n  function getDobermanFactory(DobermanConfig config) internal view returns (IDobermanFactory) {\n    return IDobermanFactory(DobermanFactoryAddress(config));\n  }\n\n  function getGFI(DobermanConfig config) internal view returns (IERC20withDec) {\n    return IERC20withDec(gfiAddress(config));\n  }\n\n  function getGo(DobermanConfig config) internal view returns (IGo) {\n    return IGo(goAddress(config));\n  }\n\n  function oneInchAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.OneInch));\n  }\n\n  function creditLineImplementationAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditLineImplementation));\n  }\n\n  function trustedForwarderAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TrustedForwarder));\n  }\n\n  function configAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.DobermanConfig));\n  }\n\n  function poolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Pool));\n  }\n\n  function poolTokensAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.PoolTokens));\n  }\n\n  function backerRewardsAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.BackerRewards));\n  }\n\n  function seniorPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.SeniorPool));\n  }\n\n  function seniorPoolStrategyAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.SeniorPoolStrategy));\n  }\n\n  function creditDeskAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CreditDesk));\n  }\n\n  function DobermanFactoryAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.DobermanFactory));\n  }\n\n  function gfiAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.GFI));\n  }\n\n  function fiduAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Fidu));\n  }\n\n  function cusdcContractAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.CUSDCContract));\n  }\n\n  function usdcAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.USDC));\n  }\n\n  function tranchedPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TranchedPoolImplementation));\n  }\n\n  function migratedTranchedPoolAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.MigratedTranchedPoolImplementation));\n  }\n\n  function reserveAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.TreasuryReserve));\n  }\n\n  function protocolAdminAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.ProtocolAdmin));\n  }\n\n  function borrowerImplementationAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.BorrowerImplementation));\n  }\n\n  function goAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.Go));\n  }\n\n  function stakingRewardsAddress(DobermanConfig config) internal view returns (address) {\n    return config.getAddress(uint256(ConfigOptions.Addresses.StakingRewards));\n  }\n\n  function getReserveDenominator(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.ReserveDenominator));\n  }\n\n  function getWithdrawFeeDenominator(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.WithdrawFeeDenominator));\n  }\n\n  function getLatenessGracePeriodInDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessGracePeriodInDays));\n  }\n\n  function getLatenessMaxDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LatenessMaxDays));\n  }\n\n  function getDrawdownPeriodInSeconds(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.DrawdownPeriodInSeconds));\n  }\n\n  function getTransferRestrictionPeriodInDays(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.TransferRestrictionPeriodInDays));\n  }\n\n  function getLeverageRatio(DobermanConfig config) internal view returns (uint256) {\n    return config.getNumber(uint256(ConfigOptions.Numbers.LeverageRatio));\n  }\n}\n"
    },
    "contracts/protocol/core/ConfigOptions.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n/**\n * @title ConfigOptions\n * @notice A central place for enumerating the configurable options of our DobermanConfig contract\n * @author Doberman\n */\n\nlibrary ConfigOptions {\n  // NEVER EVER CHANGE THE ORDER OF THESE!\n  // You can rename or append. But NEVER change the order.\n  enum Numbers {\n    TransactionLimit,\n    TotalFundsLimit,\n    MaxUnderwriterLimit,\n    ReserveDenominator,\n    WithdrawFeeDenominator,\n    LatenessGracePeriodInDays,\n    LatenessMaxDays,\n    DrawdownPeriodInSeconds,\n    TransferRestrictionPeriodInDays,\n    LeverageRatio\n  }\n  enum Addresses {\n    Pool,\n    CreditLineImplementation,\n    DobermanFactory,\n    CreditDesk,\n    Fidu,\n    USDC,\n    TreasuryReserve,\n    ProtocolAdmin,\n    OneInch,\n    TrustedForwarder,\n    CUSDCContract,\n    DobermanConfig,\n    PoolTokens,\n    TranchedPoolImplementation,\n    SeniorPool,\n    SeniorPoolStrategy,\n    MigratedTranchedPoolImplementation,\n    BorrowerImplementation,\n    GFI,\n    Go,\n    BackerRewards,\n    StakingRewards\n  }\n}\n"
    },
    "contracts/protocol/core/DobermanConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"../../interfaces/IDobermanConfig.sol\";\nimport \"./ConfigOptions.sol\";\n\n/**\n * @title DobermanConfig\n * @notice This contract stores mappings of useful \"protocol config state\", giving a central place\n *  for all other contracts to access it. For example, the TransactionLimit, or the PoolAddress. These config vars\n *  are enumerated in the `ConfigOptions` library, and can only be changed by admins of the protocol.\n *  Note: While this inherits from BaseUpgradeablePausable, it is not deployed as an upgradeable contract (this\n *    is mostly to save gas costs of having each call go through a proxy)\n * @author Doberman\n */\n\ncontract DobermanConfig is BaseUpgradeablePausable {\n  bytes32 public constant GO_LISTER_ROLE = keccak256(\"GO_LISTER_ROLE\");\n\n  mapping(uint256 => address) public addresses;\n  mapping(uint256 => uint256) public numbers;\n  mapping(address => bool) public goList;\n\n  event AddressUpdated(address owner, uint256 index, address oldValue, address newValue);\n  event NumberUpdated(address owner, uint256 index, uint256 oldValue, uint256 newValue);\n\n  event GoListed(address indexed member);\n  event NoListed(address indexed member);\n\n  bool public valuesInitialized;\n\n  function initialize(address owner) public initializer {\n    require(owner != address(0), \"Owner address cannot be empty\");\n\n    __BaseUpgradeablePausable__init(owner);\n\n    _setupRole(GO_LISTER_ROLE, owner);\n\n    _setRoleAdmin(GO_LISTER_ROLE, OWNER_ROLE);\n  }\n\n  function setAddress(uint256 addressIndex, address newAddress) public onlyAdmin {\n    // require(addresses[addressIndex] == address(0), \"Address has already been initialized\");\n\n    emit AddressUpdated(msg.sender, addressIndex, addresses[addressIndex], newAddress);\n    addresses[addressIndex] = newAddress;\n  }\n\n  function setNumber(uint256 index, uint256 newNumber) public onlyAdmin {\n    emit NumberUpdated(msg.sender, index, numbers[index], newNumber);\n    numbers[index] = newNumber;\n  }\n\n  function setTreasuryReserve(address newTreasuryReserve) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TreasuryReserve);\n    emit AddressUpdated(msg.sender, key, addresses[key], newTreasuryReserve);\n    addresses[key] = newTreasuryReserve;\n  }\n\n  function setSeniorPoolStrategy(address newStrategy) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.SeniorPoolStrategy);\n    emit AddressUpdated(msg.sender, key, addresses[key], newStrategy);\n    addresses[key] = newStrategy;\n  }\n\n  function setCreditLineImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.CreditLineImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setTranchedPoolImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.TranchedPoolImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setBorrowerImplementation(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.BorrowerImplementation);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function setDobermanConfig(address newAddress) public onlyAdmin {\n    uint256 key = uint256(ConfigOptions.Addresses.DobermanConfig);\n    emit AddressUpdated(msg.sender, key, addresses[key], newAddress);\n    addresses[key] = newAddress;\n  }\n\n  function initializeFromOtherConfig(\n    address _initialConfig,\n    uint256 numbersLength,\n    uint256 addressesLength\n  ) public onlyAdmin {\n    require(!valuesInitialized, \"Already initialized values\");\n    IDobermanConfig initialConfig = IDobermanConfig(_initialConfig);\n    for (uint256 i = 0; i < numbersLength; i++) {\n      setNumber(i, initialConfig.getNumber(i));\n    }\n\n    for (uint256 i = 0; i < addressesLength; i++) {\n      if (getAddress(i) == address(0)) {\n        setAddress(i, initialConfig.getAddress(i));\n      }\n    }\n    valuesInitialized = true;\n  }\n\n  /**\n   * @dev Adds a user to go-list\n   * @param _member address to add to go-list\n   */\n  function addToGoList(address _member) public onlyGoListerRole {\n    goList[_member] = true;\n    emit GoListed(_member);\n  }\n\n  /**\n   * @dev removes a user from go-list\n   * @param _member address to remove from go-list\n   */\n  function removeFromGoList(address _member) public onlyGoListerRole {\n    goList[_member] = false;\n    emit NoListed(_member);\n  }\n\n  /**\n   * @dev adds many users to go-list at once\n   * @param _members addresses to ad to go-list\n   */\n  function bulkAddToGoList(address[] calldata _members) external onlyGoListerRole {\n    for (uint256 i = 0; i < _members.length; i++) {\n      addToGoList(_members[i]);\n    }\n  }\n\n  /**\n   * @dev removes many users from go-list at once\n   * @param _members addresses to remove from go-list\n   */\n  function bulkRemoveFromGoList(address[] calldata _members) external onlyGoListerRole {\n    for (uint256 i = 0; i < _members.length; i++) {\n      removeFromGoList(_members[i]);\n    }\n  }\n\n  /*\n    Using custom getters in case we want to change underlying implementation later,\n    or add checks or validations later on.\n  */\n  function getAddress(uint256 index) public view returns (address) {\n    return addresses[index];\n  }\n\n  function getNumber(uint256 index) public view returns (uint256) {\n    return numbers[index];\n  }\n\n  modifier onlyGoListerRole() {\n    require(hasRole(GO_LISTER_ROLE, _msgSender()), \"Must have go-lister role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/PauserPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\n/**\n * @title PauserPausable\n * @notice Inheriting from OpenZeppelin's Pausable contract, this does small\n *  augmentations to make it work with a PAUSER_ROLE, leveraging the AccessControl contract.\n *  It is meant to be inherited.\n * @author Doberman\n */\n\ncontract PauserPausable is AccessControlUpgradeable, PausableUpgradeable {\n  bytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\n\n  // solhint-disable-next-line func-name-mixedcase\n  function __PauserPausable__init() public initializer {\n    __Pausable_init_unchained();\n  }\n\n  /**\n   * @dev Pauses all functions guarded by Pause\n   *\n   * See {Pausable-_pause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the PAUSER_ROLE.\n   */\n\n  function pause() public onlyPauserRole {\n    _pause();\n  }\n\n  /**\n   * @dev Unpauses the contract\n   *\n   * See {Pausable-_unpause}.\n   *\n   * Requirements:\n   *\n   * - the caller must have the Pauser role\n   */\n  function unpause() public onlyPauserRole {\n    _unpause();\n  }\n\n  modifier onlyPauserRole() {\n    require(hasRole(PAUSER_ROLE, _msgSender()), \"Must have pauser role to perform this action\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/TranchedPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IERC20withDec.sol\";\nimport \"../../interfaces/IV2CreditLine.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"./DobermanConfig.sol\";\nimport \"./BaseUpgradeablePausable.sol\";\nimport \"./ConfigHelper.sol\";\nimport \"../../library/SafeERC20Transfer.sol\";\nimport \"./TranchingLogic.sol\";\n\ncontract TranchedPool is BaseUpgradeablePausable, ITranchedPool, SafeERC20Transfer {\n  DobermanConfig public config;\n  using ConfigHelper for DobermanConfig;\n  using TranchingLogic for PoolSlice;\n  using TranchingLogic for TrancheInfo;\n  using SafeMath for uint256;\n\n  bytes32 public constant LOCKER_ROLE = keccak256(\"LOCKER_ROLE\");\n  bytes32 public constant SENIOR_ROLE = keccak256(\"SENIOR_ROLE\");\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\n  uint256 public constant SECONDS_PER_DAY = 60;\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\n  uint256 public constant NUM_TRANCHES_PER_SLICE = 2;\n  uint256 public juniorFeePercent;\n  bool public drawdownsPaused;\n  uint256[] public allowedUIDTypes;\n  uint256 public totalDeployed;\n  uint256 public fundableAt;\n\n  PoolSlice[] public poolSlices;\n\n  event DepositMade(address indexed owner, uint256 indexed tranche, uint256 indexed tokenId, uint256 amount);\n  event WithdrawalMade(\n    address indexed owner,\n    uint256 indexed tranche,\n    uint256 indexed tokenId,\n    uint256 interestWithdrawn,\n    uint256 principalWithdrawn\n  );\n\n  event DobermanConfigUpdated(address indexed who, address configAddress);\n  event TranchedPoolAssessed(address indexed pool);\n  event PaymentApplied(\n    address indexed payer,\n    address indexed pool,\n    uint256 interestAmount,\n    uint256 principalAmount,\n    uint256 remainingAmount,\n    uint256 reserveAmount\n  );\n  // Note: This has to exactly match the even in the TranchingLogic library for events to be emitted\n  // correctly\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n  event ReserveFundsCollected(address indexed from, uint256 amount);\n  event SeniorPoolFundsCollected(address indexed from, uint256 amount);\n  event CreditLineMigrated(address indexed oldCreditLine, address indexed newCreditLine);\n  event DrawdownMade(address indexed borrower, uint256 amount);\n  event DrawdownsPaused(address indexed pool);\n  event DrawdownsUnpaused(address indexed pool);\n  event EmergencyShutdown(address indexed pool);\n  event TrancheLocked(address indexed pool, uint256 trancheId, uint256 lockedUntil);\n  event SliceCreated(address indexed pool, uint256 sliceId);\n\n  function initialize(\n    address _config,\n    address _borrower,\n    uint256 _juniorFeePercent,\n    uint256 _limit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays,\n    uint256 _fundableAt,\n    uint256[] calldata _allowedUIDTypes\n  ) public override initializer {\n    require(address(_config) != address(0) && address(_borrower) != address(0), \"Config/borrower invalid\");\n\n    config = DobermanConfig(_config);\n    address owner = config.protocolAdminAddress();\n    require(owner != address(0), \"Owner invalid\");\n    __BaseUpgradeablePausable__init(owner);\n    _initializeNextSlice(_fundableAt);\n    createAndSetCreditLine(\n      _borrower,\n      _limit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n\n    createdAt = block.timestamp;\n    juniorFeePercent = _juniorFeePercent;\n    if (_allowedUIDTypes.length == 0) {\n      uint256[1] memory defaultAllowedUIDTypes = [config.getGo().ID_TYPE_0()];\n      allowedUIDTypes = defaultAllowedUIDTypes;\n    } else {\n      allowedUIDTypes = _allowedUIDTypes;\n    }\n\n    _setupRole(LOCKER_ROLE, _borrower);\n    _setupRole(LOCKER_ROLE, owner);\n    _setRoleAdmin(LOCKER_ROLE, OWNER_ROLE);\n    _setRoleAdmin(SENIOR_ROLE, OWNER_ROLE);\n\n    // Give the senior pool the ability to deposit into the senior pool\n    _setupRole(SENIOR_ROLE, address(config.getSeniorPool()));\n\n    // Unlock self for infinite amount\n    bool success = config.getUSDC().approve(address(this), type(uint256).max);\n    require(success, \"Failed to approve USDC\");\n  }\n\n  function setAllowedUIDTypes(uint256[] calldata ids) public onlyLocker {\n    require(\n      poolSlices[0].juniorTranche.principalDeposited == 0 && poolSlices[0].seniorTranche.principalDeposited == 0,\n      \"Must not have balance\"\n    );\n    allowedUIDTypes = ids;\n  }\n\n  /**\n   * @notice Deposit a USDC amount into the pool for a tranche. Mints an NFT to the caller representing the position\n   * @param tranche The number representing the tranche to deposit into\n   * @param amount The USDC amount to tranfer from the caller to the pool\n   * @return tokenId The tokenId of the NFT\n   */\n  function deposit(uint256 tranche, uint256 amount)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 tokenId)\n  {\n    TrancheInfo storage trancheInfo = getTrancheInfo(tranche);\n    require(trancheInfo.lockedUntil == 0, \"Tranche locked\");\n    require(amount > 0, \"Must deposit > zero\");\n    require(config.getGo().goOnlyIdTypes(msg.sender, allowedUIDTypes), \"Address not go-listed\");\n    require(block.timestamp > fundableAt, \"Not open for funding\");\n    // senior tranche ids are always odd numbered\n    if (_isSeniorTrancheId(trancheInfo.id)) {\n      require(hasRole(SENIOR_ROLE, _msgSender()), \"Req SENIOR_ROLE\");\n    }\n\n    trancheInfo.principalDeposited = trancheInfo.principalDeposited.add(amount);\n    IPoolTokens.MintParams memory params = IPoolTokens.MintParams({tranche: tranche, principalAmount: amount});\n    tokenId = config.getPoolTokens().mint(params, msg.sender);\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(this), amount);\n    emit DepositMade(msg.sender, tranche, tokenId, amount);\n    return tokenId;\n  }\n\n  function depositWithPermit(\n    uint256 tranche,\n    uint256 amount,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public override returns (uint256 tokenId) {\n    IERC20Permit(config.usdcAddress()).permit(msg.sender, address(this), amount, deadline, v, r, s);\n    return deposit(tranche, amount);\n  }\n\n  /**\n   * @notice Withdraw an already deposited amount if the funds are available\n   * @param tokenId The NFT representing the position\n   * @param amount The amount to withdraw (must be <= interest+principal currently available to withdraw)\n   * @return interestWithdrawn The interest amount that was withdrawn\n   * @return principalWithdrawn The principal amount that was withdrawn\n   */\n  function withdraw(uint256 tokenId, uint256 amount)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    return _withdraw(trancheInfo, tokenInfo, tokenId, amount);\n  }\n\n  /**\n   * @notice Withdraw from many tokens (that the sender owns) in a single transaction\n   * @param tokenIds An array of tokens ids representing the position\n   * @param amounts An array of amounts to withdraw from the corresponding tokenIds\n   */\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) public override {\n    require(tokenIds.length == amounts.length, \"TokensIds and Amounts mismatch\");\n\n    for (uint256 i = 0; i < amounts.length; i++) {\n      withdraw(tokenIds[i], amounts[i]);\n    }\n  }\n\n  /**\n   * @notice Similar to withdraw but will withdraw all available funds\n   * @param tokenId The NFT representing the position\n   * @return interestWithdrawn The interest amount that was withdrawn\n   * @return principalWithdrawn The principal amount that was withdrawn\n   */\n  function withdrawMax(uint256 tokenId)\n    public\n    override\n    nonReentrant\n    whenNotPaused\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    (uint256 interestRedeemable, uint256 principalRedeemable) = redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n\n    uint256 amount = interestRedeemable.add(principalRedeemable);\n\n    return _withdraw(trancheInfo, tokenInfo, tokenId, amount);\n  }\n\n  function withdrawMaxMultiple(uint256[] calldata tokenIds) public override {\n    require(tokenIds.length > 0, \"Do not have any element\");\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      withdrawMax(tokenIds[i]);\n    }\n  }\n\n  /**\n   * @notice Draws down the funds (and locks the pool) to the borrower address. Can only be called by the borrower\n   * @param amount The amount to drawdown from the creditline (must be < limit)\n   */\n  function drawdown(uint256 amount) external override onlyLocker whenNotPaused {\n    require(!drawdownsPaused, \"Drawdowns are paused\");\n    if (!locked()) {\n      // Assumes the senior pool has invested already (saves the borrower a separate transaction to lock the pool)\n      _lockPool();\n    }\n    // Drawdown only draws down from the current slice for simplicity. It's harder to account for how much\n    // money is available from previous slices since depositors can redeem after unlock.\n    PoolSlice storage currentSlice = poolSlices[poolSlices.length.sub(1)];\n    uint256 amountAvailable = sharePriceToUsdc(\n      currentSlice.juniorTranche.principalSharePrice,\n      currentSlice.juniorTranche.principalDeposited\n    );\n    amountAvailable = amountAvailable.add(\n      sharePriceToUsdc(currentSlice.seniorTranche.principalSharePrice, currentSlice.seniorTranche.principalDeposited)\n    );\n\n    require(amount <= amountAvailable, \"Insufficient funds in slice\");\n\n    creditLine.drawdown(amount);\n\n    // Update the share price to reflect the amount remaining in the pool\n    uint256 amountRemaining = amountAvailable.sub(amount);\n    uint256 oldJuniorPrincipalSharePrice = currentSlice.juniorTranche.principalSharePrice;\n    uint256 oldSeniorPrincipalSharePrice = currentSlice.seniorTranche.principalSharePrice;\n    currentSlice.juniorTranche.principalSharePrice = currentSlice.juniorTranche.calculateExpectedSharePrice(\n      amountRemaining,\n      currentSlice\n    );\n    currentSlice.seniorTranche.principalSharePrice = currentSlice.seniorTranche.calculateExpectedSharePrice(\n      amountRemaining,\n      currentSlice\n    );\n    currentSlice.principalDeployed = currentSlice.principalDeployed.add(amount);\n    totalDeployed = totalDeployed.add(amount);\n\n    address borrower = creditLine.borrower();\n    safeERC20TransferFrom(config.getUSDC(), address(this), borrower, amount);\n    emit DrawdownMade(borrower, amount);\n    emit SharePriceUpdated(\n      address(this),\n      currentSlice.juniorTranche.id,\n      currentSlice.juniorTranche.principalSharePrice,\n      int256(oldJuniorPrincipalSharePrice.sub(currentSlice.juniorTranche.principalSharePrice)) * -1,\n      currentSlice.juniorTranche.interestSharePrice,\n      0\n    );\n    emit SharePriceUpdated(\n      address(this),\n      currentSlice.seniorTranche.id,\n      currentSlice.seniorTranche.principalSharePrice,\n      int256(oldSeniorPrincipalSharePrice.sub(currentSlice.seniorTranche.principalSharePrice)) * -1,\n      currentSlice.seniorTranche.interestSharePrice,\n      0\n    );\n  }\n\n  /**\n   * @notice Locks the junior tranche, preventing more junior deposits. Gives time for the senior to determine how\n   * much to invest (ensure leverage ratio cannot change for the period)\n   */\n  function lockJuniorCapital() external override onlyLocker whenNotPaused {\n    _lockJuniorCapital(poolSlices.length.sub(1));\n  }\n\n  /**\n   * @notice Locks the pool (locks both senior and junior tranches and starts the drawdown period). Beyond the drawdown\n   * period, any unused capital is available to withdraw by all depositors\n   */\n  function lockPool() external override onlyLocker whenNotPaused {\n    _lockPool();\n  }\n\n  function setFundableAt(uint256 newFundableAt) external override onlyLocker {\n    fundableAt = newFundableAt;\n  }\n\n  function initializeNextSlice(uint256 _fundableAt) external override onlyLocker whenNotPaused {\n    require(locked(), \"Current slice still active\");\n    require(!creditLine.isLate(), \"Creditline is late\");\n    require(creditLine.withinPrincipalGracePeriod(), \"Beyond principal grace period\");\n    _initializeNextSlice(_fundableAt);\n    emit SliceCreated(address(this), poolSlices.length.sub(1));\n  }\n\n  /**\n   * @notice Triggers an assessment of the creditline and the applies the payments according the tranche waterfall\n   */\n  function assess() external override whenNotPaused {\n    _assess();\n  }\n\n  /**\n   * @notice Allows repaying the creditline. Collects the USDC amount from the sender and triggers an assess\n   * @param amount The amount to repay\n   */\n  function pay(uint256 amount) external override whenNotPaused {\n    require(amount > 0, \"Must pay more than zero\");\n    collectPayment(amount);\n    _assess();\n  }\n\n  // /**\n  //  * @notice Migrates to a new Doberman config address\n  //  */\n  // function updateDobermanConfig() external onlyAdmin {\n  //   config = DobermanConfig(config.configAddress());\n  //   creditLine.updateDobermanConfig();\n  //   emit DobermanConfigUpdated(msg.sender, address(config));\n  // }\n\n  /**\n   * @notice Pauses the pool and sweeps any remaining funds to the treasury reserve.\n   */\n  function emergencyShutdown() public onlyAdmin {\n    if (!paused()) {\n      pause();\n    }\n\n    IERC20withDec usdc = config.getUSDC();\n    address reserveAddress = config.reserveAddress();\n    // Sweep any funds to community reserve\n    uint256 poolBalance = usdc.balanceOf(address(this));\n    if (poolBalance > 0) {\n      safeERC20Transfer(usdc, reserveAddress, poolBalance);\n    }\n\n    uint256 clBalance = usdc.balanceOf(address(creditLine));\n    if (clBalance > 0) {\n      safeERC20TransferFrom(usdc, address(creditLine), reserveAddress, clBalance);\n    }\n    emit EmergencyShutdown(address(this));\n  }\n\n  /**\n   * @notice Pauses all drawdowns (but not deposits/withdraws)\n   */\n  function pauseDrawdowns() public onlyAdmin {\n    drawdownsPaused = true;\n    emit DrawdownsPaused(address(this));\n  }\n\n  /**\n   * @notice Unpause drawdowns\n   */\n  function unpauseDrawdowns() public onlyAdmin {\n    drawdownsPaused = false;\n    emit DrawdownsUnpaused(address(this));\n  }\n\n  /**\n   * @notice Migrates the accounting variables from the current creditline to a brand new one\n   * @param _borrower The borrower address\n   * @param _maxLimit The new max limit\n   * @param _interestApr The new interest APR\n   * @param _paymentPeriodInDays The new payment period in days\n   * @param _termInDays The new term in days\n   * @param _lateFeeApr The new late fee APR\n   */\n  function migrateCreditLine(\n    address _borrower,\n    uint256 _maxLimit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) public onlyAdmin {\n    require(_borrower != address(0), \"Borrower must not be empty\");\n    require(_paymentPeriodInDays != 0, \"Payment period invalid\");\n    require(_termInDays != 0, \"Term must not be empty\");\n\n    address originalClAddr = address(creditLine);\n\n    createAndSetCreditLine(\n      _borrower,\n      _maxLimit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n\n    address newClAddr = address(creditLine);\n    TranchingLogic.migrateAccountingVariables(originalClAddr, newClAddr);\n    TranchingLogic.closeCreditLine(originalClAddr);\n    address originalBorrower = IV2CreditLine(originalClAddr).borrower();\n    address newBorrower = IV2CreditLine(newClAddr).borrower();\n    // Ensure Roles\n    if (originalBorrower != newBorrower) {\n      revokeRole(LOCKER_ROLE, originalBorrower);\n      grantRole(LOCKER_ROLE, newBorrower);\n    }\n    // Transfer any funds to new CL\n    uint256 clBalance = config.getUSDC().balanceOf(originalClAddr);\n    if (clBalance > 0) {\n      safeERC20TransferFrom(config.getUSDC(), originalClAddr, newClAddr, clBalance);\n    }\n    emit CreditLineMigrated(originalClAddr, newClAddr);\n  }\n\n  /**\n   * @notice Migrates to a new creditline without copying the accounting variables\n   */\n  function migrateAndSetNewCreditLine(address newCl) public onlyAdmin {\n    require(newCl != address(0), \"Creditline cannot be empty\");\n    address originalClAddr = address(creditLine);\n    // Transfer any funds to new CL\n    uint256 clBalance = config.getUSDC().balanceOf(originalClAddr);\n    if (clBalance > 0) {\n      safeERC20TransferFrom(config.getUSDC(), originalClAddr, newCl, clBalance);\n    }\n    TranchingLogic.closeCreditLine(originalClAddr);\n    // set new CL\n    creditLine = IV2CreditLine(newCl);\n    // sanity check that the new address is in fact a creditline\n    creditLine.limit();\n\n    emit CreditLineMigrated(originalClAddr, address(creditLine));\n  }\n\n  // CreditLine proxy method\n  function setLimit(uint256 newAmount) external onlyAdmin {\n    return creditLine.setLimit(newAmount);\n  }\n\n  function setMaxLimit(uint256 newAmount) external onlyAdmin {\n    return creditLine.setMaxLimit(newAmount);\n  }\n\n  function getTranche(uint256 tranche) public view override returns (TrancheInfo memory) {\n    return getTrancheInfo(tranche);\n  }\n\n  function numSlices() public view returns (uint256) {\n    return poolSlices.length;\n  }\n\n  /**\n   * @notice Converts USDC amounts to share price\n   * @param amount The USDC amount to convert\n   * @param totalShares The total shares outstanding\n   * @return The share price of the input amount\n   */\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\n    return TranchingLogic.usdcToSharePrice(amount, totalShares);\n  }\n\n  /**\n   * @notice Converts share price to USDC amounts\n   * @param sharePrice The share price to convert\n   * @param totalShares The total shares outstanding\n   * @return The USDC amount of the input share price\n   */\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\n    return TranchingLogic.sharePriceToUsdc(sharePrice, totalShares);\n  }\n\n  /**\n   * @notice Returns the total junior capital deposited\n   * @return The total USDC amount deposited into all junior tranches\n   */\n  function totalJuniorDeposits() external view override returns (uint256) {\n    uint256 total;\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      total = total.add(poolSlices[i].juniorTranche.principalDeposited);\n    }\n    return total;\n  }\n\n  /**\n   * @notice Determines the amount of interest and principal redeemable by a particular tokenId\n   * @param tokenId The token representing the position\n   * @return interestRedeemable The interest available to redeem\n   * @return principalRedeemable The principal available to redeem\n   */\n  function availableToWithdraw(uint256 tokenId)\n    public\n    view\n    override\n    returns (uint256 interestRedeemable, uint256 principalRedeemable)\n  {\n    IPoolTokens.TokenInfo memory tokenInfo = config.getPoolTokens().getTokenInfo(tokenId);\n    TrancheInfo storage trancheInfo = getTrancheInfo(tokenInfo.tranche);\n\n    if (currentTime() > trancheInfo.lockedUntil) {\n      return redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n    } else {\n      return (0, 0);\n    }\n  }\n\n  function availableToWithdrawMultiple(uint256[] calldata tokenIds)\n    external\n    view\n    returns (uint256 interestRedeemableTotal, uint256 principalRedeemableTotal)\n  {\n    require(tokenIds.length > 0, \"Do not have any element\");\n\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      (uint256 interestRedeemable, uint256 principalRedeemable) = availableToWithdraw(tokenIds[i]);\n      interestRedeemableTotal += interestRedeemable;\n      principalRedeemableTotal += principalRedeemable;\n    }\n\n    return (interestRedeemableTotal, principalRedeemableTotal);\n  }\n\n  /* Internal functions  */\n\n  function _withdraw(\n    TrancheInfo storage trancheInfo,\n    IPoolTokens.TokenInfo memory tokenInfo,\n    uint256 tokenId,\n    uint256 amount\n  ) internal returns (uint256 interestWithdrawn, uint256 principalWithdrawn) {\n    require(config.getPoolTokens().isApprovedOrOwner(msg.sender, tokenId), \"Not token owner\");\n    require(config.getGo().goOnlyIdTypes(msg.sender, allowedUIDTypes), \"Address not go-listed\");\n    require(amount > 0, \"Must withdraw more than zero\");\n    (uint256 interestRedeemable, uint256 principalRedeemable) = redeemableInterestAndPrincipal(trancheInfo, tokenInfo);\n    uint256 netRedeemable = interestRedeemable.add(principalRedeemable);\n\n    require(amount <= netRedeemable, \"Invalid redeem amount\");\n    require(currentTime() > trancheInfo.lockedUntil, \"Tranche is locked\");\n\n    // If the tranche has not been locked, ensure the deposited amount is correct\n    if (trancheInfo.lockedUntil == 0) {\n      trancheInfo.principalDeposited = trancheInfo.principalDeposited.sub(amount);\n    }\n\n    uint256 interestToRedeem = Math.min(interestRedeemable, amount);\n    uint256 principalToRedeem = Math.min(principalRedeemable, amount.sub(interestToRedeem));\n\n    config.getPoolTokens().redeem(tokenId, principalToRedeem, interestToRedeem);\n    safeERC20TransferFrom(config.getUSDC(), address(this), msg.sender, principalToRedeem.add(interestToRedeem));\n\n    emit WithdrawalMade(msg.sender, tokenInfo.tranche, tokenId, interestToRedeem, principalToRedeem);\n\n    return (interestToRedeem, principalToRedeem);\n  }\n\n  function _isSeniorTrancheId(uint256 trancheId) internal pure returns (bool) {\n    return trancheId.mod(NUM_TRANCHES_PER_SLICE) == 1;\n  }\n\n  function redeemableInterestAndPrincipal(TrancheInfo storage trancheInfo, IPoolTokens.TokenInfo memory tokenInfo)\n    internal\n    view\n    returns (uint256 interestRedeemable, uint256 principalRedeemable)\n  {\n    // This supports withdrawing before or after locking because principal share price starts at 1\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\n\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\n\n    return (interestRedeemable, principalRedeemable);\n  }\n\n  function _lockJuniorCapital(uint256 sliceId) internal {\n    require(!locked(), \"Pool already locked\");\n    require(poolSlices[sliceId].juniorTranche.lockedUntil == 0, \"Junior tranche already locked\");\n\n    uint256 lockedUntil = currentTime().add(config.getDrawdownPeriodInSeconds());\n    poolSlices[sliceId].juniorTranche.lockedUntil = lockedUntil;\n\n    emit TrancheLocked(address(this), poolSlices[sliceId].juniorTranche.id, lockedUntil);\n  }\n\n  function _lockPool() internal {\n    uint256 sliceId = poolSlices.length.sub(1);\n\n    require(poolSlices[sliceId].juniorTranche.lockedUntil > 0, \"Junior tranche must be locked\");\n    // Allow locking the pool only once; do not allow extending the lock of an\n    // already-locked pool. Otherwise the locker could keep the pool locked\n    // indefinitely, preventing withdrawals.\n    require(poolSlices[sliceId].seniorTranche.lockedUntil == 0, \"Lock cannot be extended\");\n\n    uint256 currentTotal = poolSlices[sliceId].juniorTranche.principalDeposited.add(\n      poolSlices[sliceId].seniorTranche.principalDeposited\n    );\n    creditLine.setLimit(Math.min(creditLine.limit().add(currentTotal), creditLine.maxLimit()));\n\n    // We start the drawdown period, so backers can withdraw unused capital after borrower draws down\n    uint256 lockPeriod = config.getDrawdownPeriodInSeconds();\n    poolSlices[sliceId].seniorTranche.lockedUntil = currentTime().add(lockPeriod);\n    poolSlices[sliceId].juniorTranche.lockedUntil = currentTime().add(lockPeriod);\n    emit TrancheLocked(\n      address(this),\n      poolSlices[sliceId].seniorTranche.id,\n      poolSlices[sliceId].seniorTranche.lockedUntil\n    );\n    emit TrancheLocked(\n      address(this),\n      poolSlices[sliceId].juniorTranche.id,\n      poolSlices[sliceId].juniorTranche.lockedUntil\n    );\n  }\n\n  function _initializeNextSlice(uint256 newFundableAt) internal {\n    uint256 numSlices = poolSlices.length;\n    require(numSlices < 5, \"Cannot exceed 5 slices\");\n    poolSlices.push(\n      PoolSlice({\n        seniorTranche: TrancheInfo({\n          id: numSlices.mul(NUM_TRANCHES_PER_SLICE).add(1),\n          principalSharePrice: usdcToSharePrice(1, 1),\n          interestSharePrice: 0,\n          principalDeposited: 0,\n          lockedUntil: 0\n        }),\n        juniorTranche: TrancheInfo({\n          id: numSlices.mul(NUM_TRANCHES_PER_SLICE).add(2),\n          principalSharePrice: usdcToSharePrice(1, 1),\n          interestSharePrice: 0,\n          principalDeposited: 0,\n          lockedUntil: 0\n        }),\n        totalInterestAccrued: 0,\n        principalDeployed: 0\n      })\n    );\n    fundableAt = newFundableAt;\n  }\n\n  function collectInterestAndPrincipal(\n    address from,\n    uint256 interest,\n    uint256 principal\n  ) internal returns (uint256 totalReserveAmount) {\n    safeERC20TransferFrom(config.getUSDC(), from, address(this), principal.add(interest), \"Failed to collect payment\");\n    uint256 reserveFeePercent = ONE_HUNDRED.div(config.getReserveDenominator()); // Convert the denonminator to percent\n\n    ApplyResult memory result = TranchingLogic.applyToAllSeniorTranches(\n      poolSlices,\n      interest,\n      principal,\n      reserveFeePercent,\n      totalDeployed,\n      creditLine,\n      juniorFeePercent\n    );\n\n    totalReserveAmount = result.reserveDeduction.add(\n      TranchingLogic.applyToAllJuniorTranches(\n        poolSlices,\n        result.interestRemaining,\n        result.principalRemaining,\n        reserveFeePercent,\n        totalDeployed,\n        creditLine\n      )\n    );\n\n    sendToReserve(totalReserveAmount);\n\n    sendToSeniorPool(interest - result.interestRemaining, principal - result.principalRemaining);\n\n    return totalReserveAmount;\n  }\n\n  // If the senior tranche of the current slice is locked, then the pool is not open to any more deposits\n  // (could throw off leverage ratio)\n  function locked() internal view returns (bool) {\n    return poolSlices[poolSlices.length.sub(1)].seniorTranche.lockedUntil > 0;\n  }\n\n  function createAndSetCreditLine(\n    address _borrower,\n    uint256 _maxLimit,\n    uint256 _interestApr,\n    uint256 _paymentPeriodInDays,\n    uint256 _termInDays,\n    uint256 _lateFeeApr,\n    uint256 _principalGracePeriodInDays\n  ) internal {\n    address _creditLine = config.getDobermanFactory().createCreditLine();\n    creditLine = IV2CreditLine(_creditLine);\n    creditLine.initialize(\n      address(config),\n      address(this), // Set self as the owner\n      _borrower,\n      _maxLimit,\n      _interestApr,\n      _paymentPeriodInDays,\n      _termInDays,\n      _lateFeeApr,\n      _principalGracePeriodInDays\n    );\n  }\n\n  function getTrancheInfo(uint256 trancheId) internal view returns (TrancheInfo storage) {\n    require(trancheId > 0 && trancheId <= poolSlices.length.mul(NUM_TRANCHES_PER_SLICE), \"Unsupported tranche\");\n    uint256 sliceId = ((trancheId.add(trancheId.mod(NUM_TRANCHES_PER_SLICE))).div(NUM_TRANCHES_PER_SLICE)).sub(1);\n    PoolSlice storage slice = poolSlices[sliceId];\n    TrancheInfo storage trancheInfo = trancheId.mod(NUM_TRANCHES_PER_SLICE) == 1\n      ? slice.seniorTranche\n      : slice.juniorTranche;\n    return trancheInfo;\n  }\n\n  function currentTime() internal view virtual returns (uint256) {\n    return block.timestamp;\n  }\n\n  function sendToReserve(uint256 amount) internal {\n    emit ReserveFundsCollected(address(this), amount);\n    safeERC20TransferFrom(\n      config.getUSDC(),\n      address(this),\n      config.reserveAddress(),\n      amount,\n      \"Failed to send to reserve\"\n    );\n  }\n\n  function sendToSeniorPool(uint256 interest, uint256 principal) internal {\n    uint256 totalAmount = interest + principal;\n    address seniorPool = config.seniorPoolAddress();\n    emit SeniorPoolFundsCollected(address(this), totalAmount);\n\n    safeERC20TransferFrom(\n      config.getUSDC(),\n      address(this),\n      seniorPool,\n      totalAmount,\n      \"Failed to send to senior pool\"\n    );\n\n    (bool success, ) = seniorPool.call(\n        abi.encodeWithSignature(\"collectInterestAndPrincipal(uint256,uint256)\", interest, principal)\n    );\n\n    require(success, 'Fail to collect from senior pool');\n  }\n\n  function collectPayment(uint256 amount) internal {\n    safeERC20TransferFrom(config.getUSDC(), msg.sender, address(creditLine), amount, \"Failed to collect payment\");\n  }\n\n  function _assess() internal {\n    // We need to make sure the pool is locked before we allocate rewards to ensure it's not\n    // possible to game rewards by sandwiching an interest payment to an unlocked pool\n    // It also causes issues trying to allocate payments to an empty slice (divide by zero)\n    require(locked(), \"Pool is not locked\");\n\n    uint256 interestAccrued = creditLine.totalInterestAccrued();\n    (uint256 paymentRemaining, uint256 interestPayment, uint256 principalPayment) = creditLine.assess();\n    interestAccrued = creditLine.totalInterestAccrued().sub(interestAccrued);\n\n    // Split the interest accrued proportionally across slices so we know how much interest goes to each slice\n    // We need this because the slice start at different times, so we cannot retroactively allocate the interest\n    // linearly\n    uint256[] memory principalPaymentsPerSlice = new uint256[](poolSlices.length);\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      uint256 interestForSlice = TranchingLogic.scaleByFraction(\n        interestAccrued,\n        poolSlices[i].principalDeployed,\n        totalDeployed\n      );\n      principalPaymentsPerSlice[i] = TranchingLogic.scaleByFraction(\n        principalPayment,\n        poolSlices[i].principalDeployed,\n        totalDeployed\n      );\n      poolSlices[i].totalInterestAccrued = poolSlices[i].totalInterestAccrued.add(interestForSlice);\n    }\n\n    if (interestPayment > 0 || principalPayment > 0) {\n      uint256 reserveAmount = collectInterestAndPrincipal(\n        address(creditLine),\n        interestPayment,\n        principalPayment.add(paymentRemaining)\n      );\n\n      for (uint256 i = 0; i < poolSlices.length; i++) {\n        poolSlices[i].principalDeployed = poolSlices[i].principalDeployed.sub(principalPaymentsPerSlice[i]);\n        totalDeployed = totalDeployed.sub(principalPaymentsPerSlice[i]);\n      }\n\n      config.getBackerRewards().allocateRewards(interestPayment);\n\n      emit PaymentApplied(\n        creditLine.borrower(),\n        address(this),\n        interestPayment,\n        principalPayment,\n        paymentRemaining,\n        reserveAmount\n      );\n    }\n    emit TranchedPoolAssessed(address(this));\n  }\n\n  modifier onlyLocker() {\n    require(hasRole(LOCKER_ROLE, msg.sender), \"Must have locker role\");\n    _;\n  }\n}\n"
    },
    "contracts/protocol/core/TranchingLogic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nimport \"../../interfaces/IV2CreditLine.sol\";\nimport \"../../interfaces/ITranchedPool.sol\";\nimport \"../../interfaces/IPoolTokens.sol\";\nimport \"../../external/FixedPoint.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n/**\n * @title TranchingLogic\n * @notice Library for handling the payments waterfall\n * @author Doberman\n */\n\nlibrary TranchingLogic {\n  using SafeMath for uint256;\n  using FixedPoint for FixedPoint.Unsigned;\n  using FixedPoint for uint256;\n\n  event SharePriceUpdated(\n    address indexed pool,\n    uint256 indexed tranche,\n    uint256 principalSharePrice,\n    int256 principalDelta,\n    uint256 interestSharePrice,\n    int256 interestDelta\n  );\n\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\n\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\n    return totalShares == 0 ? 0 : amount.mul(FP_SCALING_FACTOR).div(totalShares);\n  }\n\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\n    return sharePrice.mul(totalShares).div(FP_SCALING_FACTOR);\n  }\n\n  function redeemableInterestAndPrincipal(\n    ITranchedPool.TrancheInfo storage trancheInfo,\n    IPoolTokens.TokenInfo memory tokenInfo\n  ) public view returns (uint256 interestRedeemable, uint256 principalRedeemable) {\n    // This supports withdrawing before or after locking because principal share price starts at 1\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\n\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\n\n    return (interestRedeemable, principalRedeemable);\n  }\n\n  function calculateExpectedSharePrice(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 sharePrice = usdcToSharePrice(amount, tranche.principalDeposited);\n    return scaleByPercentOwnership(tranche, sharePrice, slice);\n  }\n\n  function scaleForSlice(\n    ITranchedPool.PoolSlice memory slice,\n    uint256 amount,\n    uint256 totalDeployed\n  ) public pure returns (uint256) {\n    return scaleByFraction(amount, slice.principalDeployed, totalDeployed);\n  }\n\n  // We need to create this struct so we don't run into a stack too deep error due to too many variables\n  function getSliceInfo(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed,\n    uint256 reserveFeePercent\n  ) public view returns (ITranchedPool.SliceInfo memory) {\n    (uint256 interestAccrued, uint256 principalAccrued) = getTotalInterestAndPrincipal(\n      slice,\n      creditLine,\n      totalDeployed\n    );\n    return\n      ITranchedPool.SliceInfo({\n        reserveFeePercent: reserveFeePercent,\n        interestAccrued: interestAccrued,\n        principalAccrued: principalAccrued\n      });\n  }\n\n  function getTotalInterestAndPrincipal(\n    ITranchedPool.PoolSlice memory slice,\n    IV2CreditLine creditLine,\n    uint256 totalDeployed\n  ) public view returns (uint256 interestAccrued, uint256 principalAccrued) {\n    principalAccrued = creditLine.principalOwed();\n    // In addition to principal actually owed, we need to account for early principal payments\n    // If the borrower pays back 5K early on a 10K loan, the actual principal accrued should be\n    // 5K (balance- deployed) + 0 (principal owed)\n    principalAccrued = totalDeployed.sub(creditLine.balance()).add(principalAccrued);\n    // Now we need to scale that correctly for the slice we're interested in\n    principalAccrued = scaleForSlice(slice, principalAccrued, totalDeployed);\n    // Finally, we need to account for partial drawdowns. e.g. If 20K was deposited, and only 10K was drawn down,\n    // Then principal accrued should start at 10K (total deposited - principal deployed), not 0. This is because\n    // share price starts at 1, and is decremented by what was drawn down.\n    uint256 totalDeposited = slice.seniorTranche.principalDeposited.add(slice.juniorTranche.principalDeposited);\n    principalAccrued = totalDeposited.sub(slice.principalDeployed).add(principalAccrued);\n    return (slice.totalInterestAccrued, principalAccrued);\n  }\n\n  function scaleByFraction(\n    uint256 amount,\n    uint256 fraction,\n    uint256 total\n  ) public pure returns (uint256) {\n    FixedPoint.Unsigned memory totalAsFixedPoint = FixedPoint.fromUnscaledUint(total);\n    FixedPoint.Unsigned memory fractionAsFixedPoint = FixedPoint.fromUnscaledUint(fraction);\n    return fractionAsFixedPoint.div(totalAsFixedPoint).mul(amount).div(FP_SCALING_FACTOR).rawValue;\n  }\n\n  function applyToAllSeniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine,\n    uint256 juniorFeePercent\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    ITranchedPool.ApplyResult memory seniorApplyResult;\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n\n      // Since slices cannot be created when the loan is late, all interest collected can be assumed to split\n      // pro-rata across the slices. So we scale the interest and principal to the slice\n      ITranchedPool.ApplyResult memory applyResult = applyToSeniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        juniorFeePercent,\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].seniorTranche, applyResult);\n      seniorApplyResult.interestRemaining = seniorApplyResult.interestRemaining.add(applyResult.interestRemaining);\n      seniorApplyResult.principalRemaining = seniorApplyResult.principalRemaining.add(applyResult.principalRemaining);\n      seniorApplyResult.reserveDeduction = seniorApplyResult.reserveDeduction.add(applyResult.reserveDeduction);\n    }\n    return seniorApplyResult;\n  }\n\n  function applyToAllJuniorTranches(\n    ITranchedPool.PoolSlice[] storage poolSlices,\n    uint256 interest,\n    uint256 principal,\n    uint256 reserveFeePercent,\n    uint256 totalDeployed,\n    IV2CreditLine creditLine\n  ) public returns (uint256 totalReserveAmount) {\n    for (uint256 i = 0; i < poolSlices.length; i++) {\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\n        poolSlices[i],\n        creditLine,\n        totalDeployed,\n        reserveFeePercent\n      );\n      // Any remaining interest and principal is then shared pro-rata with the junior slices\n      ITranchedPool.ApplyResult memory applyResult = applyToJuniorTranche(\n        poolSlices[i],\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\n        sliceInfo\n      );\n      emitSharePriceUpdatedEvent(poolSlices[i].juniorTranche, applyResult);\n      totalReserveAmount = totalReserveAmount.add(applyResult.reserveDeduction);\n    }\n    return totalReserveAmount;\n  }\n\n  function emitSharePriceUpdatedEvent(\n    ITranchedPool.TrancheInfo memory tranche,\n    ITranchedPool.ApplyResult memory applyResult\n  ) internal {\n    emit SharePriceUpdated(\n      address(this),\n      tranche.id,\n      tranche.principalSharePrice,\n      int256(tranche.principalSharePrice.sub(applyResult.oldPrincipalSharePrice)),\n      tranche.interestSharePrice,\n      int256(tranche.interestSharePrice.sub(applyResult.oldInterestSharePrice))\n    );\n  }\n\n  function applyToSeniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 juniorFeePercent,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // First determine the expected share price for the senior tranche. This is the gross amount the senior\n    // tranche should receive.\n    uint256 expectedInterestSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.interestAccrued,\n      slice\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.seniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n\n    // Deduct the junior fee and the protocol reserve\n    uint256 desiredNetInterestSharePrice = scaleByFraction(\n      expectedInterestSharePrice,\n      ONE_HUNDRED.sub(juniorFeePercent.add(sliceInfo.reserveFeePercent)),\n      ONE_HUNDRED\n    );\n    // Collect protocol fee interest received (we've subtracted this from the senior portion above)\n    uint256 reserveDeduction = scaleByFraction(interestRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    uint256 oldInterestSharePrice = slice.seniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.seniorTranche.principalSharePrice;\n    // Apply the interest remaining so we get up to the netInterestSharePrice\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.seniorTranche,\n      interestRemaining,\n      principalRemaining,\n      desiredNetInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyToJuniorTranche(\n    ITranchedPool.PoolSlice storage slice,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    ITranchedPool.SliceInfo memory sliceInfo\n  ) public returns (ITranchedPool.ApplyResult memory) {\n    // Then fill up the junior tranche with all the interest remaining, upto the principal share price\n    uint256 expectedInterestSharePrice = slice.juniorTranche.interestSharePrice.add(\n      usdcToSharePrice(interestRemaining, slice.juniorTranche.principalDeposited)\n    );\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\n      slice.juniorTranche,\n      sliceInfo.principalAccrued,\n      slice\n    );\n    uint256 oldInterestSharePrice = slice.juniorTranche.interestSharePrice;\n    uint256 oldPrincipalSharePrice = slice.juniorTranche.principalSharePrice;\n    (interestRemaining, principalRemaining) = applyBySharePrice(\n      slice.juniorTranche,\n      interestRemaining,\n      principalRemaining,\n      expectedInterestSharePrice,\n      expectedPrincipalSharePrice\n    );\n\n    // All remaining interest and principal is applied towards the junior tranche as interest\n    interestRemaining = interestRemaining.add(principalRemaining);\n    // Since any principal remaining is treated as interest (there is \"extra\" interest to be distributed)\n    // we need to make sure to collect the protocol fee on the additional interest (we only deducted the\n    // fee on the original interest portion)\n    uint256 reserveDeduction = scaleByFraction(principalRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\n    interestRemaining = interestRemaining.sub(reserveDeduction);\n    principalRemaining = 0;\n\n    (interestRemaining, principalRemaining) = applyByAmount(\n      slice.juniorTranche,\n      interestRemaining.add(principalRemaining),\n      0,\n      interestRemaining.add(principalRemaining),\n      0\n    );\n    return\n      ITranchedPool.ApplyResult({\n        interestRemaining: interestRemaining,\n        principalRemaining: principalRemaining,\n        reserveDeduction: reserveDeduction,\n        oldInterestSharePrice: oldInterestSharePrice,\n        oldPrincipalSharePrice: oldPrincipalSharePrice\n      });\n  }\n\n  function applyBySharePrice(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestSharePrice,\n    uint256 desiredPrincipalSharePrice\n  ) public returns (uint256, uint256) {\n    uint256 desiredInterestAmount = desiredAmountFromSharePrice(\n      desiredInterestSharePrice,\n      tranche.interestSharePrice,\n      tranche.principalDeposited\n    );\n    uint256 desiredPrincipalAmount = desiredAmountFromSharePrice(\n      desiredPrincipalSharePrice,\n      tranche.principalSharePrice,\n      tranche.principalDeposited\n    );\n    return applyByAmount(tranche, interestRemaining, principalRemaining, desiredInterestAmount, desiredPrincipalAmount);\n  }\n\n  function applyByAmount(\n    ITranchedPool.TrancheInfo storage tranche,\n    uint256 interestRemaining,\n    uint256 principalRemaining,\n    uint256 desiredInterestAmount,\n    uint256 desiredPrincipalAmount\n  ) public returns (uint256, uint256) {\n    uint256 totalShares = tranche.principalDeposited;\n    uint256 newSharePrice;\n\n    (interestRemaining, newSharePrice) = applyToSharePrice(\n      interestRemaining,\n      tranche.interestSharePrice,\n      desiredInterestAmount,\n      totalShares\n    );\n    tranche.interestSharePrice = newSharePrice;\n\n    (principalRemaining, newSharePrice) = applyToSharePrice(\n      principalRemaining,\n      tranche.principalSharePrice,\n      desiredPrincipalAmount,\n      totalShares\n    );\n    tranche.principalSharePrice = newSharePrice;\n    return (interestRemaining, principalRemaining);\n  }\n\n  function migrateAccountingVariables(address originalClAddr, address newClAddr) public {\n    IV2CreditLine originalCl = IV2CreditLine(originalClAddr);\n    IV2CreditLine newCl = IV2CreditLine(newClAddr);\n\n    // Copy over all accounting variables\n    newCl.setBalance(originalCl.balance());\n    newCl.setLimit(originalCl.limit());\n    newCl.setInterestOwed(originalCl.interestOwed());\n    newCl.setPrincipalOwed(originalCl.principalOwed());\n    newCl.setTermEndTime(originalCl.termEndTime());\n    newCl.setNextDueTime(originalCl.nextDueTime());\n    newCl.setInterestAccruedAsOf(originalCl.interestAccruedAsOf());\n    newCl.setLastFullPaymentTime(originalCl.lastFullPaymentTime());\n    newCl.setTotalInterestAccrued(originalCl.totalInterestAccrued());\n  }\n\n  function closeCreditLine(address originalCl) public {\n    // Close out old CL\n    IV2CreditLine oldCreditLine = IV2CreditLine(originalCl);\n    oldCreditLine.setBalance(0);\n    oldCreditLine.setLimit(0);\n    oldCreditLine.setMaxLimit(0);\n  }\n\n  function desiredAmountFromSharePrice(\n    uint256 desiredSharePrice,\n    uint256 actualSharePrice,\n    uint256 totalShares\n  ) public pure returns (uint256) {\n    // If the desired share price is lower, then ignore it, and leave it unchanged\n    if (desiredSharePrice < actualSharePrice) {\n      desiredSharePrice = actualSharePrice;\n    }\n    uint256 sharePriceDifference = desiredSharePrice.sub(actualSharePrice);\n    return sharePriceToUsdc(sharePriceDifference, totalShares);\n  }\n\n  function applyToSharePrice(\n    uint256 amountRemaining,\n    uint256 currentSharePrice,\n    uint256 desiredAmount,\n    uint256 totalShares\n  ) public pure returns (uint256, uint256) {\n    // If no money left to apply, or don't need any changes, return the original amounts\n    if (amountRemaining == 0 || desiredAmount == 0) {\n      return (amountRemaining, currentSharePrice);\n    }\n    if (amountRemaining < desiredAmount) {\n      // We don't have enough money to adjust share price to the desired level. So just use whatever amount is left\n      desiredAmount = amountRemaining;\n    }\n    uint256 sharePriceDifference = usdcToSharePrice(desiredAmount, totalShares);\n    return (amountRemaining.sub(desiredAmount), currentSharePrice.add(sharePriceDifference));\n  }\n\n  function scaleByPercentOwnership(\n    ITranchedPool.TrancheInfo memory tranche,\n    uint256 amount,\n    ITranchedPool.PoolSlice memory slice\n  ) public pure returns (uint256) {\n    uint256 totalDeposited = slice.juniorTranche.principalDeposited.add(slice.seniorTranche.principalDeposited);\n    return scaleByFraction(amount, tranche.principalDeposited, totalDeposited);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}