{
  "address": "0x140663331008d3a803cF44b9bE1AfE1cc4D6575c",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tranche",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "principalSharePrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "principalDelta",
          "type": "int256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "interestSharePrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "interestDelta",
          "type": "int256"
        }
      ],
      "name": "SharePriceUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FP_SCALING_FACTOR",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ONE_HUNDRED",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amountRemaining",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentSharePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "desiredAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalShares",
          "type": "uint256"
        }
      ],
      "name": "applyToSharePrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeposited",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalSharePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestSharePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lockedUntil",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.TrancheInfo",
          "name": "tranche",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "seniorTranche",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "juniorTranche",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "totalInterestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeployed",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.PoolSlice",
          "name": "slice",
          "type": "tuple"
        }
      ],
      "name": "calculateExpectedSharePrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "desiredSharePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actualSharePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalShares",
          "type": "uint256"
        }
      ],
      "name": "desiredAmountFromSharePrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "seniorTranche",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "juniorTranche",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "totalInterestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeployed",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.PoolSlice",
          "name": "slice",
          "type": "tuple"
        },
        {
          "internalType": "contract IV2CreditLine",
          "name": "creditLine",
          "type": "IV2CreditLine"
        },
        {
          "internalType": "uint256",
          "name": "totalDeployed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "reserveFeePercent",
          "type": "uint256"
        }
      ],
      "name": "getSliceInfo",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "reserveFeePercent",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalAccrued",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.SliceInfo",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "seniorTranche",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "juniorTranche",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "totalInterestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeployed",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.PoolSlice",
          "name": "slice",
          "type": "tuple"
        },
        {
          "internalType": "contract IV2CreditLine",
          "name": "creditLine",
          "type": "IV2CreditLine"
        },
        {
          "internalType": "uint256",
          "name": "totalDeployed",
          "type": "uint256"
        }
      ],
      "name": "getTotalInterestAndPrincipal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "interestAccrued",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "principalAccrued",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fraction",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "name": "scaleByFraction",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "id",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeposited",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalSharePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "interestSharePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lockedUntil",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.TrancheInfo",
          "name": "tranche",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "seniorTranche",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "juniorTranche",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "totalInterestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeployed",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.PoolSlice",
          "name": "slice",
          "type": "tuple"
        }
      ],
      "name": "scaleByPercentOwnership",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "seniorTranche",
              "type": "tuple"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "id",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalDeposited",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "principalSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "interestSharePrice",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "lockedUntil",
                  "type": "uint256"
                }
              ],
              "internalType": "struct ITranchedPool.TrancheInfo",
              "name": "juniorTranche",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "totalInterestAccrued",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "principalDeployed",
              "type": "uint256"
            }
          ],
          "internalType": "struct ITranchedPool.PoolSlice",
          "name": "slice",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalDeployed",
          "type": "uint256"
        }
      ],
      "name": "scaleForSlice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "sharePrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalShares",
          "type": "uint256"
        }
      ],
      "name": "sharePriceToUsdc",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalShares",
          "type": "uint256"
        }
      ],
      "name": "usdcToSharePrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x45237115f87e401bd4568122b6515241a2f07790947306623c4e41bacfd7a0f4",
  "receipt": {
    "to": null,
    "from": "0x9460b481366b7462af4f7991d430e5eB97FAAEB5",
    "contractAddress": "0x140663331008d3a803cF44b9bE1AfE1cc4D6575c",
    "transactionIndex": 17,
    "gasUsed": "2045483",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9fe5b566122f0af73bf257c06ae90e8ac4b8363f05865eb7d90e2cf928bc6892",
    "transactionHash": "0x45237115f87e401bd4568122b6515241a2f07790947306623c4e41bacfd7a0f4",
    "logs": [],
    "blockNumber": 3588375,
    "cumulativeGasUsed": "8885243",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ae210064203e836f7b382a4941e267e0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tranche\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"principalDelta\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"interestDelta\",\"type\":\"int256\"}],\"name\":\"SharePriceUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FP_SCALING_FACTOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desiredAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"applyToSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"tranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"seniorTranche\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"juniorTranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeployed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.PoolSlice\",\"name\":\"slice\",\"type\":\"tuple\"}],\"name\":\"calculateExpectedSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"desiredSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"desiredAmountFromSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"seniorTranche\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"juniorTranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeployed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.PoolSlice\",\"name\":\"slice\",\"type\":\"tuple\"},{\"internalType\":\"contract IV2CreditLine\",\"name\":\"creditLine\",\"type\":\"IV2CreditLine\"},{\"internalType\":\"uint256\",\"name\":\"totalDeployed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFeePercent\",\"type\":\"uint256\"}],\"name\":\"getSliceInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"reserveFeePercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalAccrued\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.SliceInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"seniorTranche\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"juniorTranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeployed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.PoolSlice\",\"name\":\"slice\",\"type\":\"tuple\"},{\"internalType\":\"contract IV2CreditLine\",\"name\":\"creditLine\",\"type\":\"IV2CreditLine\"},{\"internalType\":\"uint256\",\"name\":\"totalDeployed\",\"type\":\"uint256\"}],\"name\":\"getTotalInterestAndPrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"interestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalAccrued\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fraction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"scaleByFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"tranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"seniorTranche\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"juniorTranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeployed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.PoolSlice\",\"name\":\"slice\",\"type\":\"tuple\"}],\"name\":\"scaleByPercentOwnership\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"seniorTranche\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockedUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.TrancheInfo\",\"name\":\"juniorTranche\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalInterestAccrued\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principalDeployed\",\"type\":\"uint256\"}],\"internalType\":\"struct ITranchedPool.PoolSlice\",\"name\":\"slice\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeployed\",\"type\":\"uint256\"}],\"name\":\"scaleForSlice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"sharePriceToUsdc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"usdcToSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Doberman\",\"kind\":\"dev\",\"methods\":{},\"title\":\"TranchingLogic\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Library for handling the payments waterfall\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/core/TranchingLogic.sol\":\"TranchingLogic\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x2c0b89cef83f353c6f9488c013d8a5968587ffdd6dfc26aad53774214b97e229\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\",\"keccak256\":\"0x62f53f262fabbbc6d8ab49488d8fce36370351aff2b8d3898d499d68995a71c2\",\"license\":\"MIT\"},\"contracts/external/FixedPoint.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\n// solhint-disable\\n// Imported from https://github.com/UMAprotocol/protocol/blob/4d1c8cc47a4df5e79f978cb05647a7432e111a3d/packages/core/contracts/common/implementation/FixedPoint.sol\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\n/**\\n * @title Library for fixed point arithmetic on uints\\n */\\nlibrary FixedPoint {\\n  using SafeMath for uint256;\\n  using SignedSafeMath for int256;\\n\\n  // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n  // For unsigned values:\\n  //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\n  uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n  // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\n  struct Unsigned {\\n    uint256 rawValue;\\n  }\\n\\n  /**\\n   * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5**18`.\\n   * @param a uint to convert into a FixedPoint.\\n   * @return the converted FixedPoint.\\n   */\\n  function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.mul(FP_SCALING_FACTOR));\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue > fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue >= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n    return a.rawValue <= fromUnscaledUint(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n    return fromUnscaledUint(a).rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice The minimum of `a` and `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the minimum of `a` and `b`.\\n   */\\n  function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice The maximum of `a` and `b`.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the maximum of `a` and `b`.\\n   */\\n  function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice Adds two `Unsigned`s, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.add(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return add(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts two `Unsigned`s, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return sub(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\n   * @param a a uint256.\\n   * @param b a FixedPoint.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return sub(fromUnscaledUint(a), b);\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Unsigned`s, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n    // stored internally as a uint256 ~10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n    // would round to 3, but this computation produces the result 2.\\n    // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\n    return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.\\n   * @param b a uint256.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n    uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n    uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n    if (mod != 0) {\\n      return Unsigned(mulFloor.add(1));\\n    } else {\\n      return Unsigned(mulFloor);\\n    }\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.\\n   * @param b a FixedPoint.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\\n    return Unsigned(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n    // 10^41 is stored internally as a uint256 10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n    return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    return Unsigned(a.rawValue.div(b));\\n  }\\n\\n  /**\\n   * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a uint256 numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    return div(fromUnscaledUint(a), b);\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n    uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n    uint256 divFloor = aScaled.div(b.rawValue);\\n    uint256 mod = aScaled.mod(b.rawValue);\\n    if (mod != 0) {\\n      return Unsigned(divFloor.add(1));\\n    } else {\\n      return Unsigned(divFloor);\\n    }\\n  }\\n\\n  /**\\n   * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n    // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\n    // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\n    // This creates the possibility of overflow if b is very large.\\n    return divCeil(a, fromUnscaledUint(b));\\n  }\\n\\n  /**\\n   * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n   * @dev This will \\\"floor\\\" the result.\\n   * @param a a FixedPoint numerator.\\n   * @param b a uint256 denominator.\\n   * @return output is `a` to the power of `b`.\\n   */\\n  function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\n    output = fromUnscaledUint(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n\\n  // ------------------------------------------------- SIGNED -------------------------------------------------------------\\n  // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n  // For signed values:\\n  //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\n  int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n  struct Signed {\\n    int256 rawValue;\\n  }\\n\\n  function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n    require(a.rawValue >= 0, \\\"Negative value provided\\\");\\n    return Unsigned(uint256(a.rawValue));\\n  }\\n\\n  function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\n    require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\n    return Signed(int256(a.rawValue));\\n  }\\n\\n  /**\\n   * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5**18`.\\n   * @param a int to convert into a FixedPoint.Signed.\\n   * @return the converted FixedPoint.Signed.\\n   */\\n  function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n    return Signed(a.mul(SFP_SCALING_FACTOR));\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a int256.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue == fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if equal, or False.\\n   */\\n  function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue == b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue > fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a > b`, or False.\\n   */\\n  function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue > b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue >= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is greater than or equal to `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a >= b`, or False.\\n   */\\n  function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue >= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue < fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a < b`, or False.\\n   */\\n  function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue < b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n    return a.rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n    return a.rawValue <= fromUnscaledInt(b).rawValue;\\n  }\\n\\n  /**\\n   * @notice Whether `a` is less than or equal to `b`.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return True if `a <= b`, or False.\\n   */\\n  function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n    return fromUnscaledInt(a).rawValue <= b.rawValue;\\n  }\\n\\n  /**\\n   * @notice The minimum of `a` and `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the minimum of `a` and `b`.\\n   */\\n  function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return a.rawValue < b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice The maximum of `a` and `b`.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the maximum of `a` and `b`.\\n   */\\n  function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return a.rawValue > b.rawValue ? a : b;\\n  }\\n\\n  /**\\n   * @notice Adds two `Signed`s, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.add(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the sum of `a` and `b`.\\n   */\\n  function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return add(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts two `Signed`s, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.sub(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return sub(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\n   * @param a an int256.\\n   * @param b a FixedPoint.Signed.\\n   * @return the difference of `a` and `b`.\\n   */\\n  function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n    return sub(fromUnscaledInt(a), b);\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Signed`s, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n    // stored internally as an int256 ~10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n    // would round to 3, but this computation produces the result 2.\\n    // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\n    return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\n   * @dev This will \\\"floor\\\" the product.\\n   * @param a a FixedPoint.Signed.\\n   * @param b an int256.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    int256 mulRaw = a.rawValue.mul(b.rawValue);\\n    int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n    // Manual mod because SignedSafeMath doesn't support it.\\n    int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(mulTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(mulTowardsZero);\\n    }\\n  }\\n\\n  /**\\n   * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a FixedPoint.Signed.\\n   * @return the product of `a` and `b`.\\n   */\\n  function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    // Since b is an int, there is no risk of truncation and we can just mul it normally\\n    return Signed(a.rawValue.mul(b));\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    // There are two caveats with this computation:\\n    // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n    // 10^41 is stored internally as an int256 10^59.\\n    // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n    // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n    return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a a FixedPoint numerator.\\n   * @param b an int256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    return Signed(a.rawValue.div(b));\\n  }\\n\\n  /**\\n   * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\n   * @dev This will \\\"floor\\\" the quotient.\\n   * @param a an int256 numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n    return div(fromUnscaledInt(a), b);\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b a FixedPoint denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n    int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n    int256 divTowardsZero = aScaled.div(b.rawValue);\\n    // Manual mod because SignedSafeMath doesn't support it.\\n    int256 mod = aScaled % b.rawValue;\\n    if (mod != 0) {\\n      bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n      int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n      return Signed(divTowardsZero.add(valueToAdd));\\n    } else {\\n      return Signed(divTowardsZero);\\n    }\\n  }\\n\\n  /**\\n   * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n   * @param a a FixedPoint numerator.\\n   * @param b an int256 denominator.\\n   * @return the quotient of `a` divided by `b`.\\n   */\\n  function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n    // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\n    // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\n    // This creates the possibility of overflow if b is very large.\\n    return divAwayFromZero(a, fromUnscaledInt(b));\\n  }\\n\\n  /**\\n   * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n   * @dev This will \\\"floor\\\" the result.\\n   * @param a a FixedPoint.Signed.\\n   * @param b a uint256 (negative exponents are not allowed).\\n   * @return output is `a` to the power of `b`.\\n   */\\n  function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\n    output = fromUnscaledInt(1);\\n    for (uint256 i = 0; i < b; i = i.add(1)) {\\n      output = mul(output, a);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xef56ceabf32470c8c9054fcc93e8d8b7750ee9d009f16adf6bf12a1ef4abb426\",\"license\":\"AGPL-3.0-only\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\ninterface ICreditLine {\\n  function borrower() external view returns (address);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function paymentPeriodInDays() external view returns (uint256);\\n\\n  function principalGracePeriodInDays() external view returns (uint256);\\n\\n  function termInDays() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  // Accounting variables\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xf2086c373a79a01688d42eb3b5ed1a2233c6a9226a75bf86ddbb8f6f5276bffa\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\n\\ninterface IPoolTokens is IERC721Upgradeable {\\n  event TokenMinted(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 tranche\\n  );\\n\\n  event TokenRedeemed(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed,\\n    uint256 tranche\\n  );\\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\\n\\n  struct TokenInfo {\\n    address pool;\\n    uint256 tranche;\\n    uint256 principalAmount;\\n    uint256 principalRedeemed;\\n    uint256 interestRedeemed;\\n  }\\n\\n  struct MintParams {\\n    uint256 principalAmount;\\n    uint256 tranche;\\n  }\\n\\n  function mint(MintParams calldata params, address to) external returns (uint256);\\n\\n  function redeem(\\n    uint256 tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed\\n  ) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function onPoolCreated(address newPool) external;\\n\\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\\n\\n  function validPool(address sender) external view returns (bool);\\n\\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xe5726725621e6306b3f79602d807a5738d63ad64a77e1db86e201a75427e8ec3\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./IV2CreditLine.sol\\\";\\n\\nabstract contract ITranchedPool {\\n  IV2CreditLine public creditLine;\\n  uint256 public createdAt;\\n\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n\\n  struct SliceInfo {\\n    uint256 reserveFeePercent;\\n    uint256 interestAccrued;\\n    uint256 principalAccrued;\\n  }\\n\\n  struct ApplyResult {\\n    uint256 interestRemaining;\\n    uint256 principalRemaining;\\n    uint256 reserveDeduction;\\n    uint256 oldInterestSharePrice;\\n    uint256 oldPrincipalSharePrice;\\n  }\\n\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) public virtual;\\n\\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\\n\\n  function pay(uint256 amount) external virtual;\\n\\n  function lockJuniorCapital() external virtual;\\n\\n  function lockPool() external virtual;\\n\\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\\n\\n  function totalJuniorDeposits() external view virtual returns (uint256);\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function setFundableAt(uint256 timestamp) external virtual;\\n\\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\\n\\n  function assess() external virtual;\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 tokenId);\\n\\n  function availableToWithdraw(uint256 tokenId)\\n    external\\n    view\\n    virtual\\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  function withdraw(uint256 tokenId, uint256 amount)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMax(uint256 tokenId)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\\n}\\n\",\"keccak256\":\"0xbd8d1ee91296df9b944a31d94023937d6dd2893c9fd73e283767653d2b813be5\",\"license\":\"MIT\"},\"contracts/interfaces/IV2CreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"./ICreditLine.sol\\\";\\n\\nabstract contract IV2CreditLine is ICreditLine {\\n  function principal() external view virtual returns (uint256);\\n\\n  function totalInterestAccrued() external view virtual returns (uint256);\\n\\n  function termStartTime() external view virtual returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external virtual;\\n\\n  function setMaxLimit(uint256 newAmount) external virtual;\\n\\n  function setBalance(uint256 newBalance) external virtual;\\n\\n  function setPrincipal(uint256 _principal) external virtual;\\n\\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function assess()\\n    external\\n    virtual\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function initialize(\\n    address _config,\\n    address owner,\\n    address _borrower,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays\\n  ) public virtual;\\n\\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\\n\\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\\n\\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\\n\\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\\n\\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\\n\\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\\n\\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\\n\\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\\n\\n  function updateDobermanConfig() external virtual;\\n}\\n\",\"keccak256\":\"0xe16a99039e2b5f2472a7c520d53bca63fbd412c4169201f552e5e13a6d120af8\",\"license\":\"MIT\"},\"contracts/protocol/core/TranchingLogic.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\nimport \\\"../../interfaces/IV2CreditLine.sol\\\";\\nimport \\\"../../interfaces/ITranchedPool.sol\\\";\\nimport \\\"../../interfaces/IPoolTokens.sol\\\";\\nimport \\\"../../external/FixedPoint.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n/**\\n * @title TranchingLogic\\n * @notice Library for handling the payments waterfall\\n * @author Doberman\\n */\\n\\nlibrary TranchingLogic {\\n  using SafeMath for uint256;\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FixedPoint for uint256;\\n\\n  event SharePriceUpdated(\\n    address indexed pool,\\n    uint256 indexed tranche,\\n    uint256 principalSharePrice,\\n    int256 principalDelta,\\n    uint256 interestSharePrice,\\n    int256 interestDelta\\n  );\\n\\n  uint256 public constant FP_SCALING_FACTOR = 1e18;\\n  uint256 public constant ONE_HUNDRED = 100; // Need this because we cannot call .div on a literal 100\\n\\n  function usdcToSharePrice(uint256 amount, uint256 totalShares) public pure returns (uint256) {\\n    return totalShares == 0 ? 0 : amount.mul(FP_SCALING_FACTOR).div(totalShares);\\n  }\\n\\n  function sharePriceToUsdc(uint256 sharePrice, uint256 totalShares) public pure returns (uint256) {\\n    return sharePrice.mul(totalShares).div(FP_SCALING_FACTOR);\\n  }\\n\\n  function redeemableInterestAndPrincipal(\\n    ITranchedPool.TrancheInfo storage trancheInfo,\\n    IPoolTokens.TokenInfo memory tokenInfo\\n  ) public view returns (uint256 interestRedeemable, uint256 principalRedeemable) {\\n    // This supports withdrawing before or after locking because principal share price starts at 1\\n    // and is set to 0 on lock. Interest share price is always 0 until interest payments come back, when it increases\\n    uint256 maxPrincipalRedeemable = sharePriceToUsdc(trancheInfo.principalSharePrice, tokenInfo.principalAmount);\\n    // The principalAmount is used as the totalShares because we want the interestSharePrice to be expressed as a\\n    // percent of total loan value e.g. if the interest is 10% APR, the interestSharePrice should approach a max of 0.1.\\n    uint256 maxInterestRedeemable = sharePriceToUsdc(trancheInfo.interestSharePrice, tokenInfo.principalAmount);\\n\\n    interestRedeemable = maxInterestRedeemable.sub(tokenInfo.interestRedeemed);\\n    principalRedeemable = maxPrincipalRedeemable.sub(tokenInfo.principalRedeemed);\\n\\n    return (interestRedeemable, principalRedeemable);\\n  }\\n\\n  function calculateExpectedSharePrice(\\n    ITranchedPool.TrancheInfo memory tranche,\\n    uint256 amount,\\n    ITranchedPool.PoolSlice memory slice\\n  ) public pure returns (uint256) {\\n    uint256 sharePrice = usdcToSharePrice(amount, tranche.principalDeposited);\\n    return scaleByPercentOwnership(tranche, sharePrice, slice);\\n  }\\n\\n  function scaleForSlice(\\n    ITranchedPool.PoolSlice memory slice,\\n    uint256 amount,\\n    uint256 totalDeployed\\n  ) public pure returns (uint256) {\\n    return scaleByFraction(amount, slice.principalDeployed, totalDeployed);\\n  }\\n\\n  // We need to create this struct so we don't run into a stack too deep error due to too many variables\\n  function getSliceInfo(\\n    ITranchedPool.PoolSlice memory slice,\\n    IV2CreditLine creditLine,\\n    uint256 totalDeployed,\\n    uint256 reserveFeePercent\\n  ) public view returns (ITranchedPool.SliceInfo memory) {\\n    (uint256 interestAccrued, uint256 principalAccrued) = getTotalInterestAndPrincipal(\\n      slice,\\n      creditLine,\\n      totalDeployed\\n    );\\n    return\\n      ITranchedPool.SliceInfo({\\n        reserveFeePercent: reserveFeePercent,\\n        interestAccrued: interestAccrued,\\n        principalAccrued: principalAccrued\\n      });\\n  }\\n\\n  function getTotalInterestAndPrincipal(\\n    ITranchedPool.PoolSlice memory slice,\\n    IV2CreditLine creditLine,\\n    uint256 totalDeployed\\n  ) public view returns (uint256 interestAccrued, uint256 principalAccrued) {\\n    principalAccrued = creditLine.principalOwed();\\n    // In addition to principal actually owed, we need to account for early principal payments\\n    // If the borrower pays back 5K early on a 10K loan, the actual principal accrued should be\\n    // 5K (balance- deployed) + 0 (principal owed)\\n    principalAccrued = totalDeployed.sub(creditLine.balance()).add(principalAccrued);\\n    // Now we need to scale that correctly for the slice we're interested in\\n    principalAccrued = scaleForSlice(slice, principalAccrued, totalDeployed);\\n    // Finally, we need to account for partial drawdowns. e.g. If 20K was deposited, and only 10K was drawn down,\\n    // Then principal accrued should start at 10K (total deposited - principal deployed), not 0. This is because\\n    // share price starts at 1, and is decremented by what was drawn down.\\n    uint256 totalDeposited = slice.seniorTranche.principalDeposited.add(slice.juniorTranche.principalDeposited);\\n    principalAccrued = totalDeposited.sub(slice.principalDeployed).add(principalAccrued);\\n    return (slice.totalInterestAccrued, principalAccrued);\\n  }\\n\\n  function scaleByFraction(\\n    uint256 amount,\\n    uint256 fraction,\\n    uint256 total\\n  ) public pure returns (uint256) {\\n    FixedPoint.Unsigned memory totalAsFixedPoint = FixedPoint.fromUnscaledUint(total);\\n    FixedPoint.Unsigned memory fractionAsFixedPoint = FixedPoint.fromUnscaledUint(fraction);\\n    return fractionAsFixedPoint.div(totalAsFixedPoint).mul(amount).div(FP_SCALING_FACTOR).rawValue;\\n  }\\n\\n  function applyToAllSeniorTranches(\\n    ITranchedPool.PoolSlice[] storage poolSlices,\\n    uint256 interest,\\n    uint256 principal,\\n    uint256 reserveFeePercent,\\n    uint256 totalDeployed,\\n    IV2CreditLine creditLine,\\n    uint256 juniorFeePercent\\n  ) public returns (ITranchedPool.ApplyResult memory) {\\n    ITranchedPool.ApplyResult memory seniorApplyResult;\\n    for (uint256 i = 0; i < poolSlices.length; i++) {\\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\\n        poolSlices[i],\\n        creditLine,\\n        totalDeployed,\\n        reserveFeePercent\\n      );\\n\\n      // Since slices cannot be created when the loan is late, all interest collected can be assumed to split\\n      // pro-rata across the slices. So we scale the interest and principal to the slice\\n      ITranchedPool.ApplyResult memory applyResult = applyToSeniorTranche(\\n        poolSlices[i],\\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\\n        juniorFeePercent,\\n        sliceInfo\\n      );\\n      emitSharePriceUpdatedEvent(poolSlices[i].seniorTranche, applyResult);\\n      seniorApplyResult.interestRemaining = seniorApplyResult.interestRemaining.add(applyResult.interestRemaining);\\n      seniorApplyResult.principalRemaining = seniorApplyResult.principalRemaining.add(applyResult.principalRemaining);\\n      seniorApplyResult.reserveDeduction = seniorApplyResult.reserveDeduction.add(applyResult.reserveDeduction);\\n    }\\n    return seniorApplyResult;\\n  }\\n\\n  function applyToAllJuniorTranches(\\n    ITranchedPool.PoolSlice[] storage poolSlices,\\n    uint256 interest,\\n    uint256 principal,\\n    uint256 reserveFeePercent,\\n    uint256 totalDeployed,\\n    IV2CreditLine creditLine\\n  ) public returns (uint256 totalReserveAmount) {\\n    for (uint256 i = 0; i < poolSlices.length; i++) {\\n      ITranchedPool.SliceInfo memory sliceInfo = getSliceInfo(\\n        poolSlices[i],\\n        creditLine,\\n        totalDeployed,\\n        reserveFeePercent\\n      );\\n      // Any remaining interest and principal is then shared pro-rata with the junior slices\\n      ITranchedPool.ApplyResult memory applyResult = applyToJuniorTranche(\\n        poolSlices[i],\\n        scaleForSlice(poolSlices[i], interest, totalDeployed),\\n        scaleForSlice(poolSlices[i], principal, totalDeployed),\\n        sliceInfo\\n      );\\n      emitSharePriceUpdatedEvent(poolSlices[i].juniorTranche, applyResult);\\n      totalReserveAmount = totalReserveAmount.add(applyResult.reserveDeduction);\\n    }\\n    return totalReserveAmount;\\n  }\\n\\n  function emitSharePriceUpdatedEvent(\\n    ITranchedPool.TrancheInfo memory tranche,\\n    ITranchedPool.ApplyResult memory applyResult\\n  ) internal {\\n    emit SharePriceUpdated(\\n      address(this),\\n      tranche.id,\\n      tranche.principalSharePrice,\\n      int256(tranche.principalSharePrice.sub(applyResult.oldPrincipalSharePrice)),\\n      tranche.interestSharePrice,\\n      int256(tranche.interestSharePrice.sub(applyResult.oldInterestSharePrice))\\n    );\\n  }\\n\\n  function applyToSeniorTranche(\\n    ITranchedPool.PoolSlice storage slice,\\n    uint256 interestRemaining,\\n    uint256 principalRemaining,\\n    uint256 juniorFeePercent,\\n    ITranchedPool.SliceInfo memory sliceInfo\\n  ) public returns (ITranchedPool.ApplyResult memory) {\\n    // First determine the expected share price for the senior tranche. This is the gross amount the senior\\n    // tranche should receive.\\n    uint256 expectedInterestSharePrice = calculateExpectedSharePrice(\\n      slice.seniorTranche,\\n      sliceInfo.interestAccrued,\\n      slice\\n    );\\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\\n      slice.seniorTranche,\\n      sliceInfo.principalAccrued,\\n      slice\\n    );\\n\\n    // Deduct the junior fee and the protocol reserve\\n    uint256 desiredNetInterestSharePrice = scaleByFraction(\\n      expectedInterestSharePrice,\\n      ONE_HUNDRED.sub(juniorFeePercent.add(sliceInfo.reserveFeePercent)),\\n      ONE_HUNDRED\\n    );\\n    // Collect protocol fee interest received (we've subtracted this from the senior portion above)\\n    uint256 reserveDeduction = scaleByFraction(interestRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\\n    interestRemaining = interestRemaining.sub(reserveDeduction);\\n    uint256 oldInterestSharePrice = slice.seniorTranche.interestSharePrice;\\n    uint256 oldPrincipalSharePrice = slice.seniorTranche.principalSharePrice;\\n    // Apply the interest remaining so we get up to the netInterestSharePrice\\n    (interestRemaining, principalRemaining) = applyBySharePrice(\\n      slice.seniorTranche,\\n      interestRemaining,\\n      principalRemaining,\\n      desiredNetInterestSharePrice,\\n      expectedPrincipalSharePrice\\n    );\\n    return\\n      ITranchedPool.ApplyResult({\\n        interestRemaining: interestRemaining,\\n        principalRemaining: principalRemaining,\\n        reserveDeduction: reserveDeduction,\\n        oldInterestSharePrice: oldInterestSharePrice,\\n        oldPrincipalSharePrice: oldPrincipalSharePrice\\n      });\\n  }\\n\\n  function applyToJuniorTranche(\\n    ITranchedPool.PoolSlice storage slice,\\n    uint256 interestRemaining,\\n    uint256 principalRemaining,\\n    ITranchedPool.SliceInfo memory sliceInfo\\n  ) public returns (ITranchedPool.ApplyResult memory) {\\n    // Then fill up the junior tranche with all the interest remaining, upto the principal share price\\n    uint256 expectedInterestSharePrice = slice.juniorTranche.interestSharePrice.add(\\n      usdcToSharePrice(interestRemaining, slice.juniorTranche.principalDeposited)\\n    );\\n    uint256 expectedPrincipalSharePrice = calculateExpectedSharePrice(\\n      slice.juniorTranche,\\n      sliceInfo.principalAccrued,\\n      slice\\n    );\\n    uint256 oldInterestSharePrice = slice.juniorTranche.interestSharePrice;\\n    uint256 oldPrincipalSharePrice = slice.juniorTranche.principalSharePrice;\\n    (interestRemaining, principalRemaining) = applyBySharePrice(\\n      slice.juniorTranche,\\n      interestRemaining,\\n      principalRemaining,\\n      expectedInterestSharePrice,\\n      expectedPrincipalSharePrice\\n    );\\n\\n    // All remaining interest and principal is applied towards the junior tranche as interest\\n    interestRemaining = interestRemaining.add(principalRemaining);\\n    // Since any principal remaining is treated as interest (there is \\\"extra\\\" interest to be distributed)\\n    // we need to make sure to collect the protocol fee on the additional interest (we only deducted the\\n    // fee on the original interest portion)\\n    uint256 reserveDeduction = scaleByFraction(principalRemaining, sliceInfo.reserveFeePercent, ONE_HUNDRED);\\n    interestRemaining = interestRemaining.sub(reserveDeduction);\\n    principalRemaining = 0;\\n\\n    (interestRemaining, principalRemaining) = applyByAmount(\\n      slice.juniorTranche,\\n      interestRemaining.add(principalRemaining),\\n      0,\\n      interestRemaining.add(principalRemaining),\\n      0\\n    );\\n    return\\n      ITranchedPool.ApplyResult({\\n        interestRemaining: interestRemaining,\\n        principalRemaining: principalRemaining,\\n        reserveDeduction: reserveDeduction,\\n        oldInterestSharePrice: oldInterestSharePrice,\\n        oldPrincipalSharePrice: oldPrincipalSharePrice\\n      });\\n  }\\n\\n  function applyBySharePrice(\\n    ITranchedPool.TrancheInfo storage tranche,\\n    uint256 interestRemaining,\\n    uint256 principalRemaining,\\n    uint256 desiredInterestSharePrice,\\n    uint256 desiredPrincipalSharePrice\\n  ) public returns (uint256, uint256) {\\n    uint256 desiredInterestAmount = desiredAmountFromSharePrice(\\n      desiredInterestSharePrice,\\n      tranche.interestSharePrice,\\n      tranche.principalDeposited\\n    );\\n    uint256 desiredPrincipalAmount = desiredAmountFromSharePrice(\\n      desiredPrincipalSharePrice,\\n      tranche.principalSharePrice,\\n      tranche.principalDeposited\\n    );\\n    return applyByAmount(tranche, interestRemaining, principalRemaining, desiredInterestAmount, desiredPrincipalAmount);\\n  }\\n\\n  function applyByAmount(\\n    ITranchedPool.TrancheInfo storage tranche,\\n    uint256 interestRemaining,\\n    uint256 principalRemaining,\\n    uint256 desiredInterestAmount,\\n    uint256 desiredPrincipalAmount\\n  ) public returns (uint256, uint256) {\\n    uint256 totalShares = tranche.principalDeposited;\\n    uint256 newSharePrice;\\n\\n    (interestRemaining, newSharePrice) = applyToSharePrice(\\n      interestRemaining,\\n      tranche.interestSharePrice,\\n      desiredInterestAmount,\\n      totalShares\\n    );\\n    tranche.interestSharePrice = newSharePrice;\\n\\n    (principalRemaining, newSharePrice) = applyToSharePrice(\\n      principalRemaining,\\n      tranche.principalSharePrice,\\n      desiredPrincipalAmount,\\n      totalShares\\n    );\\n    tranche.principalSharePrice = newSharePrice;\\n    return (interestRemaining, principalRemaining);\\n  }\\n\\n  function migrateAccountingVariables(address originalClAddr, address newClAddr) public {\\n    IV2CreditLine originalCl = IV2CreditLine(originalClAddr);\\n    IV2CreditLine newCl = IV2CreditLine(newClAddr);\\n\\n    // Copy over all accounting variables\\n    newCl.setBalance(originalCl.balance());\\n    newCl.setLimit(originalCl.limit());\\n    newCl.setInterestOwed(originalCl.interestOwed());\\n    newCl.setPrincipalOwed(originalCl.principalOwed());\\n    newCl.setTermEndTime(originalCl.termEndTime());\\n    newCl.setNextDueTime(originalCl.nextDueTime());\\n    newCl.setInterestAccruedAsOf(originalCl.interestAccruedAsOf());\\n    newCl.setLastFullPaymentTime(originalCl.lastFullPaymentTime());\\n    newCl.setTotalInterestAccrued(originalCl.totalInterestAccrued());\\n  }\\n\\n  function closeCreditLine(address originalCl) public {\\n    // Close out old CL\\n    IV2CreditLine oldCreditLine = IV2CreditLine(originalCl);\\n    oldCreditLine.setBalance(0);\\n    oldCreditLine.setLimit(0);\\n    oldCreditLine.setMaxLimit(0);\\n  }\\n\\n  function desiredAmountFromSharePrice(\\n    uint256 desiredSharePrice,\\n    uint256 actualSharePrice,\\n    uint256 totalShares\\n  ) public pure returns (uint256) {\\n    // If the desired share price is lower, then ignore it, and leave it unchanged\\n    if (desiredSharePrice < actualSharePrice) {\\n      desiredSharePrice = actualSharePrice;\\n    }\\n    uint256 sharePriceDifference = desiredSharePrice.sub(actualSharePrice);\\n    return sharePriceToUsdc(sharePriceDifference, totalShares);\\n  }\\n\\n  function applyToSharePrice(\\n    uint256 amountRemaining,\\n    uint256 currentSharePrice,\\n    uint256 desiredAmount,\\n    uint256 totalShares\\n  ) public pure returns (uint256, uint256) {\\n    // If no money left to apply, or don't need any changes, return the original amounts\\n    if (amountRemaining == 0 || desiredAmount == 0) {\\n      return (amountRemaining, currentSharePrice);\\n    }\\n    if (amountRemaining < desiredAmount) {\\n      // We don't have enough money to adjust share price to the desired level. So just use whatever amount is left\\n      desiredAmount = amountRemaining;\\n    }\\n    uint256 sharePriceDifference = usdcToSharePrice(desiredAmount, totalShares);\\n    return (amountRemaining.sub(desiredAmount), currentSharePrice.add(sharePriceDifference));\\n  }\\n\\n  function scaleByPercentOwnership(\\n    ITranchedPool.TrancheInfo memory tranche,\\n    uint256 amount,\\n    ITranchedPool.PoolSlice memory slice\\n  ) public pure returns (uint256) {\\n    uint256 totalDeposited = slice.juniorTranche.principalDeposited.add(slice.seniorTranche.principalDeposited);\\n    return scaleByFraction(amount, tranche.principalDeposited, totalDeposited);\\n  }\\n}\\n\",\"keccak256\":\"0x917cdefd8f1972860da3c126dfd1a546936eb22af20ef65c8496beb2db5d57d1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61240b61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106101415760003560e01c80638c48a764116100c2578063bfaa8cca11610086578063bfaa8cca1461033b578063cde8884514610343578063cee38ee414610356578063d8eb673e14610369578063f7fc24b214610389578063ff0825bc1461039c57600080fd5b80638c48a764146102a05780638e3875b6146102c05780639d82cfd2146102f5578063a59387cd14610308578063af5f57531461032857600080fd5b80635df6b2ed116101095780635df6b2ed146101e957806368dcfdc0146101fc5780636dd0a9b51461020b57806384810cb01461022b57806385bd324d1461023e57600080fd5b80630174b449146101465780630a9f9a141461016c57806321a0aa7d1461018e5780632e76cb89146101a157806330785368146101c9575b600080fd5b61015961015436600461226a565b6103bc565b6040519081526020015b60405180910390f35b81801561017857600080fd5b5061018c610187366004611f15565b6103e1565b005b61015961019c36600461228b565b6104f5565b6101b46101af3660046122b6565b610524565b60408051928352602083019190915201610163565b8180156101d557600080fd5b506101596101e4366004611f69565b61057e565b6101b46101f736600461201c565b61091d565b610159670de0b6b3a764000081565b81801561021757600080fd5b506101b4610226366004612218565b610a78565b6101596102393660046120a6565b610aca565b81801561024a57600080fd5b5061025e610259366004611fbd565b610ae3565b6040516101639190600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b8180156102ac57600080fd5b506101b46102bb366004612218565b610ec1565b6102d36102ce36600461205e565b610f0f565b6040805182518152602080840151908201529181015190820152606001610163565b610159610303366004612164565b610f65565b81801561031457600080fd5b5061025e61032336600461211b565b610f83565b610159610336366004612164565b6111fb565b610159606481565b61015961035136600461226a565b611232565b61015961036436600461228b565b61125e565b81801561037557600080fd5b5061025e6103843660046120dc565b6112aa565b6101b46103973660046121a2565b61147b565b8180156103a857600080fd5b5061018c6103b7366004611f31565b6114e5565b60006103da670de0b6b3a76400006103d48585611c45565b90611c51565b9392505050565b604051637d8b34e560e11b81526000600482015281906001600160a01b0382169063fb1669ca90602401600060405180830381600087803b15801561042557600080fd5b505af1158015610439573d6000803e3d6000fd5b50506040516327ea6f2b60e01b8152600060048201526001600160a01b03841692506327ea6f2b9150602401600060405180830381600087803b15801561047f57600080fd5b505af1158015610493573d6000803e3d6000fd5b5050604051632fe2f3b960e21b8152600060048201526001600160a01b038416925063bf8bcee49150602401600060405180830381600087803b1580156104d957600080fd5b505af11580156104ed573d6000803e3d6000fd5b505050505050565b600082841015610503578293505b600061050f8585611c5d565b905061051b81846103bc565b95945050505050565b600080851580610532575083155b15610541575084905083610575565b8386101561054d578593505b60006105598585611232565b90506105658786611c5d565b61056f8783611c69565b92509250505b94509492505050565b6000805b87548110156109125760006106718983815481106105b057634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050858789610f0f565b905060006108728a848154811061069857634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016107898c86815481106106c957634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508c8a610aca565b61086c8d87815481106107ac57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508c8b610aca565b856112aa565b90506108eb8a848154811061089757634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016005016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505082611c75565b60408101516108fb908590611c69565b93505050808061090a9061238c565b915050610582565b509695505050505050565b600080836001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561095957600080fd5b505afa15801561096d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109919190612252565b9050610a1881610a12866001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b1580156109d357600080fd5b505afa1580156109e7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0b9190612252565b8690611c5d565b90611c69565b9050610a25858285610aca565b90506000610a4c866020015160200151876000015160200151611c6990919063ffffffff16565b9050610a6982610a12886060015184611c5d90919063ffffffff16565b60409096015196945050505050565b6000806000876001015490506000610a96888a600301548885610524565b60038b0181905560028b01549199509150610ab49088908785610524565b60029a909a019990995550959795505050505050565b6000610adb8385606001518461125e565b949350505050565b610aeb611db0565b610af3611db0565b60005b8954811015610eb4576000610be58b8381548110610b2457634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b8201548152505087898b610f0f565b90506000610de78c8481548110610c0c57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201610cfd8e8681548110610c3d57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508e8c610aca565b610de08f8781548110610d2057634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508e8d610aca565b8986610f83565b9050610e608c8481548110610e0c57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016000016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505082611c75565b80518451610e6d91611c69565b845260208082015190850151610e8291611c69565b602085015260408082015190850151610e9a91611c69565b604085015250819050610eac8161238c565b915050610af6565b5098975050505050505050565b6000806000610ed98589600301548a600101546104f5565b90506000610ef0858a600201548b600101546104f5565b9050610eff8989898585610a78565b9350935050509550959350505050565b610f3360405180606001604052806000815260200160008152602001600081525090565b600080610f4187878761091d565b60408051606081018252878152602081019390935282015292505050949350505050565b600080610f76848660200151611232565b905061051b8582856111fb565b610f8b611db0565b6040805160a08082018352885480835260018a0154602080850182905260028c015485870181905260038d0154606080880182905260048f01546080808a018290528c8601518b5161012081018d52808301998a52808b019890985260c088019590955260e08701939093526101008601529484528751958601885260058e0154865260068e01548684015260078e01548689015260088e01548686015260098e01549086015290820193909352600a8b015494810194909452600b8a01549084015260009261105c929190610f65565b9050600061115a886000016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505085604001518a604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050610f65565b9050600061118b8361118461117c88600001518a611c6990919063ffffffff16565b606490611c5d565b606461125e565b9050600061119f898760000151606461125e565b90506111ab8982611c5d565b60038b015460028c0154919a50906111c68c8c8c8789610ec1565b6040805160a0810182529283526020830191909152810193909352606083019190915260808201529998505050505050505050565b600080611221836000015160200151846020015160200151611c6990919063ffffffff16565b905061051b8486602001518361125e565b6000811561125557611250826103d485670de0b6b3a7640000611c45565b6103da565b50600092915050565b60008061126a83611cec565b9050600061127785611cec565b905061129f670de0b6b3a7640000611299886112938587611d21565b90611d60565b90611d88565b519695505050505050565b6112b2611db0565b60006112d36112c8868860050160010154611232565b600888015490611c69565b905060006113d1876005016040518060a001604052908160008201548152602001600182015481526020016002820154815260200160038201548152602001600482015481525050856040015189604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050610f65565b60088801546007890154919250906113ef60058a0189898787610ec1565b90985096506113fe8888611c69565b97506000611412888860000151606461125e565b905061141e8982611c5d565b98506000975061144860058b016114358b8b611c69565b60006114418d8d611c69565b6000610a78565b6040805160a081018252928352602083019190915281019190915260608101929092526080820152979650505050505050565b6000806000611492856002015485604001516103bc565b905060006114a8866003015486604001516103bc565b90506114c1856080015182611c5d90919063ffffffff16565b93506114da856060015183611c5d90919063ffffffff16565b925050509250929050565b60008290506000829050806001600160a01b031663fb1669ca836001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561153757600080fd5b505afa15801561154b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061156f9190612252565b6040518263ffffffff1660e01b815260040161158d91815260200190565b600060405180830381600087803b1580156115a757600080fd5b505af11580156115bb573d6000803e3d6000fd5b50505050806001600160a01b03166327ea6f2b836001600160a01b031663a4d66daf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561160757600080fd5b505afa15801561161b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163f9190612252565b6040518263ffffffff1660e01b815260040161165d91815260200190565b600060405180830381600087803b15801561167757600080fd5b505af115801561168b573d6000803e3d6000fd5b50505050806001600160a01b03166396c8df37836001600160a01b03166321856b366040518163ffffffff1660e01b815260040160206040518083038186803b1580156116d757600080fd5b505afa1580156116eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170f9190612252565b6040518263ffffffff1660e01b815260040161172d91815260200190565b600060405180830381600087803b15801561174757600080fd5b505af115801561175b573d6000803e3d6000fd5b50505050806001600160a01b031663b3b8a9c7836001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b1580156117a757600080fd5b505afa1580156117bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117df9190612252565b6040518263ffffffff1660e01b81526004016117fd91815260200190565b600060405180830381600087803b15801561181757600080fd5b505af115801561182b573d6000803e3d6000fd5b50505050806001600160a01b0316637ae14b09836001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561187757600080fd5b505afa15801561188b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118af9190612252565b6040518263ffffffff1660e01b81526004016118cd91815260200190565b600060405180830381600087803b1580156118e757600080fd5b505af11580156118fb573d6000803e3d6000fd5b50505050806001600160a01b03166326a40e82836001600160a01b031663d28459776040518163ffffffff1660e01b815260040160206040518083038186803b15801561194757600080fd5b505afa15801561195b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061197f9190612252565b6040518263ffffffff1660e01b815260040161199d91815260200190565b600060405180830381600087803b1580156119b757600080fd5b505af11580156119cb573d6000803e3d6000fd5b50505050806001600160a01b031663a6b1ae0d836001600160a01b031663bbafcb406040518163ffffffff1660e01b815260040160206040518083038186803b158015611a1757600080fd5b505afa158015611a2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4f9190612252565b6040518263ffffffff1660e01b8152600401611a6d91815260200190565b600060405180830381600087803b158015611a8757600080fd5b505af1158015611a9b573d6000803e3d6000fd5b50505050806001600160a01b03166336d91494836001600160a01b031663ce78290d6040518163ffffffff1660e01b815260040160206040518083038186803b158015611ae757600080fd5b505afa158015611afb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b1f9190612252565b6040518263ffffffff1660e01b8152600401611b3d91815260200190565b600060405180830381600087803b158015611b5757600080fd5b505af1158015611b6b573d6000803e3d6000fd5b50505050806001600160a01b031663033669cf836001600160a01b0316631cd724ac6040518163ffffffff1660e01b815260040160206040518083038186803b158015611bb757600080fd5b505afa158015611bcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bef9190612252565b6040518263ffffffff1660e01b8152600401611c0d91815260200190565b600060405180830381600087803b158015611c2757600080fd5b505af1158015611c3b573d6000803e3d6000fd5b5050505050505050565b60006103da8284612356565b60006103da8284612336565b60006103da8284612375565b60006103da828461231e565b81516040830151608083015130917f42a55d7508b1c40b53524cf7cc2558b0f6bc7c4f262a3e929b65cd48bec2b68791611cb0908290611c5d565b60608088015190870151611cc5908290611c5d565b60408051948552602085019390935291830152606082015260800160405180910390a35050565b604080516020810190915260008152604080516020810190915280611d1984670de0b6b3a7640000611c45565b905292915050565b6040805160208101909152600081526040805160208101909152825184518291611d57916103d490670de0b6b3a7640000611c45565b90529392505050565b604080516020810190915260008152604080516020810190915283518190611d579085611c45565b604080516020810190915260008152604080516020810190915283518190611d579085611c51565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006101808284031215611df1578081fd5b6040516080810181811067ffffffffffffffff82111715611e2057634e487b7160e01b83526041600452602483fd5b604052905080611e308484611ec8565b8152611e3f8460a08501611ec8565b6020820152610140830135604082015261016083013560608201525092915050565b600060608284031215611e72578081fd5b6040516060810181811067ffffffffffffffff82111715611ea157634e487b7160e01b83526041600452602483fd5b80604052508091508235815260208301356020820152604083013560408201525092915050565b600060a08284031215611ed9578081fd5b611ee16122e7565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015292915050565b600060208284031215611f26578081fd5b81356103da816123bd565b60008060408385031215611f43578081fd5b8235611f4e816123bd565b91506020830135611f5e816123bd565b809150509250929050565b60008060008060008060c08789031215611f81578182fd5b863595506020870135945060408701359350606087013592506080870135915060a0870135611faf816123bd565b809150509295509295509295565b600080600080600080600060e0888a031215611fd7578081fd5b873596506020880135955060408801359450606088013593506080880135925060a0880135612005816123bd565b8092505060c0880135905092959891949750929550565b60008060006101c08486031215612031578283fd5b61203b8585611ddf565b925061018084013561204c816123bd565b929592945050506101a0919091013590565b6000806000806101e08587031215612074578384fd5b61207e8686611ddf565b935061018085013561208f816123bd565b93969395505050506101a0820135916101c0013590565b60008060006101c084860312156120bb578081fd5b6120c58585611ddf565b9561018085013595506101a0909401359392505050565b60008060008060c085870312156120f1578182fd5b8435935060208501359250604085013591506121108660608701611e61565b905092959194509250565b600080600080600060e08688031215612132578283fd5b853594506020860135935060408601359250606086013591506121588760808801611e61565b90509295509295909350565b60008060006102408486031215612179578081fd5b6121838585611ec8565b925060a084013591506121998560c08601611ddf565b90509250925092565b60008082840360c08112156121b5578283fd5b8335925060a0601f19820112156121ca578182fd5b506121d36122e7565b60208401356121e1816123bd565b8082525060408401356020820152606084013560408201526080840135606082015260a08401356080820152809150509250929050565b600080600080600060a0868803121561222f578283fd5b505083359560208501359550604085013594606081013594506080013592509050565b600060208284031215612263578081fd5b5051919050565b6000806040838503121561227c578182fd5b50508035926020909101359150565b60008060006060848603121561229f578081fd5b505081359360208301359350604090920135919050565b600080600080608085870312156122cb578182fd5b5050823594602084013594506040840135936060013592509050565b60405160a0810167ffffffffffffffff8111828210171561231857634e487b7160e01b600052604160045260246000fd5b60405290565b60008219821115612331576123316123a7565b500190565b60008261235157634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612370576123706123a7565b500290565b600082821015612387576123876123a7565b500390565b60006000198214156123a0576123a06123a7565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b03811681146123d257600080fd5b5056fea26469706673582212209100fc872ddef1d2b74d85254be6c04cd93d6bd0b3dddb19517ef7367953b4a464736f6c63430008040033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106101415760003560e01c80638c48a764116100c2578063bfaa8cca11610086578063bfaa8cca1461033b578063cde8884514610343578063cee38ee414610356578063d8eb673e14610369578063f7fc24b214610389578063ff0825bc1461039c57600080fd5b80638c48a764146102a05780638e3875b6146102c05780639d82cfd2146102f5578063a59387cd14610308578063af5f57531461032857600080fd5b80635df6b2ed116101095780635df6b2ed146101e957806368dcfdc0146101fc5780636dd0a9b51461020b57806384810cb01461022b57806385bd324d1461023e57600080fd5b80630174b449146101465780630a9f9a141461016c57806321a0aa7d1461018e5780632e76cb89146101a157806330785368146101c9575b600080fd5b61015961015436600461226a565b6103bc565b6040519081526020015b60405180910390f35b81801561017857600080fd5b5061018c610187366004611f15565b6103e1565b005b61015961019c36600461228b565b6104f5565b6101b46101af3660046122b6565b610524565b60408051928352602083019190915201610163565b8180156101d557600080fd5b506101596101e4366004611f69565b61057e565b6101b46101f736600461201c565b61091d565b610159670de0b6b3a764000081565b81801561021757600080fd5b506101b4610226366004612218565b610a78565b6101596102393660046120a6565b610aca565b81801561024a57600080fd5b5061025e610259366004611fbd565b610ae3565b6040516101639190600060a082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015292915050565b8180156102ac57600080fd5b506101b46102bb366004612218565b610ec1565b6102d36102ce36600461205e565b610f0f565b6040805182518152602080840151908201529181015190820152606001610163565b610159610303366004612164565b610f65565b81801561031457600080fd5b5061025e61032336600461211b565b610f83565b610159610336366004612164565b6111fb565b610159606481565b61015961035136600461226a565b611232565b61015961036436600461228b565b61125e565b81801561037557600080fd5b5061025e6103843660046120dc565b6112aa565b6101b46103973660046121a2565b61147b565b8180156103a857600080fd5b5061018c6103b7366004611f31565b6114e5565b60006103da670de0b6b3a76400006103d48585611c45565b90611c51565b9392505050565b604051637d8b34e560e11b81526000600482015281906001600160a01b0382169063fb1669ca90602401600060405180830381600087803b15801561042557600080fd5b505af1158015610439573d6000803e3d6000fd5b50506040516327ea6f2b60e01b8152600060048201526001600160a01b03841692506327ea6f2b9150602401600060405180830381600087803b15801561047f57600080fd5b505af1158015610493573d6000803e3d6000fd5b5050604051632fe2f3b960e21b8152600060048201526001600160a01b038416925063bf8bcee49150602401600060405180830381600087803b1580156104d957600080fd5b505af11580156104ed573d6000803e3d6000fd5b505050505050565b600082841015610503578293505b600061050f8585611c5d565b905061051b81846103bc565b95945050505050565b600080851580610532575083155b15610541575084905083610575565b8386101561054d578593505b60006105598585611232565b90506105658786611c5d565b61056f8783611c69565b92509250505b94509492505050565b6000805b87548110156109125760006106718983815481106105b057634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050858789610f0f565b905060006108728a848154811061069857634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016107898c86815481106106c957634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508c8a610aca565b61086c8d87815481106107ac57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508c8b610aca565b856112aa565b90506108eb8a848154811061089757634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016005016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505082611c75565b60408101516108fb908590611c69565b93505050808061090a9061238c565b915050610582565b509695505050505050565b600080836001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b15801561095957600080fd5b505afa15801561096d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109919190612252565b9050610a1881610a12866001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b1580156109d357600080fd5b505afa1580156109e7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a0b9190612252565b8690611c5d565b90611c69565b9050610a25858285610aca565b90506000610a4c866020015160200151876000015160200151611c6990919063ffffffff16565b9050610a6982610a12886060015184611c5d90919063ffffffff16565b60409096015196945050505050565b6000806000876001015490506000610a96888a600301548885610524565b60038b0181905560028b01549199509150610ab49088908785610524565b60029a909a019990995550959795505050505050565b6000610adb8385606001518461125e565b949350505050565b610aeb611db0565b610af3611db0565b60005b8954811015610eb4576000610be58b8381548110610b2457634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b8201548152505087898b610f0f565b90506000610de78c8481548110610c0c57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201610cfd8e8681548110610c3d57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508e8c610aca565b610de08f8781548110610d2057634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c0201604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b820154815250508e8d610aca565b8986610f83565b9050610e608c8481548110610e0c57634e487b7160e01b600052603260045260246000fd5b90600052602060002090600c02016000016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505082611c75565b80518451610e6d91611c69565b845260208082015190850151610e8291611c69565b602085015260408082015190850151610e9a91611c69565b604085015250819050610eac8161238c565b915050610af6565b5098975050505050505050565b6000806000610ed98589600301548a600101546104f5565b90506000610ef0858a600201548b600101546104f5565b9050610eff8989898585610a78565b9350935050509550959350505050565b610f3360405180606001604052806000815260200160008152602001600081525090565b600080610f4187878761091d565b60408051606081018252878152602081019390935282015292505050949350505050565b600080610f76848660200151611232565b905061051b8582856111fb565b610f8b611db0565b6040805160a08082018352885480835260018a0154602080850182905260028c015485870181905260038d0154606080880182905260048f01546080808a018290528c8601518b5161012081018d52808301998a52808b019890985260c088019590955260e08701939093526101008601529484528751958601885260058e0154865260068e01548684015260078e01548689015260088e01548686015260098e01549086015290820193909352600a8b015494810194909452600b8a01549084015260009261105c929190610f65565b9050600061115a886000016040518060a00160405290816000820154815260200160018201548152602001600282015481526020016003820154815260200160048201548152505085604001518a604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050610f65565b9050600061118b8361118461117c88600001518a611c6990919063ffffffff16565b606490611c5d565b606461125e565b9050600061119f898760000151606461125e565b90506111ab8982611c5d565b60038b015460028c0154919a50906111c68c8c8c8789610ec1565b6040805160a0810182529283526020830191909152810193909352606083019190915260808201529998505050505050505050565b600080611221836000015160200151846020015160200151611c6990919063ffffffff16565b905061051b8486602001518361125e565b6000811561125557611250826103d485670de0b6b3a7640000611c45565b6103da565b50600092915050565b60008061126a83611cec565b9050600061127785611cec565b905061129f670de0b6b3a7640000611299886112938587611d21565b90611d60565b90611d88565b519695505050505050565b6112b2611db0565b60006112d36112c8868860050160010154611232565b600888015490611c69565b905060006113d1876005016040518060a001604052908160008201548152602001600182015481526020016002820154815260200160038201548152602001600482015481525050856040015189604051806080016040529081600082016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600582016040518060a0016040529081600082015481526020016001820154815260200160028201548152602001600382015481526020016004820154815250508152602001600a8201548152602001600b82015481525050610f65565b60088801546007890154919250906113ef60058a0189898787610ec1565b90985096506113fe8888611c69565b97506000611412888860000151606461125e565b905061141e8982611c5d565b98506000975061144860058b016114358b8b611c69565b60006114418d8d611c69565b6000610a78565b6040805160a081018252928352602083019190915281019190915260608101929092526080820152979650505050505050565b6000806000611492856002015485604001516103bc565b905060006114a8866003015486604001516103bc565b90506114c1856080015182611c5d90919063ffffffff16565b93506114da856060015183611c5d90919063ffffffff16565b925050509250929050565b60008290506000829050806001600160a01b031663fb1669ca836001600160a01b031663b69ef8a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561153757600080fd5b505afa15801561154b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061156f9190612252565b6040518263ffffffff1660e01b815260040161158d91815260200190565b600060405180830381600087803b1580156115a757600080fd5b505af11580156115bb573d6000803e3d6000fd5b50505050806001600160a01b03166327ea6f2b836001600160a01b031663a4d66daf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561160757600080fd5b505afa15801561161b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061163f9190612252565b6040518263ffffffff1660e01b815260040161165d91815260200190565b600060405180830381600087803b15801561167757600080fd5b505af115801561168b573d6000803e3d6000fd5b50505050806001600160a01b03166396c8df37836001600160a01b03166321856b366040518163ffffffff1660e01b815260040160206040518083038186803b1580156116d757600080fd5b505afa1580156116eb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061170f9190612252565b6040518263ffffffff1660e01b815260040161172d91815260200190565b600060405180830381600087803b15801561174757600080fd5b505af115801561175b573d6000803e3d6000fd5b50505050806001600160a01b031663b3b8a9c7836001600160a01b031663193501146040518163ffffffff1660e01b815260040160206040518083038186803b1580156117a757600080fd5b505afa1580156117bb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117df9190612252565b6040518263ffffffff1660e01b81526004016117fd91815260200190565b600060405180830381600087803b15801561181757600080fd5b505af115801561182b573d6000803e3d6000fd5b50505050806001600160a01b0316637ae14b09836001600160a01b03166364fb2d956040518163ffffffff1660e01b815260040160206040518083038186803b15801561187757600080fd5b505afa15801561188b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118af9190612252565b6040518263ffffffff1660e01b81526004016118cd91815260200190565b600060405180830381600087803b1580156118e757600080fd5b505af11580156118fb573d6000803e3d6000fd5b50505050806001600160a01b03166326a40e82836001600160a01b031663d28459776040518163ffffffff1660e01b815260040160206040518083038186803b15801561194757600080fd5b505afa15801561195b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061197f9190612252565b6040518263ffffffff1660e01b815260040161199d91815260200190565b600060405180830381600087803b1580156119b757600080fd5b505af11580156119cb573d6000803e3d6000fd5b50505050806001600160a01b031663a6b1ae0d836001600160a01b031663bbafcb406040518163ffffffff1660e01b815260040160206040518083038186803b158015611a1757600080fd5b505afa158015611a2b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4f9190612252565b6040518263ffffffff1660e01b8152600401611a6d91815260200190565b600060405180830381600087803b158015611a8757600080fd5b505af1158015611a9b573d6000803e3d6000fd5b50505050806001600160a01b03166336d91494836001600160a01b031663ce78290d6040518163ffffffff1660e01b815260040160206040518083038186803b158015611ae757600080fd5b505afa158015611afb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b1f9190612252565b6040518263ffffffff1660e01b8152600401611b3d91815260200190565b600060405180830381600087803b158015611b5757600080fd5b505af1158015611b6b573d6000803e3d6000fd5b50505050806001600160a01b031663033669cf836001600160a01b0316631cd724ac6040518163ffffffff1660e01b815260040160206040518083038186803b158015611bb757600080fd5b505afa158015611bcb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bef9190612252565b6040518263ffffffff1660e01b8152600401611c0d91815260200190565b600060405180830381600087803b158015611c2757600080fd5b505af1158015611c3b573d6000803e3d6000fd5b5050505050505050565b60006103da8284612356565b60006103da8284612336565b60006103da8284612375565b60006103da828461231e565b81516040830151608083015130917f42a55d7508b1c40b53524cf7cc2558b0f6bc7c4f262a3e929b65cd48bec2b68791611cb0908290611c5d565b60608088015190870151611cc5908290611c5d565b60408051948552602085019390935291830152606082015260800160405180910390a35050565b604080516020810190915260008152604080516020810190915280611d1984670de0b6b3a7640000611c45565b905292915050565b6040805160208101909152600081526040805160208101909152825184518291611d57916103d490670de0b6b3a7640000611c45565b90529392505050565b604080516020810190915260008152604080516020810190915283518190611d579085611c45565b604080516020810190915260008152604080516020810190915283518190611d579085611c51565b6040518060a0016040528060008152602001600081526020016000815260200160008152602001600081525090565b60006101808284031215611df1578081fd5b6040516080810181811067ffffffffffffffff82111715611e2057634e487b7160e01b83526041600452602483fd5b604052905080611e308484611ec8565b8152611e3f8460a08501611ec8565b6020820152610140830135604082015261016083013560608201525092915050565b600060608284031215611e72578081fd5b6040516060810181811067ffffffffffffffff82111715611ea157634e487b7160e01b83526041600452602483fd5b80604052508091508235815260208301356020820152604083013560408201525092915050565b600060a08284031215611ed9578081fd5b611ee16122e7565b9050813581526020820135602082015260408201356040820152606082013560608201526080820135608082015292915050565b600060208284031215611f26578081fd5b81356103da816123bd565b60008060408385031215611f43578081fd5b8235611f4e816123bd565b91506020830135611f5e816123bd565b809150509250929050565b60008060008060008060c08789031215611f81578182fd5b863595506020870135945060408701359350606087013592506080870135915060a0870135611faf816123bd565b809150509295509295509295565b600080600080600080600060e0888a031215611fd7578081fd5b873596506020880135955060408801359450606088013593506080880135925060a0880135612005816123bd565b8092505060c0880135905092959891949750929550565b60008060006101c08486031215612031578283fd5b61203b8585611ddf565b925061018084013561204c816123bd565b929592945050506101a0919091013590565b6000806000806101e08587031215612074578384fd5b61207e8686611ddf565b935061018085013561208f816123bd565b93969395505050506101a0820135916101c0013590565b60008060006101c084860312156120bb578081fd5b6120c58585611ddf565b9561018085013595506101a0909401359392505050565b60008060008060c085870312156120f1578182fd5b8435935060208501359250604085013591506121108660608701611e61565b905092959194509250565b600080600080600060e08688031215612132578283fd5b853594506020860135935060408601359250606086013591506121588760808801611e61565b90509295509295909350565b60008060006102408486031215612179578081fd5b6121838585611ec8565b925060a084013591506121998560c08601611ddf565b90509250925092565b60008082840360c08112156121b5578283fd5b8335925060a0601f19820112156121ca578182fd5b506121d36122e7565b60208401356121e1816123bd565b8082525060408401356020820152606084013560408201526080840135606082015260a08401356080820152809150509250929050565b600080600080600060a0868803121561222f578283fd5b505083359560208501359550604085013594606081013594506080013592509050565b600060208284031215612263578081fd5b5051919050565b6000806040838503121561227c578182fd5b50508035926020909101359150565b60008060006060848603121561229f578081fd5b505081359360208301359350604090920135919050565b600080600080608085870312156122cb578182fd5b5050823594602084013594506040840135936060013592509050565b60405160a0810167ffffffffffffffff8111828210171561231857634e487b7160e01b600052604160045260246000fd5b60405290565b60008219821115612331576123316123a7565b500190565b60008261235157634e487b7160e01b81526012600452602481fd5b500490565b6000816000190483118215151615612370576123706123a7565b500290565b600082821015612387576123876123a7565b500390565b60006000198214156123a0576123a06123a7565b5060010190565b634e487b7160e01b600052601160045260246000fd5b6001600160a01b03811681146123d257600080fd5b5056fea26469706673582212209100fc872ddef1d2b74d85254be6c04cd93d6bd0b3dddb19517ef7367953b4a464736f6c63430008040033",
  "devdoc": {
    "author": "Doberman",
    "kind": "dev",
    "methods": {},
    "title": "TranchingLogic",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Library for handling the payments waterfall",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}